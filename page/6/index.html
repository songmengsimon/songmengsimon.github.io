<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/xxw/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/xxw/pace/pace-theme-minimal.min.css">
  <script src="/xxw/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dhkkk.gitee.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="记录一些学习日常">
<meta property="og:type" content="website">
<meta property="og:title" content="小董的BLOG">
<meta property="og:url" content="https://dhkkk.gitee.io/page/6/index.html">
<meta property="og:site_name" content="小董的BLOG">
<meta property="og:description" content="记录一些学习日常">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="dhk">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dhkkk.gitee.io/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>
#needsharebutton-postbottom {
  cursor: pointer;
  height: 26px;
  margin-top: 10px;
  position: relative;
}
#needsharebutton-postbottom .btn {
  border: 1px solid $btn-default-border-color;
  border-radius: 3px;
  display: initial;
  padding: 1px 4px;
}
</style>
  <title>小董的BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">小董的BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-目录">

    <a href="/tags/" rel="section"><i class="fa fa-tag fa-fw"></i>目录</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dhkkk.gitee.io/2023/01/12/C++-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zoe.gif">
      <meta itemprop="name" content="dhk">
      <meta itemprop="description" content="记录一些学习日常">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小董的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/12/C++-8/" class="post-title-link" itemprop="url">C++-顺序容器</a>
        </h2>

        <div class="post-meta">
		  
		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-12 14:40:06" itemprop="dateCreated datePublished" datetime="2023-01-12T14:40:06+08:00">2023-01-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-31 23:35:50" itemprop="dateModified" datetime="2023-01-31T23:35:50+08:00">2023-01-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h1><p>容器：一些特定类型对象的集合。顺序容器提供了控制元素存储和访问顺序的能力，且该顺序与元素的内容无关，而与元素加入容器时的位置相关</p>
<h2 id="标准库中的顺序容器"><a href="#标准库中的顺序容器" class="headerlink" title="标准库中的顺序容器"></a>标准库中的顺序容器</h2><p>C++中提供了多种多种顺序容器，这些容器根据下两方面性能的选择都有不同的折中：</p>
<ul>
<li>向容器中不同位置添加、删除元素的代价</li>
<li>非顺序访问容器中的元素的代价</li>
</ul>
<table>
<thead>
<tr>
<th>vector</th>
<th>可变大小数组；支持快速任意元素随机访问；在尾部之外插入元素代价较大</th>
</tr>
</thead>
<tbody><tr>
<td>deque</td>
<td>双端队列；支持快速任意元素随机访问；<strong>在头、尾部之外</strong>插入元素代价较大</td>
</tr>
<tr>
<td>list</td>
<td>双向链表；只支持双向<strong>顺序访问</strong>，不支持随机访问；任何位置插入元素速度都快</td>
</tr>
<tr>
<td>forward_list</td>
<td>单向链表，只支持单向顺序访问，其余同双向链表</td>
</tr>
<tr>
<td>array</td>
<td>固定大小数组；支持快速任意元素随机访问；不能添加、删除元素</td>
</tr>
<tr>
<td>string</td>
<td>字符串，与vector相似，专门用于保存字符；在尾部之外插入元素代价较大</td>
</tr>
</tbody></table>
<p>array是C++新标准添加的类型，比内置的数组更加安全、更容易使用</p>
<h2 id="选择顺序容器的原则"><a href="#选择顺序容器的原则" class="headerlink" title="选择顺序容器的原则"></a>选择顺序容器的原则</h2><ul>
<li><p>通常，使用vector是最好的选择</p>
</li>
<li><p>如果需存放的元素很多、元素很小，并且空间的开销很重要，则<strong>不要选择</strong>list或forward_list</p>
</li>
<li><p>其余原则根据：</p>
<ul>
<li>程序是否要随机访问元素</li>
<li>程序是否要在中间、头部、尾部插入元素</li>
</ul>
<p>进行选择</p>
</li>
<li><p>如果程序只在读取输入时才需要在中间位置插入元素，随后只需要随机访问元素：</p>
<p>可以在输入阶段使用list，输入完成后将元素拷贝至一个vector</p>
</li>
</ul>
<p>如果目前不确定使用哪种容器，可以先选定一个容器类型，在程序中只使用vector和list的公共操作：使用迭代器，而不是使用下标。这样后续改变容器类型会很方便</p>
<h1 id="容器通用操作"><a href="#容器通用操作" class="headerlink" title="容器通用操作"></a>容器通用操作</h1><p>一般来说，每个容器都定义在对应的头文件中，且文件名与类型名相同</p>
<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>每个容器都定义了多个类型，我们可以通过这些类型的类型别名来定义一个变量以供使用，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> i=a.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure>

<p>通常我们使用auto来创建一个容器内的类型对象，因为通常这样更方便，但是同时可以通过类型别名具体地定义这些变量的类型，例如这里的i类型实际上是:<code>vector&lt;int&gt;::iterator</code>这里的iterator就是一个类型别名，所以这里还可以：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator i=a.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure>

<p>像这样的类型别名还有：</p>
<table>
<thead>
<tr>
<th align="center">iterator</th>
<th align="center">此容器的迭代器类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">const_iterator</td>
<td align="center">只读迭代器类型</td>
</tr>
<tr>
<td align="center">size_type</td>
<td align="center">无符号整数类型，用于保存容器长度，可用于索引</td>
</tr>
<tr>
<td align="center">difference_type</td>
<td align="center">带符号整数类型，用于保存两迭代器之间的距离</td>
</tr>
<tr>
<td align="center">value_type</td>
<td align="center">容器的元素类型</td>
</tr>
<tr>
<td align="center">reference</td>
<td align="center">元素的左值类型</td>
</tr>
<tr>
<td align="center">const_reference</td>
<td align="center">只读左值类型</td>
</tr>
</tbody></table>
<h2 id="容器定义和初始化"><a href="#容器定义和初始化" class="headerlink" title="容器定义和初始化"></a>容器定义和初始化</h2><p>为方便理解，我们先像这样定义<strong>容器元素</strong>的类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">person</span>() =<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">person</span>(string s) &#123;name=s;&#125;</span><br><span class="line">    <span class="built_in">person</span>(string s1, string s2)  &#123;name=s1;addr=s2;&#125;</span><br><span class="line">   </span><br><span class="line">    string name;</span><br><span class="line">    string addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，该类有三个默认构造函数，接下来对容器的定义和初始化的元素均是该类型对象。</p>
<p>容器的定义与初始化有以下方式（均已vector为例）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;person&gt; men;</span><br><span class="line"><span class="function">vector&lt;person&gt; <span class="title">men1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;person&gt; <span class="title">men2</span><span class="params">(men1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">a</span><span class="params">(<span class="string">&quot;dhk&quot;</span>)</span>,<span class="title">b</span><span class="params">(<span class="string">&quot;aca&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;person&gt; <span class="title">men3</span><span class="params">(<span class="number">10</span>,a)</span></span>;</span><br><span class="line"><span class="function">vector&lt;person&gt; <span class="title">men3</span><span class="params">(<span class="number">10</span>,a)</span></span>;</span><br><span class="line"><span class="function">vector&lt;person&gt; <span class="title">men4</span><span class="params">(<span class="number">10</span>,&#123;a,b&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">vector&lt;person&gt; men5&#123;a,b,a,b&#125;;</span><br><span class="line">vector&lt;person&gt; men6&#123;&#123;a,b&#125;,&#123;b,a&#125;&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;person&gt;::iterator i=men1.<span class="built_in">begin</span>(), e=men1.<span class="built_in">end</span>();</span><br><span class="line"><span class="function">vector&lt;person&gt; <span class="title">men7</span><span class="params">(i,e)</span></span>;</span><br></pre></td></tr></table></figure>

<p><em>写在前面：有关元素类对象的构造函数生成元素的方法后面还会讲到更好用的办法，因此不建议在初始化容器时就添加元素</em></p>
<ul>
<li><p>men为经过<strong>默认容器构造函数</strong>定义的容器对象，每个容器类型都定义了一个默认的构造函数，除了array容器之外，其他容器的默认构造函数都会创建一个<strong>指定类型的空容器</strong>。而对于array来说，用C中数组思维理解，由于在创建时长度已经给定，因此array中<strong>每个元素都会被初始化</strong>。</p>
</li>
<li><p>men1为创建一个含有10个person类元素的vector容器，这些元素都已经经过初始化，并且全部相同。</p>
</li>
<li><p>men2为创建一个vector容器，其含有的元素未men1的拷贝，这就要求men1和men2必须是相同的类型，且元素也为相同的类型。对于array容器而言，长度还必须相等。</p>
</li>
<li><p>men3为创建一个含有10个person类元素的vector容器，而这些元素<strong>通过person的第二个构造函数进行了初始化</strong>，而不是像men1一样进行默认初始化。也就是说，<strong>现在men3内有10个name为”dhk”，addr为默认初始化值的相同元素。</strong></p>
</li>
<li><p>men4为创建一个含有10个person类元素的vector容器，而这些元素经过person的第三个构造函数进行了初始化。也就是说，<strong>现在men3内有10个name为”dhk”，addr为”aca”的相同元素。</strong></p>
<p>到此可以看出，当使用小括号进行容器初始化时，且当第一个值为一个整数n时，代表初始化n个相同的元素，而第二个参数<strong>可以为元素的构造函数参数</strong>，但这个参数<strong>有且只能有1个！！！</strong>，因为这n个元素是相同的，不能在这里对其中两个元素使用不同的构造函数参数，<strong>因此，<code>vector&lt;person&gt; men3(10,a,b);</code>是错误的写法！</strong></p>
<p>而如果当元素的构造函数参数有多个时，只需要像men4一样将这些参数通过大括号括起来即可。</p>
</li>
<li><p>men5为创建一个含有<strong>4个</strong>person类元素的vector容器，这些元素通过person的第二个构造函数进行初始化，分别是name为”dhk”,”aca”,”dhk”,”aca”；addr为默认初始化值的person对象。</p>
</li>
<li><p>men6为创建一个含有<strong>2个</strong>person类元素的vector容器，而这些元素经过person的第三个构造函数进行了初始化，分别是<u>name为”dhk”，addr为”aca”</u>和<u>name为”dhk”，addr为”aca”</u>的<strong>两个元素</strong></p>
</li>
<li><p>men7为迭代器i和e指定范围内中元素的拷贝，这些元素类型也需和men7中的元素类型相同</p>
</li>
</ul>
<h3 id="array类型的初始化"><a href="#array类型的初始化" class="headerlink" title="array类型的初始化"></a>array类型的初始化</h3><p>array类型由于需指定大小，初始化方式稍微有一点不一样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array&lt;person,10&gt; men=&#123;a,b,a&#125;;</span><br></pre></td></tr></table></figure>

<p>并且初始化时不能像men6一样使用大括号实现多个构造函数参数初始化</p>
<h3 id="string容器初始化"><a href="#string容器初始化" class="headerlink" title="string容器初始化"></a>string容器初始化</h3><p><a href="https://dhkkk.gitee.io/2022/09/15/C++-3/">C++字符串、向量和数组 | 小董的BLOG (gitee.io)</a></p>
<h2 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h2><p>除了一般初始化列表拷贝（不支持array），插入函数之外，这里将介绍assign函数和swap函数</p>
<h3 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h3><p>顺序容器中定义了assign成员，该函数允许从一个不同但可以兼容的类型元素赋值（不支持array），例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; names;</span><br><span class="line">vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; oldstyle;</span><br><span class="line">names=oldstyle;<span class="comment">//错误的，不可以直接将类型不同的容器赋值</span></span><br><span class="line">names=<span class="built_in">assign</span>( oldstyle.<span class="built_in">begin</span>(),oldstyle.<span class="built_in">end</span>() );</span><br></pre></td></tr></table></figure>

<p>assign会直接替换掉旧的元素，<strong>并且assign中使用的迭代器不能指向调用assign的容器</strong></p>
<p>assign也支持输入一个整数和一个元素值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">list&lt;string&gt; <span class="title">names</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">name.<span class="built_in">assign</span>(<span class="number">10</span>,<span class="string">&quot;dhk&quot;</span>);<span class="comment">//替换为10个相同的指定元素</span></span><br></pre></td></tr></table></figure>

<h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><p>swap函数的作用是交换<strong>两个相同类型容器</strong>的元素，但是swap的速度要快于一般的值拷贝，因为其本质的操作并没有改变这些元素的地址，而是改变了两个容器的<strong>数据结构</strong>，我个人的理解是就好像<a href="https://dhkkk.gitee.io/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/">基于FreeRTOS的列表学习 | 小董的BLOG (gitee.io)</a>中列表与列表项之间的关系，swap只是改变了首尾列表项与对应列表的指针关系；也就是说容器内元素的地址未发生变化，只是用于存储它们所属容器信息的某个变量（应该只有首尾元素）发生了变化。因此，<strong>swap操作是在一个常数时间内完成的</strong>，因为它跟元素的个数无关</p>
<p>因此，在swap前使用的迭代器、引用、指针在swap后<strong>都不会失效，因为元素本身的地址是没有改变的</strong>，这点就不同于assign的值拷贝。<strong>也就是说我们在使用swap后仍可以使用之前的迭代器、引用和指针，它们依旧指向（绑定）swap前的那个元素，只是这个元素不再属于之前的容器了</strong></p>
<p>需要注意的是：</p>
<ul>
<li>对于string，调用swap会导致之前的迭代器、指针和引用失效</li>
<li>对于array，两容器长度必须相等。swap会真正地交换元素值，但元素地址还是没有改变的，也就是swap前的迭代器、指针和引用仍然可以使用，只是它指向（绑定）的元素的元素内容发生了变化</li>
</ul>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>所有容器都支持使用关系运算符，但运算对象类型必须一致，运算原则：</p>
<ul>
<li>长度相等且元素两两对应相等则两个容器相等</li>
<li>如果长度不等，但元素相等（较小容器的所有元素都等于较大容器的元素），则小容器＜大容器</li>
<li>如果长度不等且元素不等，则关系取决于第一个不不相等元素的大小关系</li>
</ul>
<p>需要注意的是，<strong>只有当容器元素的类型也定义了相应的运算符时才可以使用关系运算符比较两个容器</strong></p>
<h1 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a>顺序容器操作</h1><h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><p>以下函数皆为类成员函数</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">作用</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">push_back(t)</td>
<td align="center">在容器尾部添加一个t元素</td>
<td align="center">void</td>
</tr>
<tr>
<td align="center">push_front(t)</td>
<td align="center">在容器头部添加一个t元素</td>
<td align="center">void</td>
</tr>
<tr>
<td align="center">insert(p,t)</td>
<td align="center">在迭代器p指向的元素<strong>之前</strong>添加一个t元素</td>
<td align="center">新元素的迭代器</td>
</tr>
<tr>
<td align="center">insert(p,n,t)</td>
<td align="center">插入n个t元素</td>
<td align="center">第一个新元素的迭代器</td>
</tr>
<tr>
<td align="center">insert(p,b,e)</td>
<td align="center">在迭代器p之前添加迭代器b到e范围内的元素</td>
<td align="center">第一个新元素的迭代器</td>
</tr>
<tr>
<td align="center">insert(p,il)</td>
<td align="center">插入一个il列表，例如{1,2,3}</td>
<td align="center">第一个新元素的迭代器</td>
</tr>
</tbody></table>
<p>当容器元素需要通过构造函数创建时，可以使用以下函数直接在容器内存中构造元素：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">作用</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">emplace_back(arg1,arg2,…)</td>
<td align="center">直接添加一个由元素类构造函数构建的新元素到容器尾部</td>
<td align="center">void</td>
</tr>
<tr>
<td align="center">emplace_front(arg1,arg2,…)</td>
<td align="center">直接添加一个由元素类构造函数构建的新元素到容器头部</td>
<td align="center">void</td>
</tr>
<tr>
<td align="center">emplace(p,arg1,arg2,…)</td>
<td align="center">直接添加一个由元素类构造函数构建的元素到迭代器p前</td>
<td align="center">新元素的迭代器</td>
</tr>
</tbody></table>
<p><strong>从arg1开始的参数要严格符合元素的构造函数参数要求</strong></p>
<p>使用这些函数有几个需要注意的点：</p>
<ul>
<li>array不能使用这些操作</li>
<li>forward_list有专用函数，不能使用这些函数</li>
<li>forward_list不支持push_back和emplace_back</li>
<li>vector和string不支持push_front和emplace_front</li>
<li><strong>向一个vector、string或deque插入元素会使原来的迭代器、指针、引用失效</strong></li>
<li><strong>将元素插入到vector、deque和string中是合法的，但是消耗资源较大</strong></li>
</ul>
<h2 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h2><p>以下皆为类成员函数</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin()</td>
<td align="center">返回首元素迭代器</td>
</tr>
<tr>
<td align="center">end()</td>
<td align="center">返回尾元素之后位置的迭代器</td>
</tr>
<tr>
<td align="center">front()</td>
<td align="center">返回首元素的引用</td>
</tr>
<tr>
<td align="center">back()</td>
<td align="center">返回尾元素的引用</td>
</tr>
<tr>
<td align="center">c[n]</td>
<td align="center">返回容器c中下标n元素的引用，下标越界会导致运行出错</td>
</tr>
<tr>
<td align="center">at(n)</td>
<td align="center">同上，但如果下标越界，会抛出一个out_of_range异常</td>
</tr>
</tbody></table>
<ul>
<li>对一个空容器调用这些函数都属于越界访问</li>
<li>at和下标操作只适用于vector、string、deque和array</li>
<li>如果容器是const的，则返回元素的引用也是const的，不可改变</li>
</ul>
<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">作用</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">pop_back()</td>
<td align="center">删除尾部元素，若容器为空则函数未定义</td>
<td align="center">void</td>
</tr>
<tr>
<td align="center">pop_front()</td>
<td align="center">删除头部元素</td>
<td align="center">void</td>
</tr>
<tr>
<td align="center">erase(p)</td>
<td align="center">删除迭代器p处元素，若p为尾后迭代器，则函数未定义</td>
<td align="center">被删元素之后的元素迭代器</td>
</tr>
<tr>
<td align="center">erase(b,e)</td>
<td align="center">删除迭代器b和e范围内的元素</td>
<td align="center">最后一个被删元素之后的迭代器</td>
</tr>
<tr>
<td align="center">clear()</td>
<td align="center">删除所有元素</td>
<td align="center">void</td>
</tr>
</tbody></table>
<ul>
<li>array不能使用这些操作</li>
<li>forward_list不支持pop_back()</li>
<li>vector和string不支持pop_front()</li>
</ul>
<h2 id="forward-list的特殊操作"><a href="#forward-list的特殊操作" class="headerlink" title="forward_list的特殊操作"></a>forward_list的特殊操作</h2><p>前面讲到，forward_list为单向链表，当我们使用前面的这些函数操作某个元素时，需要找到该元素的前驱，因为无论是添加、删除元素都需要改变前驱的链接。但是单向链表无法通过简单的办法找到一个节点的上一个节点，因此单向链表的实现方式有所不同：通过要操作的元素的上一个元素的迭代器来找到待操作元素</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">作用</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">before_begin()</td>
<td align="center">返回首元素之前的迭代器，该迭代器不可解引用</td>
<td align="center">~</td>
</tr>
<tr>
<td align="center">insert_after(p,t)</td>
<td align="center">在迭代器p<strong>后</strong>插入t</td>
<td align="center">插入的元素的迭代器</td>
</tr>
<tr>
<td align="center">insert_after(p,n,t)</td>
<td align="center">在迭代器p<strong>后</strong>插入n个t</td>
<td align="center">最后一个插入的元素的迭代器</td>
</tr>
<tr>
<td align="center">insert_after(p,b,e)</td>
<td align="center">在p<strong>后</strong>插入迭代器b和e之间的元素</td>
<td align="center">最后一个插入的元素的迭代器</td>
</tr>
<tr>
<td align="center">insert_after(p,il)</td>
<td align="center">在p<strong>后</strong>插入一个花括号列表</td>
<td align="center">最后一个插入的元素的迭代器</td>
</tr>
<tr>
<td align="center">emplace_after(p,args1,args2,…)</td>
<td align="center">在p后插入一个由构造函数构造的元素</td>
<td align="center">新元素的迭代器</td>
</tr>
<tr>
<td align="center">erase_after(p)</td>
<td align="center">删除p指向的元素之后的那一个元素</td>
<td align="center">被删元素之后的迭代器</td>
</tr>
<tr>
<td align="center">erase_after(b,e)</td>
<td align="center">删除从b之后到e之间的元素，即(b,e]</td>
<td align="center">被删元素之后的迭代器</td>
</tr>
</tbody></table>
<h1 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h1><p>对应除array之外的容器，其容量都是随时可变的，可以通过添加、删除元素实时改变容器的大小，这里提供了resize函数来可视化管理容器的大小：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">resize(n)</td>
<td align="center">将容器大小调整为n</td>
</tr>
<tr>
<td align="center">resize(n,t)</td>
<td align="center">任何新添加的元素都初始化为t</td>
</tr>
</tbody></table>
<p>对于调整值n，若n小于容器本身大小，则多出的元素被丢弃；若n大于容器大小，新的元素都将进行初始化</p>
<p>改变容器大小可能会因为删除元素导致迭代器失效</p>
<h1 id="管理容器的内存"><a href="#管理容器的内存" class="headerlink" title="管理容器的内存"></a>管理容器的内存</h1><p>对于vector和string来说，为了支持快速随机访问，其元素在内存上是连续存储的。</p>
<p>因此，当容器需要扩充容量时，因为元素必须连续纯粹的关系，每次添加扩容的新元素时，容器都会重新分配内存空间以保证所有的元素在内存上都连续存储（此时原来的空间内存就会被释放），这种操作会严重影响性能。</p>
<p>为了减轻这种代价，标准库实现者在容器不得不获取新的内存空间时，<strong>会分配比新的空间需求更大的内存空间</strong>，多出的空间作为预留备用，可以一定程度避免多次重新分配内存空间。而在实际中，这种策略也确实大大提高了性能</p>
<p>为了方便用户管理这些内存，容器类型中也提供了相关的成员函数：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">shrink_to_fit()</td>
<td align="center">删除预留的空间，使用后内存空间与size()一致</td>
</tr>
<tr>
<td align="center">capacity()</td>
<td align="center">容器目前在不重新分配空间的前提下<strong>最多</strong>可以保存多少元素</td>
</tr>
<tr>
<td align="center">reserve(n)</td>
<td align="center">为容器分配一个<strong>至少</strong>能容纳n个元素的空间</td>
</tr>
</tbody></table>
<p>根据我的使用经验，当reserve的值超过目前容器实际容量一定值之后，reserve的值会等于capacity。并且，<strong>reserve与resize函数最大的区别就是：reserve仅分配内存空间，而resize会将元素进行初始化，但它们都是以元素的个数为单位，而不是字节之类的</strong></p>
<ul>
<li>capacity和reserve只适用于vector和string</li>
</ul>
<h1 id="额外的string操作"><a href="#额外的string操作" class="headerlink" title="额外的string操作"></a>额外的string操作</h1><h2 id="构造string的其他方法"><a href="#构造string的其他方法" class="headerlink" title="构造string的其他方法"></a>构造string的其他方法</h2><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">string s(cp,n)</td>
<td align="center">s是cp指向的数组前n个字符的拷贝</td>
</tr>
<tr>
<td align="center">string s(s2,pos2)</td>
<td align="center">s是string变量s2从下标pos2开始的字符的拷贝</td>
</tr>
<tr>
<td align="center">string s(s2,pos2,len2)</td>
<td align="center">同上，len的长度可以超过s2长度，此时至多拷贝size-pos2个字符</td>
</tr>
</tbody></table>
<h2 id="子字符串操作"><a href="#子字符串操作" class="headerlink" title="子字符串操作"></a>子字符串操作</h2><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">substr(pos,n)</td>
<td align="center">返回一个string，返回值同第二个构造函数</td>
</tr>
</tbody></table>
<h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><p>关联容器和顺序容器有根本的区别，简单来说，关联容器通过关键字来保存、访问元素；而顺序容器是通过元素在容器中的位置来操作元素的。</p>
<p>标准库提供了8个关联容器：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">map</td>
<td align="center">关联数组：关键字与值一一对应</td>
</tr>
<tr>
<td align="center">set</td>
<td align="center">关键字即值，只保存关键字的容器</td>
</tr>
<tr>
<td align="center">multimap</td>
<td align="center">关键字可重复出现，允许多个元素对应一个关键字的map</td>
</tr>
<tr>
<td align="center">multiset</td>
<td align="center">关键字可重复出现的set</td>
</tr>
<tr>
<td align="center"><strong>下方为无序容器</strong></td>
<td align="center">~</td>
</tr>
<tr>
<td align="center">unordered_map</td>
<td align="center">用哈希函数组织的map</td>
</tr>
<tr>
<td align="center">unordered_set</td>
<td align="center">用哈希函数组织的set</td>
</tr>
<tr>
<td align="center">unordered_multimap</td>
<td align="center">~</td>
</tr>
<tr>
<td align="center">unordered_multiset</td>
<td align="center">~</td>
</tr>
</tbody></table>
<p>使用它们需包含对应的头文件</p>
<h2 id="关联容器概述"><a href="#关联容器概述" class="headerlink" title="关联容器概述"></a>关联容器概述</h2><p>关联容器支持上面讲的容器通用操作，不支持顺序容器操作，且关联容器的迭代器都是双向的</p>
<h3 id="关联容器定义"><a href="#关联容器定义" class="headerlink" title="关联容器定义"></a>关联容器定义</h3><p>没什么需要特别讲的，基本可以看明白</p>
<ul>
<li><p>map：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; test=&#123;&#123;<span class="string">&quot;dhk&quot;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&quot;aca&quot;</span>,<span class="number">2</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>set：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; test=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="关键字类型要求"><a href="#关键字类型要求" class="headerlink" title="关键字类型要求"></a>关键字类型要求</h3><p>对于关键字的类型必须是可以比较的。</p>
<h2 id="关联容器操作"><a href="#关联容器操作" class="headerlink" title="关联容器操作"></a>关联容器操作</h2><h3 id="关联容器特有类型别名"><a href="#关联容器特有类型别名" class="headerlink" title="关联容器特有类型别名"></a>关联容器特有类型别名</h3><ul>
<li>key_type：容器的关键字类型</li>
<li>mapped_type：关键字对应值的类型，只适用于map</li>
<li>value_type：对于set，于key_type相同；对于map，为<code>pair&lt;const key_type,mapped_type&gt;</code></li>
</ul>
<p>(pair可以简单理解为一个类似小容器的类型，每个对象只允许有两个成员)</p>
<h3 id="关联容器迭代器"><a href="#关联容器迭代器" class="headerlink" title="关联容器迭代器"></a>关联容器迭代器</h3><p>对于顺序容器，迭代器的解引用为元素的值；而对于关联容器：</p>
<ul>
<li><p>set的迭代器解引用对象为key_type</p>
</li>
<li><p>map的迭代器解引用对象为一个pair类型，因此：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">map&lt;string,<span class="type">int</span>&gt; <span class="title">test</span><span class="params">(&#123;<span class="string">&quot;dhk&quot;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&quot;aca&quot;</span>,<span class="number">2</span>&#125;)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> i=test.<span class="built_in">begin</span>();</span><br><span class="line">string a=(*i).first;</span><br><span class="line"><span class="type">int</span> b=i-&gt;second;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，关联容器的关键字是const的，不可修改</p>
<p><strong>同时，对于关联容器，begin函数返回的不一定是初始化时的第一个元素，而是经过关键字比较过后最小的元素</strong></p>
</li>
</ul>
<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>对于map，以下几种方式都可以</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test.<span class="built_in">insert</span>(&#123;<span class="string">&quot;dhk&quot;</span>,<span class="number">1</span>&#125;);</span><br><span class="line">test.<span class="built_in">insert</span>(<span class="built_in">makepair</span>(<span class="string">&quot;dhk&quot;</span>,<span class="number">1</span>));<span class="comment">//makepair为现场构造一个pair</span></span><br><span class="line">test.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string,<span class="type">int</span>&gt;(<span class="string">&quot;dhk&quot;</span>,<span class="number">1</span>));</span><br><span class="line">test.<span class="built_in">insert</span>(map&lt;string,<span class="type">int</span>&gt;::<span class="built_in">value_type</span>(<span class="string">&quot;dhk&quot;</span>,<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>同时也可以使用emplace函数，同顺序容器</p>
<h3 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h3><p>使用erase函数，参数可以为关键字或迭代器</p>
<h3 id="map的下标操作"><a href="#map的下标操作" class="headerlink" title="map的下标操作"></a>map的下标操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">map&lt;string,<span class="type">int</span>&gt; <span class="title">test</span><span class="params">(&#123;<span class="string">&quot;dhk&quot;</span>,<span class="number">1</span>&#125;)</span></span>;</span><br><span class="line">map[<span class="string">&quot;dhk&quot;</span>]=<span class="number">2</span>;</span><br><span class="line">map[<span class="string">&quot;aca&quot;</span>]=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>map的下标接受一个关键字，会获取该关键字关联的值</p>
<p>如果容器中未存在该关键字，则会创建一个新的元素插入容器中，因此下标操作只能对非const容器使用</p>
<h3 id="通用访问操作"><a href="#通用访问操作" class="headerlink" title="通用访问操作"></a>通用访问操作</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">find(k)</td>
<td align="center">访问容器中第一次出现的关键字为k的元素</td>
<td align="center">该元素迭代器</td>
</tr>
<tr>
<td align="center">count(k)</td>
<td align="center">关键字为k的元素数量</td>
<td align="center">数量</td>
</tr>
<tr>
<td align="center">lower_bound(k)</td>
<td align="center">访问第一次出现的关键字≤k的元素</td>
<td align="center">该元素迭代器</td>
</tr>
<tr>
<td align="center">upper_bound(k)</td>
<td align="center">访问第一次出现的关键字＞k的元素</td>
<td align="center">该元素迭代器</td>
</tr>
<tr>
<td align="center">equal_range(k)</td>
<td align="center">关键字为k的所有元素的范围</td>
<td align="center">一个pair，两个成员均为迭代器</td>
</tr>
</tbody></table>
<p>对于允许关键字重复的容器，关键字相同的元素会在容器中相邻存储，也就是可以通过迭代器递增的方式依次访问</p>
<p><strong>这些操作与下标操作不同的是不能创建新元素</strong></p>
<h2 id="单词转换程序"><a href="#单词转换程序" class="headerlink" title="单词转换程序"></a>单词转换程序</h2><p>根据书上的思路写了一个简化版的拼音转汉字程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将文件流绑定的文件数据导入到本程序的map中,文件数据格式如下*/</span></span><br><span class="line"><span class="comment">/*拼音 对应汉字*/</span></span><br><span class="line"><span class="function">map&lt;string,string&gt; <span class="title">bulidmap</span><span class="params">(ifstream &amp;map_file)</span><span class="comment">//返回值为一个map&lt;string,string&gt;</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;string,string&gt; the_map;</span><br><span class="line">    string key,value;</span><br><span class="line">    <span class="keyword">while</span>(map_file&gt;&gt;key &amp;&amp; <span class="built_in">getline</span>(map_file,value))</span><br><span class="line">    <span class="comment">//将拼音存入key变量中，该行剩下的内容存入value中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果value有值，则删除开头的空格</span></span><br><span class="line">        <span class="keyword">if</span>(value.<span class="built_in">size</span>()&gt;<span class="number">1</span>)  the_map[key]=value.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> the_map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ifstream mapfile;<span class="comment">//创建一个读取文件流用于读取文件</span></span><br><span class="line">    <span class="function">stringstream <span class="title">str</span><span class="params">(<span class="string">&quot;cy shi wo die&quot;</span>)</span></span>;<span class="comment">//字符串流用于程序输入</span></span><br><span class="line">    mapfile.<span class="built_in">open</span>(<span class="string">&quot;c++\\ass_container\\map.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> trans_map=<span class="built_in">bulidmap</span>(mapfile);<span class="comment">//将文件流内容导入新创建的map类型变量中</span></span><br><span class="line">    <span class="keyword">auto</span> end=trans_map.<span class="built_in">end</span>();<span class="comment">//指向map末端之后的一个迭代器</span></span><br><span class="line">    string s,s1;</span><br><span class="line">    <span class="keyword">while</span>(str&gt;&gt;s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> i= trans_map.<span class="built_in">find</span>(s);<span class="comment">//将字符串流中的每一个单词取出，在map中寻找有无对应的key</span></span><br><span class="line">        <span class="keyword">if</span> (i !=end)<span class="comment">//如果未寻找到，迭代器i会等于end</span></span><br><span class="line">        &#123;</span><br><span class="line">            s=i-&gt;second;<span class="comment">//用寻找到的key对应的value（拼音对应汉字）覆盖s中原有的拼音</span></span><br><span class="line">        &#125;</span><br><span class="line">        s1=s1+s;<span class="comment">//s1用于存储全部的转换结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>21行：字符串删除函数，可以删除字符串中指定数量的字符</li>
<li>38行：find函数如果未找到对应关键字则会返回队尾之后的迭代器</li>
</ul>
<h1 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h1><p>无序容器也属于关联容器的一种，但无序容器不是使用比较关键字的方式来组织元素顺序，而是通过一个哈希函数算法进行组织元素，简单地来说，该算法就是用比普通关联容器组织方式代价更小的方式进行元素组织，<strong>通常用于关键字没有明显的序关系等情况下使用，也许可以节省性能的占用</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">unordered_map</td>
<td align="center">用哈希函数组织的map</td>
</tr>
<tr>
<td align="center">unordered_set</td>
<td align="center">用哈希函数组织的set</td>
</tr>
<tr>
<td align="center">unordered_multimap</td>
<td align="center">~</td>
</tr>
<tr>
<td align="center">unordered_multiset</td>
<td align="center">~</td>
</tr>
</tbody></table>
<h2 id="无序容器的管理措施"><a href="#无序容器的管理措施" class="headerlink" title="无序容器的管理措施"></a>无序容器的管理措施</h2><p>无序容器在存储上组织为一组“桶”，哈希函数会计算每个元素的哈希值，具有相同哈希值的元素会被存入一个桶中，对于桶的维护，标准库也给出了一系列函数，但是我觉得用处不大，就先不写在这里了</p>
<h2 id="无序容器对关键字类型的要求"><a href="#无序容器对关键字类型的要求" class="headerlink" title="无序容器对关键字类型的要求"></a>无序容器对关键字类型的要求</h2><p>无序容器中有一个hash<key_type>类型用于存储哈希值，内置类型和string等标准库类型均定义了hash类型，均可以作为关键字。不能作为无序容器关键字的是另一个自定义的无序容器，原因与模板有关。</key_type></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dhkkk.gitee.io/2022/12/14/FreeRTOS%E4%BB%BB%E5%8A%A1%E5%BB%B6%E6%97%B6%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zoe.gif">
      <meta itemprop="name" content="dhk">
      <meta itemprop="description" content="记录一些学习日常">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小董的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/14/FreeRTOS%E4%BB%BB%E5%8A%A1%E5%BB%B6%E6%97%B6%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">FreeRTOS任务延时分析</a>
        </h2>

        <div class="post-meta">
		  
		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-14 10:49:06" itemprop="dateCreated datePublished" datetime="2022-12-14T10:49:06+08:00">2022-12-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-17 16:34:06" itemprop="dateModified" datetime="2022-12-17T16:34:06+08:00">2022-12-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前几章中都有涉及FreeRTOS的列表相关内容，在学习过程中，我们也能看出来列表与任务的状态（就绪、延时、堵塞）与任务调度息息相关，本文就针对任务延时进行<strong>列表运行机制</strong>的进一步学习</p>
<p>参考：<a target="_blank" rel="noopener" href="https://freertos.blog.csdn.net/article/details/51705148">FreeRTOS高级篇9—FreeRTOS系统延时分析_研究是为了理解的博客-CSDN博客_pdms_to_ticks</a></p>
<h1 id="相对延时"><a href="#相对延时" class="headerlink" title="相对延时"></a>相对延时</h1><table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">参数</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">vTaskDelay( const TickType_t xTicksToDelay )</td>
<td align="center">系统节拍个数</td>
<td align="center">无</td>
</tr>
</tbody></table>
<p>再次提醒一下，FreeRTOS中的延时参数都是以FreeRTOS<strong>自身的系统节拍</strong>为单位，系统节拍可以在在配置文件FreeRTOSConfig.h，改变宏configTICK_RATE_HZ的值；cubemx中的配置项也有相关的配置处，单位为Hz</p>
<h2 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelay</span><span class="params">( <span class="type">const</span> TickType_t xTicksToDelay )</span></span><br><span class="line">&#123;</span><br><span class="line">BaseType_t xAlreadyYielded = pdFALSE;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 如果延时时间为0,则不会将当前任务加入延时列表 */</span></span><br><span class="line">    <span class="keyword">if</span>( xTicksToDelay &gt; ( TickType_t ) <span class="number">0U</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        configASSERT( uxSchedulerSuspended == <span class="number">0</span> );<span class="comment">//禁用中断</span></span><br><span class="line">        vTaskSuspendAll();<span class="comment">//将调度器挂起</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">/* 将当前任务从就绪列表中移除,并根据当前系统节拍计数器值计算唤醒时间,然后将任务加入延时列表 */</span></span><br><span class="line">            prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );</span><br><span class="line">        &#125;</span><br><span class="line">        xAlreadyYielded = xTaskResumeAll();<span class="comment">//恢复调度器运行</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 强制执行一次上下文切换*/</span></span><br><span class="line">    <span class="keyword">if</span>( xAlreadyYielded == pdFALSE )</span><br><span class="line">    &#123;</span><br><span class="line">        portYIELD_WITHIN_API();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，关键函数为prvAddCurrentTaskToDelayedList()：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvAddCurrentTaskToDelayedList</span><span class="params">( TickType_t xTicksToWait, <span class="type">const</span> BaseType_t xCanBlockIndefinitely )</span></span><br><span class="line">&#123;</span><br><span class="line">TickType_t xTimeToWake;</span><br><span class="line"><span class="type">const</span> TickType_t xConstTickCount = xTickCount;</span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span>( INCLUDE_xTaskAbortDelay == 1 )</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 延时相关标志位清零 */</span></span><br><span class="line">		pxCurrentTCB-&gt;ucDelayAborted = pdFALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将列表项移出当前列表（就绪列表），pxCurrentTCB作为全局变量指向当前任务TCB，uxListRemove()返回列表的成员个数 */</span></span><br><span class="line">	<span class="keyword">if</span>( uxListRemove( &amp;( pxCurrentTCB-&gt;xStateListItem ) ) == ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* The current task must be in a ready list, so there is no need to</span></span><br><span class="line"><span class="comment">		check, and the port reset macro can be called directly. */</span></span><br><span class="line">		portRESET_READY_PRIORITY( pxCurrentTCB-&gt;uxPriority, uxTopReadyPriority );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		mtCOVERAGE_TEST_MARKER();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> ( INCLUDE_vTaskSuspend == 1 )</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>( ( xTicksToWait == portMAX_DELAY ) &amp;&amp; ( xCanBlockIndefinitely != pdFALSE ) )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/*如果设置的延时参数等于portMAX_DELAY(0xffffffff)，则视为堵塞而不是延时 */</span></span><br><span class="line">			vListInsertEnd( &amp;xSuspendedTaskList, &amp;( pxCurrentTCB-&gt;xStateListItem ) );</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 计算唤醒时间 */</span></span><br><span class="line">			xTimeToWake = xConstTickCount + xTicksToWait;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 将当前任务TCB的状态列表项值设置为唤醒时间 */</span></span><br><span class="line">			listSET_LIST_ITEM_VALUE( &amp;( pxCurrentTCB-&gt;xStateListItem ), xTimeToWake );</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>( xTimeToWake &lt; xConstTickCount )</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* Wake time has overflowed.  Place this item in the overflow</span></span><br><span class="line"><span class="comment">				list. */</span></span><br><span class="line">				vListInsert( pxOverflowDelayedTaskList, &amp;( pxCurrentTCB-&gt;xStateListItem ) );</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* 使用的是插入函数，因此延时列表中列表项会根据唤醒时间的大小进行排序 */</span></span><br><span class="line">				vListInsert( pxDelayedTaskList, &amp;( pxCurrentTCB-&gt;xStateListItem ) );</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* If the task entering the blocked state was placed at the</span></span><br><span class="line"><span class="comment">				head of the list of blocked tasks then xNextTaskUnblockTime</span></span><br><span class="line"><span class="comment">				needs to be updated too. */</span></span><br><span class="line">				<span class="keyword">if</span>( xTimeToWake &lt; xNextTaskUnblockTime )</span><br><span class="line">				&#123;</span><br><span class="line">					xNextTaskUnblockTime = xTimeToWake;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					mtCOVERAGE_TEST_MARKER();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">		<span class="comment">/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */</span></span><br><span class="line">		( <span class="type">void</span> ) xCanBlockIndefinitely;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span> <span class="comment">/* INCLUDE_vTaskSuspend */</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过对上述代码解释了列表的具体使用方法：</p>
<ul>
<li><p>若要将当前任务延时或挂起，可以通过全局变量pxCurrentTCB找到该任务TCB，再操作该TCB的<strong>状态</strong>列表项</p>
</li>
<li><p>当任务延时或挂起时，状态列表项的列表项值xItemValue会用于存放唤醒（延时结束）的时间，由于列表插入函数会自动根据xItemValue的值进行排序，<strong>所以唤醒时间越短的列表项会越排在列表前面</strong></p>
</li>
<li><p>FreeRTOS使用了两个延时列表：xDelayedTaskList1和xDelayedTaskList2，并使用两个列表指针类型变量pxDelayedTaskList和pxOverflowDelayedTaskList分别指向上面的延时列表1和延时列表2</p>
<p>pxOverflowDelayedTaskList用于解决计时溢出的问题：</p>
<p>tasks.c中定义了很多局部静态变量，其中有一个变量xTickCount用于记录系统节拍中断次数（可以理解为记录当前时间），当xTicksToDelay达到4294967295后再增加，就会溢出变成0。 如果内核判断出xTickCount+ xTicksToDelay溢出，就将当前任务挂接到列表指针pxOverflowDelayedTaskList指向的列表中</p>
</li>
</ul>
<h2 id="相对延时的缺点"><a href="#相对延时的缺点" class="headerlink" title="相对延时的缺点"></a>相对延时的缺点</h2><p>由于相对延时是在每次调用vTaskDelay之后才开启延时，如果调用延时的任务在运行过程中发生中断，那通过相对延时进行的周期任务就会因为该中断而被影响导致不能发生中断。</p>
<p>因此，为了能最大程度的使相对延时达到精准的效果，最好将使用相对延时的任务优先级设置为最高</p>
<h1 id="绝对延时"><a href="#绝对延时" class="headerlink" title="绝对延时"></a>绝对延时</h1><table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">参数</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, <br>                   const TickType_t xTimeIncrement )</td>
<td align="center">上一次记录的时间；<br>周期循环时间</td>
<td align="center">无</td>
</tr>
</tbody></table>
<h2 id="函数体-1"><a href="#函数体-1" class="headerlink" title="函数体"></a>函数体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelayUntil</span><span class="params">( TickType_t * <span class="type">const</span> pxPreviousWakeTime, <span class="type">const</span> TickType_t xTimeIncrement )</span></span><br><span class="line">&#123;</span><br><span class="line">TickType_t xTimeToWake;</span><br><span class="line">BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;</span><br><span class="line"> </span><br><span class="line">    vTaskSuspendAll();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 保存系统节拍中断次数计数器 */</span></span><br><span class="line">        <span class="type">const</span> TickType_t xConstTickCount = xTickCount;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 计算任务下次唤醒时间(以系统节拍中断次数表示)   */</span></span><br><span class="line">        xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* *pxPreviousWakeTime中保存的是上次唤醒时间,唤醒后需要一定时间执行任务主体代码,如果上次唤醒时间大于当前时间,说明节拍计数器溢出了 */</span></span><br><span class="line">        <span class="keyword">if</span>( xConstTickCount &lt; *pxPreviousWakeTime )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*只有当周期性延时时间大于任务主体代码执行时间,才会将任务挂接到延时列表.*/</span></span><br><span class="line">            <span class="keyword">if</span>( ( xTimeToWake &lt; *pxPreviousWakeTime ) &amp;&amp; ( xTimeToWake &gt; xConstTickCount ) )</span><br><span class="line">            &#123;</span><br><span class="line">                xShouldDelay = pdTRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 也都是保证周期性延时时间大于任务主体代码执行时间 */</span></span><br><span class="line">            <span class="keyword">if</span>( ( xTimeToWake &lt; *pxPreviousWakeTime ) || ( xTimeToWake &gt; xConstTickCount ) )</span><br><span class="line">            &#123;</span><br><span class="line">                xShouldDelay = pdTRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 更新唤醒时间,为下一次调用本函数做准备. */</span></span><br><span class="line">        *pxPreviousWakeTime = xTimeToWake;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>( xShouldDelay != pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 将本任务加入延时列表,注意阻塞时间并不是以当前时间为参考,因此减去了当前系统节拍中断计数器值*/</span></span><br><span class="line">            prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xAlreadyYielded = xTaskResumeAll();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 强制执行一次上下文切换 */</span></span><br><span class="line">    <span class="keyword">if</span>( xAlreadyYielded == pdFALSE )</span><br><span class="line">    &#123;</span><br><span class="line">        portYIELD_WITHIN_API();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写法和基本思路和相对延时区别不大，唯一需要注意的是。绝对延时之所以叫绝对延时，<strong>是因为其第一个参数pxPreviousWakeTime除开第一次使用时需获取当前系统时间外，每次调用绝对延时函数时pxPreviousWakeTime内保存的值为上一次调用时计算出的唤醒时间</strong></p>
<p>也就是说，绝对延时的<strong>每一次延时的起点都是上一次延时的终点</strong>，这也就保证了任务主体即使被中断也不会影响到下一次执行任务主体（前提是任务主体+中断执行的时间小于延时长度，如果超过延时时间，需要重新获取pxPreviousWakeTime为当前系统的最新时间）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dhkkk.gitee.io/2022/12/12/FreeRTOS%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/zoe.gif">
      <meta itemprop="name" content="dhk">
      <meta itemprop="description" content="记录一些学习日常">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小董的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/12/FreeRTOS%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">FreeRTOS的任务创建分析</a>
        </h2>

        <div class="post-meta">
		  
		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-12 15:33:00" itemprop="dateCreated datePublished" datetime="2022-12-12T15:33:00+08:00">2022-12-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-13 16:42:20" itemprop="dateModified" datetime="2022-12-13T16:42:20+08:00">2022-12-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文的学习参考了<a target="_blank" rel="noopener" href="https://freertos.blog.csdn.net/article/details/51303639">FreeRTOS高级篇2—FreeRTOS任务创建分析_研究是为了理解的博客-CSDN博客_</a></p>
<h1 id="任务TCB分析"><a href="#任务TCB分析" class="headerlink" title="任务TCB分析"></a>任务TCB分析</h1><p>在<a href="https://dhkkk.gitee.io/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/">基于FreeRTOS的列表学习 | 小董的BLOG (gitee.io)</a>中对列表项分析时，在列表项的结构中有一个无类型指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * pvOwner;                                     <span class="comment">/*指向一个任务TCB*/</span></span><br></pre></td></tr></table></figure>

<p>该指针用于指向任务的TCB（Task Control Block）。顾名思义，该结构作为一个用于控制任务的集合。它用于存储任务的状态信息，包括任务运行时的环境。<strong>每个任务都有自己的任务TCB。</strong></p>
<h2 id="结构解读"><a href="#结构解读" class="headerlink" title="结构解读"></a>结构解读</h2><p>可以在task.c中找到定义TCB的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tskTaskControlBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">volatile</span> StackType_t	*pxTopOfStack;		<span class="comment">//栈顶指针</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> ( portUSING_MPU_WRAPPERS == 1 )		<span class="comment">//是否使用MPU</span></span></span><br><span class="line">		xMPU_SETTINGS	xMPUSettings;		</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	ListItem_t			xStateListItem;	<span class="comment">//状态列表项</span></span><br><span class="line">	ListItem_t			xEventListItem;	<span class="comment">//事件列表项	</span></span><br><span class="line">	UBaseType_t			uxPriority;			<span class="comment">//优先级</span></span><br><span class="line">	StackType_t			*pxStack;			<span class="comment">//指向堆栈起始位置</span></span><br><span class="line">	<span class="type">char</span>				pcTaskName[ configMAX_TASK_NAME_LEN ];		<span class="comment">//任务名字最大长度</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> ( portSTACK_GROWTH &gt; 0 )		<span class="comment">//判断堆栈生长方向,&gt;0为向上生长</span></span></span><br><span class="line">		StackType_t		*pxEndOfStack;		 <span class="comment">//需要额外的一个指针来判断堆栈是否溢出</span></span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> ( portCRITICAL_NESTING_IN_TCB == 1 )</span></span><br><span class="line">		UBaseType_t		uxCriticalNesting;	</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span></span><br><span class="line">		UBaseType_t		uxTCBNumber;		<span class="comment">//一个数值，每个任务都有一个唯一的值</span></span><br><span class="line">		UBaseType_t		uxTaskNumber;		<span class="comment">//存储一个特定数值</span></span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> ( configUSE_MUTEXES == 1 )	<span class="comment">//是否使用互斥量</span></span></span><br><span class="line">		UBaseType_t		uxBasePriority;		<span class="comment">//用于保存任务的基础的基础优先级</span></span><br><span class="line">		UBaseType_t		uxMutexesHeld;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> ( configUSE_APPLICATION_TASK_TAG == 1 )</span></span><br><span class="line">		TaskHookFunction_t pxTaskTag;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span>( configNUM_THREAD_LOCAL_STORAGE_POINTERS &gt; 0 )</span></span><br><span class="line">		<span class="type">void</span> *pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span>( configGENERATE_RUN_TIME_STATS == 1 )</span></span><br><span class="line">		<span class="type">uint32_t</span>		ulRunTimeCounter;		<span class="comment">//记录任务在运行状态下执行的总时间</span></span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> ( configUSE_NEWLIB_REENTRANT == 1 )</span></span><br><span class="line">    <span class="comment">/* 为任务分配一个Newlibreent结构体变量。Newlib是一个C库函数，并非FreeRTOS维护，FreeRTOS也不对使用结果负责。如果用户使用Newlib，必须熟知Newlib的细节*/</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span>	_<span class="title">reent</span> <span class="title">xNewLib_reent</span>;</span></span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span>( configUSE_TASK_NOTIFICATIONS == 1 ) 		<span class="comment">//与任务通知相关</span></span></span><br><span class="line">		<span class="keyword">volatile</span> <span class="type">uint32_t</span> ulNotifiedValue;</span><br><span class="line">		<span class="keyword">volatile</span> <span class="type">uint8_t</span> ucNotifyState;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span>( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )</span></span><br><span class="line">		<span class="type">uint8_t</span>	ucStaticallyAllocated; 		</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span>( INCLUDE_xTaskAbortDelay == 1 )</span></span><br><span class="line">		<span class="type">uint8_t</span> ucDelayAborted;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; tskTCB;</span><br><span class="line"><span class="keyword">typedef</span> tskTCB TCB_t;</span><br></pre></td></tr></table></figure>

<h3 id="状态列表项与事件列表项"><a href="#状态列表项与事件列表项" class="headerlink" title="状态列表项与事件列表项"></a>状态列表项与事件列表项</h3><p>从TCB的结构中可以发现两个定义的列表项，分别是<strong>状态列表项和事件列表项</strong>，在上一章也略微提到过，列表与列表项用于调度任务、跟踪任务状态。例如：在task.c中，定义了一些静态列表变量，其中有就绪、阻塞、挂起列表，例如当某个任务处于就绪态时，调度器就将这个任务TCB的<strong>状态列表项</strong>挂接到就绪列表。事件列表项也与之类似，当队列满的情况下，任务因入队操作而阻塞时，就会将<strong>事件列表项</strong>挂接到队列的等待入队列表上。具体实现方法和规则会在之后学习任务调度时讲到。</p>
<h3 id="uxTCBNumber与uxTaskNumber"><a href="#uxTCBNumber与uxTaskNumber" class="headerlink" title="uxTCBNumber与uxTaskNumber"></a>uxTCBNumber与uxTaskNumber</h3><p>这两个变量主要用于调试与可视化追踪。仅当宏configUSE_TRACE_FACILITY（位于FreeRTOSConfig.h中）为1时有效。变量uxTCBNumber在创建任务时<strong>由内核自动分配</strong>，每个任务对应一个值，<strong>后续不再改变</strong>。变量uxTaskNumber由<strong>API函数vTaskSetTaskNumber()来设置的</strong>，数值由函数参数指定。</p>
<p>其定义在task.c中如下，参数为对应任务的引用句柄和要设置的数值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskSetTaskNumber</span><span class="params">( TaskHandle_t xTask, <span class="type">const</span> UBaseType_t uxHandle )</span></span><br><span class="line">&#123;</span><br><span class="line">	TCB_t *pxTCB;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>( xTask != <span class="literal">NULL</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			pxTCB = ( TCB_t * ) xTask;</span><br><span class="line">			pxTCB-&gt;uxTaskNumber = uxHandle;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="任务创建的内部流程"><a href="#任务创建的内部流程" class="headerlink" title="任务创建的内部流程"></a>任务创建的内部流程</h1><p>假设当前创建了一个任务如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> TaskHandle_t xHandle；</span><br><span class="line">xTaskCreate(vTask_A,”Task A”,<span class="number">120</span>,<span class="literal">NULL</span>,<span class="number">1</span>,&amp;xHandle);</span><br></pre></td></tr></table></figure>

<p>当这个语句执行后，任务A被创建并加入就绪任务列表，我们这章的主要目的，就是看看这个语句在执行过程中，发生了什么事情。</p>
<h2 id="1、创建任务堆栈和TCB所用空间"><a href="#1、创建任务堆栈和TCB所用空间" class="headerlink" title="1、创建任务堆栈和TCB所用空间"></a>1、创建任务堆栈和TCB所用空间</h2><p>注：原博客中也就是接下来讲到的函数在我使用的基于STM32的FreeRTOS中并不存在，但是可以在对xTaskCreate的定义下找到基本类似的操作（可能是版本原因）<strong>，不过其并不是用函数封装的，但是功能基本一致</strong>。为了方便学习就使用原博客中的函数来理解。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> TCB_t *<span class="title function_">prvAllocateTCBAndStack</span><span class="params">( <span class="type">const</span> <span class="type">uint16_t</span> usStackDepth, StackType_t * <span class="type">const</span> puxStackBuffer, TCB_t * <span class="type">const</span> pxTaskBuffer )</span></span><br><span class="line">&#123;</span><br><span class="line">TCB_t *pxNewTCB;</span><br><span class="line">StackType_t *pxStack;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 分配堆栈空间*/</span></span><br><span class="line">    pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( <span class="type">size_t</span> ) usStackDepth ) * <span class="keyword">sizeof</span>( StackType_t ) ), puxStackBuffer );</span><br><span class="line">    <span class="keyword">if</span>( pxStack != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 分配TCB空间 */</span></span><br><span class="line">        pxNewTCB = ( TCB_t * ) pvPortMallocAligned( <span class="keyword">sizeof</span>( TCB_t ), pxTaskBuffer );</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>( pxNewTCB != <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 将堆栈起始位置存入TCB*/</span></span><br><span class="line">            pxNewTCB-&gt;pxStack = pxStack;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 如果TCB分配失败，释放之前申请的堆栈空间 */</span></span><br><span class="line">            <span class="keyword">if</span>( puxStackBuffer == <span class="literal">NULL</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                vPortFree( pxStack );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pxNewTCB = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>( pxNewTCB != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 如果需要，使用固定值填充堆栈 */</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span>( ( configCHECK_FOR_STACK_OVERFLOW&gt; 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark== 1 ) )</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 仅用于调试 */</span></span><br><span class="line">            ( <span class="type">void</span> ) <span class="built_in">memset</span>( pxNewTCB-&gt;pxStack, ( <span class="type">int</span> ) tskSTACK_FILL_BYTE, ( <span class="type">size_t</span> ) usStackDepth * <span class="keyword">sizeof</span>( StackType_t ) );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> pxNewTCB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本就是一些分配内存的逻辑与操作，还是比较好理解的。</p>
<h2 id="2、初始化TCB必要的字段"><a href="#2、初始化TCB必要的字段" class="headerlink" title="2、初始化TCB必要的字段"></a>2、初始化TCB必要的字段</h2><p>这些操作在我的版本中都是用预编译判断执行的，没有使用函数封装，要找到对应操作实在是有点眼花，姑且看到大部分操作都是在task.c中对xTaskCreate的定义的后面，这里为了<strong>方便理解</strong>还是使用原博主的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvInitialiseTCBVariables</span><span class="params">( </span></span><br><span class="line"><span class="params">TCB_t * <span class="type">const</span> pxTCB,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName, </span></span><br><span class="line"><span class="params">UBaseType_t uxPriority,   </span></span><br><span class="line"><span class="params"><span class="type">const</span> MemoryRegion_t * <span class="type">const</span> xRegions, </span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">uint16_t</span> usStackDepth </span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	UBaseType_t x;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 将任务描述存入TCB */</span></span><br><span class="line">    <span class="keyword">for</span>( x = ( UBaseType_t ) <span class="number">0</span>; x &lt; ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )</span><br><span class="line">    &#123;</span><br><span class="line">        pxTCB-&gt;pcTaskName[ x ] = pcName[ x ];</span><br><span class="line">        <span class="keyword">if</span>( pcName[ x ] == <span class="number">0x00</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 确保字符串有结束 */</span></span><br><span class="line">    pxTCB-&gt;pcTaskName[ configMAX_TASK_NAME_LEN - <span class="number">1</span> ] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 调整优先级，宏configMAX_PRIORITIES的值在FreeRTOSConfig.h中设置 */</span></span><br><span class="line">    <span class="keyword">if</span>( uxPriority &gt;= ( UBaseType_t ) configMAX_PRIORITIES )</span><br><span class="line">    &#123;</span><br><span class="line">        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) <span class="number">1U</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    pxTCB-&gt;uxPriority = uxPriority;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_MUTEXES == 1 )              <span class="comment">/*使用互斥量*/</span></span></span><br><span class="line">    &#123;  </span><br><span class="line">        pxTCB-&gt;uxBasePriority = uxPriority;</span><br><span class="line">        pxTCB-&gt;uxMutexesHeld = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_MUTEXES */</span></span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">/*初始化列表项*/</span></span><br><span class="line">    vListInitialiseItem( &amp;( pxTCB-&gt;xStateListItem ) );</span><br><span class="line">    vListInitialiseItem( &amp;( pxTCB-&gt;xEventListItem ) );</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 设置列表项xStateListItem的成员pvOwner指向当前任务控制块 */</span></span><br><span class="line">    listSET_LIST_ITEM_OWNER( &amp;( pxTCB-&gt;xStateListItem ), pxTCB );</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 设置列表项xEventListItem的成员xItemValue*/</span></span><br><span class="line">    listSET_LIST_ITEM_VALUE( &amp;( pxTCB-&gt;xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority );</span><br><span class="line">    <span class="comment">/* 设置列表项xEventListItem的成员pvOwner指向当前任务控制块 */</span></span><br><span class="line">    listSET_LIST_ITEM_OWNER( &amp;( pxTCB-&gt;xEventListItem ), pxTCB );</span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( portCRITICAL_NESTING_IN_TCB ==1 )    <span class="comment">/*使能临界区嵌套功能*/</span></span></span><br><span class="line">    &#123;  </span><br><span class="line">        pxTCB-&gt;uxCriticalNesting = ( UBaseType_t ) <span class="number">0U</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* portCRITICAL_NESTING_IN_TCB */</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_APPLICATION_TASK_TAG == 1 ) <span class="comment">/*使能任务标签功能*/</span></span></span><br><span class="line">    &#123;  </span><br><span class="line">        pxTCB-&gt;pxTaskTag = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_APPLICATION_TASK_TAG */</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configGENERATE_RUN_TIME_STATS == 1 )  <span class="comment">/*使能事件统计功能*/</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        pxTCB-&gt;ulRunTimeCounter = <span class="number">0UL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configGENERATE_RUN_TIME_STATS */</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( portUSING_MPU_WRAPPERS == 1 )         <span class="comment">/*使用MPU功能*/</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        vPortStoreTaskMPUSettings( &amp;( pxTCB-&gt;xMPUSettings ), xRegions, pxTCB-&gt;pxStack, usStackDepth );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span> <span class="comment">/* portUSING_MPU_WRAPPERS */</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        ( <span class="type">void</span> ) xRegions;</span><br><span class="line">        ( <span class="type">void</span> ) usStackDepth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* portUSING_MPU_WRAPPERS */</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span>( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )<span class="comment">/*使能线程本地存储指针*/</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>( x = <span class="number">0</span>; x &lt; ( UBaseType_t )configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )</span><br><span class="line">        &#123;</span><br><span class="line">            pxTCB-&gt;pvThreadLocalStoragePointers[ x ] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_TASK_NOTIFICATIONS == 1 )   <span class="comment">/*使能任务通知功能*/</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        pxTCB-&gt;ulNotifiedValue = <span class="number">0</span>;</span><br><span class="line">        pxTCB-&gt;ucNotifyState = taskNOT_WAITING_NOTIFICATION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_NEWLIB_REENTRANT == 1 )     <span class="comment">/*使用Newlib*/</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        _REENT_INIT_PTR( ( &amp;( pxTCB-&gt;xNewLib_reent ) ) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span>( INCLUDE_xTaskAbortDelay == 1 )</span></span><br><span class="line">    &#123;</span><br><span class="line">        pxTCB-&gt;ucDelayAborted = pdFALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实大部分也就是对应TCB结构体中各个成员的初始化，其中有几点需要着重讲一下：</p>
<h3 id="对两个列表项的初始化："><a href="#对两个列表项的初始化：" class="headerlink" title="对两个列表项的初始化："></a>对两个列表项的初始化：</h3><ul>
<li><p>对状态列表项的初始化</p>
<p>使成员pvOwner指向对应的任务TCB，其余成员不对其操作</p>
</li>
<li><p><strong>对事件列表项的初始化</strong></p>
<p>之前讲到过事件列表项值会存储任务的优先级相关信息，其存储方式比较特别：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置列表项xEventListItem的成员xItemValue*/</span></span><br><span class="line">listSET_LIST_ITEM_VALUE( </span><br><span class="line">&amp;( pxTCB-&gt;xEventListItem ), </span><br><span class="line">( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority );</span><br></pre></td></tr></table></figure>

<p>可以看出，事件列表项的xItemValue中存储的值为**<u>用户设置的最大优先级-当前任务的优先级</u><strong>，也就是说，ItemValue的值越小，当前任务的优先级</strong>越高**</p>
<p>再回想一下列表项插入列表的函数vListInsert()：</p>
<img src="/images/loading.png" data-original="/2022/12/12/FreeRTOS%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E5%88%86%E6%9E%90/15.jpg" class title="This is an image"> 

<p>可以发现xItemValue越小的值越是排在列表的前面，这也就解释了这样做的原因，<strong>其实也就是优先级越高的任务越在列表前面</strong></p>
</li>
</ul>
<h3 id="任务通知"><a href="#任务通知" class="headerlink" title="任务通知"></a>任务通知</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> ( configUSE_TASK_NOTIFICATIONS == 1 )   <span class="comment">/*使能任务通知功能*/</span></span></span><br><span class="line">&#123;</span><br><span class="line">    pxTCB-&gt;ulNotifiedValue = <span class="number">0</span>;</span><br><span class="line">    pxTCB-&gt;ucNotifyState = taskNOT_WAITING_NOTIFICATION;</span><br></pre></td></tr></table></figure>

<p>在<a href="https://dhkkk.gitee.io/2022/08/30/freertos%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F/">FreeRTOS任务间的交互方法 | 小董的BLOG (gitee.io)</a>中将任务通知的流程时也使用到了使用该值的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotifyWait</span><span class="params">( uint32_tulBits ToClearOnEntry,</span></span><br><span class="line"><span class="params">									 uint32_tulBits ToClearOnExit,</span></span><br><span class="line"><span class="params">									 <span class="type">uint32_t</span>* pulNotificationValue,</span></span><br><span class="line"><span class="params">									 TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>

<p>其实pulNotificationValue就是拷贝自TCB中的ulNotifiedValue值，该值在任务通知发送函数将ulValue的值拷贝进ulNotifiedValue，在接收时用户可以通过pulNotificationValue判断任务通知发送的值。在初始化时，其为0，因此发送的任务值不能为0</p>
<h2 id="3、初始化任务堆栈"><a href="#3、初始化任务堆栈" class="headerlink" title="3、初始化任务堆栈"></a>3、初始化任务堆栈</h2><p>调用函数pxPortInitialiseStack()初始化任务堆栈，并将最新的栈顶指针赋值给任务TCB的pxTopOfStack字段。</p>
<p>具体与寄存器的调用有关，目前不深读。</p>
<h2 id="4、进入临界区"><a href="#4、进入临界区" class="headerlink" title="4、进入临界区"></a>4、进入临界区</h2><p> 调用taskENTER_CRITICAL()进入临界区，进入临界区后的代码段将不能被打断，比如有的外设的初始化需要严格的时序，初始化过程中不能被打断。FreeRTOS 在进入临界区代码的时候需要关闭中断，当处理完临界区代码以后再打开中断。</p>
<p>FreeRTOS 与 临界区代 码 保 护 有 关 的 函 数 有 4 个 ： taskENTER_CRITICAL() 、taskEXIT_CRITICAL() 、taskENTER_CRITICAL_FROM_ISR() 和taskEXIT_CRITICAL_FROM_ISR()，这四个函数其实是宏定义，在 task.h 文件中有定义。 这四个函数的区别是<strong>前两个是任务级的</strong>临界段代码保护，<strong>后两个是中断级</strong>的临界段代码保护。</p>
<h2 id="5、改变跟踪任务的变量"><a href="#5、改变跟踪任务的变量" class="headerlink" title="5、改变跟踪任务的变量"></a>5、改变跟踪任务的变量</h2><p>在task.c中定义了一些静态私有变量用于跟踪任务的数量、状态等信息，每当有任务发生变化时这些对应的变量也会发生变化。</p>
<p>其中变量uxCurrentNumberOfTasks表示当前任务的总数量，每创建一个任务，这个变量都会增加1。</p>
<h2 id="6、第一次运行的必要初始化"><a href="#6、第一次运行的必要初始化" class="headerlink" title="6、第一次运行的必要初始化"></a>6、第一次运行的必要初始化</h2><p>如果当前创建的任务为第一个任务，则会调用函数prvInitialiseTaskLists()对列表进行<strong>初始化</strong>，在这之前，task.c中定义了这些静态类型的列表变量：(List_t类型变量在上一章已经讲过)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PRIVILEGED_DATAstatic List_t pxReadyTasksLists[ configMAX_PRIORITIES ];<span class="comment">/*按照优先级排序的就绪态任务*/</span></span><br><span class="line">PRIVILEGED_DATAstatic List_t xDelayedTaskList1;                    <span class="comment">/*延时的任务 */</span></span><br><span class="line">PRIVILEGED_DATAstatic List_t xDelayedTaskList2;                    <span class="comment">/*延时的任务 */</span></span><br><span class="line">PRIVILEGED_DATAstatic List_t xPendingReadyList;             <span class="comment">/*任务已就绪,但调度器被挂起 */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (INCLUDE_vTaskDelete == 1 )</span></span><br><span class="line">    PRIVILEGED_DATA <span class="type">static</span> List_t xTasksWaitingTermination;<span class="comment">/*任务已经被删除,但内存尚未释放*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (INCLUDE_vTaskSuspend == 1 )</span></span><br><span class="line">    PRIVILEGED_DATA <span class="type">static</span> List_t xSuspendedTaskList;            <span class="comment">/*当前挂起的任务*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvInitialiseTaskLists</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">UBaseType_tuxPriority;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>( uxPriority = ( UBaseType_t ) <span class="number">0U</span>; uxPriority &lt; ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )</span><br><span class="line">    &#123;</span><br><span class="line">        vListInitialise( &amp;( pxReadyTasksLists[ uxPriority ] ) );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    vListInitialise( &amp;xDelayedTaskList1 );</span><br><span class="line">    vListInitialise( &amp;xDelayedTaskList2 );</span><br><span class="line">    vListInitialise( &amp;xPendingReadyList );</span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( INCLUDE_vTaskDelete == 1 )</span></span><br><span class="line">    &#123;</span><br><span class="line">        vListInitialise( &amp;xTasksWaitingTermination );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* INCLUDE_vTaskDelete */</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( INCLUDE_vTaskSuspend == 1 )</span></span><br><span class="line">    &#123;</span><br><span class="line">        vListInitialise( &amp;xSuspendedTaskList );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* INCLUDE_vTaskSuspend */</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskListusing list2. */</span></span><br><span class="line">    pxDelayedTaskList = &amp;xDelayedTaskList1;</span><br><span class="line">    pxOverflowDelayedTaskList = &amp;xDelayedTaskList2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中主要调用的函数vListInitialise()在讲列表时已经讲过，其作用就是初始化列表成员的一些指针的初始指向，为后续接入列表项做准备。</p>
<h2 id="7、更新任务TCB指针"><a href="#7、更新任务TCB指针" class="headerlink" title="7、更新任务TCB指针"></a>7、更新任务TCB指针</h2><p>tasks.c中定义了一个任务TCB指针型变量：</p>
<ul>
<li>PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB&#x3D; NULL;</li>
</ul>
<p> 这是一个全局变量，在tasks.c中只定义了这一个全局变量。这个变量用来指向当前正在运行的任务TCB。</p>
<p>当调度器还没有开启时（程序刚开始运行时，可能会先创建几个任务，之后才会启动调度器），如果新创建的任务优先级大于pxCurrentTCB指向的任务优先级，则设置pxCurrentTCB指向当前新创建的任务TCB。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( xSchedulerRunning == pdFALSE )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( pxCurrentTCB-&gt;uxPriority &lt;= uxPriority )</span><br><span class="line">    &#123;</span><br><span class="line">        pxCurrentTCB = pxNewTCB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这项操作可以<strong>确保pxCurrentTCB始终指向优先级最高的就绪任务。</strong></p>
<h2 id="8、将新创建的任务加入就绪列表数组"><a href="#8、将新创建的任务加入就绪列表数组" class="headerlink" title="8、将新创建的任务加入就绪列表数组"></a>8、将新创建的任务加入就绪列表数组</h2><p>新创建的任务会被直接加入到就绪列表中，因为它不会一被创建就被阻塞或挂起。观察在task.c中定义的几个静态类型的列表可以发现就绪列表是一个结构体数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PRIVILEGED_DATAstatic List_t pxReadyTasksLists[ configMAX_PRIORITIES ];</span><br><span class="line"><span class="comment">/*按照优先级排序的就绪态任务*/</span></span><br></pre></td></tr></table></figure>

<p>因此当前新创建的任务会根据该任务TCB中存储的优先级<strong>决定存入的列表下标</strong>。比如我们新创建的任务优先级为1，则这个任务被加入到列表pxReadyTasksLists[1]中。</p>
<p>并且由于同一个列表中任务的优先级是相同的，因此每次加入列表时会直接将当前任务放入列表尾：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> prvAddTaskToReadyList( pxTCB )                        </span></span><br><span class="line">    taskRECORD_READY_PRIORITY( ( pxTCB)-&gt;uxPriority );       </span><br><span class="line">    vListInsertEnd( &amp;( pxReadyTasksLists[ (pxTCB )-&gt;uxPriority ] ), </span><br><span class="line">                    &amp;( ( pxTCB )-&gt;xStateListItem ) );</span><br></pre></td></tr></table></figure>

<p>调用一个宏将任务放入列表。可以看到，加入列表的为任务的<strong>状态列表项</strong>，但最终调用宏的<strong>参数直接是任务TCB</strong>，因此可能用户不用关心何时操作状态列表项，何时操作事件列表项？（我的猜测，因为目前还不太清楚二者的明显区别）</p>
<h2 id="9、退出临界区"><a href="#9、退出临界区" class="headerlink" title="9、退出临界区"></a>9、退出临界区</h2><p>到此，一个任务的创建基本结束，也就可以退出临界区了（本身进入临界区的原因就是让任务的创建过程不被打断）</p>
<h2 id="10、新任务进入调度"><a href="#10、新任务进入调度" class="headerlink" title="10、新任务进入调度"></a>10、新任务进入调度</h2><p>如果调度器已开启，新任务便会根据其优先级由调度器进行相关调度。</p>
<h1 id="任务创建过程总结"><a href="#任务创建过程总结" class="headerlink" title="任务创建过程总结"></a>任务创建过程总结</h1><ul>
<li>为当前任务<strong>分配内存</strong>创建堆栈，为任务TCB创建空间</li>
<li><strong>初始化TCB</strong>，主要是使TCB成员中的两个列表项指向当前TCB和改变<strong>事件列表项的列表项值</strong></li>
<li><strong>初始化</strong>任务的<strong>堆栈</strong></li>
<li><em><strong>进入临界区，之后的进程不能被打断</strong></em></li>
<li>改变一些存储任务信息的<strong>变量</strong>（主要是全局的信息，并不是指某一个任务的信息。比如任务的总数量等）</li>
<li>如果当前为第一个任务，则<strong>初始化各列表</strong></li>
<li><strong>更新</strong>当前的任务TCB指针（该指针专用于指向当前TCB）</li>
<li>将新任务加入就绪列表数组中，<strong>根据优先级决定加入的数组下标</strong></li>
<li><em><strong>退出临界区</strong></em></li>
<li>新任务也加入调度过程中</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dhk"
      src="/images/zoe.gif">
  <p class="site-author-name" itemprop="name">dhk</p>
  <div class="site-description" itemprop="description">记录一些学习日常</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/dhkkkkkk" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dhkkkkkk" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/1154012965@qq.com" title="QQ email → 1154012965@qq.com"><i class="fa fa-envelope fa-fw"></i>QQ email</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/waiyeniao" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;waiyeniao" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"> </div>



      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dhk</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/xxw/anime.min.js"></script>
  <script src="/xxw/velocity/velocity.min.js"></script>
  <script src="/xxw/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script>
  <script>
      pbOptions = {};
        pbOptions.iconStyle = "box";
        pbOptions.boxForm = "horizontal";
        pbOptions.position = "bottomCenter";
        pbOptions.networks = "Wechat,QQZone,Weibo,Douban,Twitter,Facebook";
      new needShareButton('#needsharebutton-postbottom', pbOptions);
  </script>
<script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},t.src!==i&&(n.src=i)}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
