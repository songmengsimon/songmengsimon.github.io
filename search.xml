<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用说明</title>
    <url>/2022/09/08/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="欢迎访问DHK的个人博客！以下是一些使用说明："><a href="#欢迎访问DHK的个人博客！以下是一些使用说明：" class="headerlink" title="欢迎访问DHK的个人博客！以下是一些使用说明："></a>欢迎访问DHK的个人博客！以下是一些使用说明：</h1><h2 id="1-写的目的"><a href="#1-写的目的" class="headerlink" title="1.写的目的"></a>1.写的目的</h2><p>主要是为了记录自己在一些学习中的笔记和感想，方便日后回忆与查阅，仅供内部学习，未经同意请勿转载！</p>
<p>由于大部分是将自己的理解总结出来，所以有些地方不一定正确，也欢迎读者随时给予斧正，一些联系方式也已经放在侧边栏。</p>
<h2 id="2-如何查找需要内容"><a href="#2-如何查找需要内容" class="headerlink" title="2.如何查找需要内容"></a>2.如何查找需要内容</h2><ul>
<li>左侧目录有相关分类tag，以供查找</li>
<li>也可以通过左侧搜索功能搜索想要的内容</li>
<li>左侧我的GitHub仓库中也上传过之前使用过的一些例程模板</li>
</ul>
<h2 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h2><ul>
<li><u>如果你曾经打开过此博客网站，<strong>请务必在阅读相关博客之前先Ctrl+F5</strong>强制清理之前的缓存，不然你可能会看不到最新更新的内容！！！</u><em>（感觉是gitee的问题，之前部署到GitHub时并未遇见此问题）</em></li>
<li>如果想定位到想查找的内容的具体位置，建议先用博客的搜索功能定位到文章，再通过ctrl F搜索关键字即可。</li>
</ul>
]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>FreeRTOS的任务创建分析</title>
    <url>/2022/12/12/FreeRTOS%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>本文的学习参考了<a href="https://freertos.blog.csdn.net/article/details/51303639">FreeRTOS高级篇2—FreeRTOS任务创建分析_研究是为了理解的博客-CSDN博客_</a></p>
<h1 id="任务TCB分析"><a href="#任务TCB分析" class="headerlink" title="任务TCB分析"></a>任务TCB分析</h1><p>在<a href="https://dhkkk.gitee.io/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/">基于FreeRTOS的列表学习 | 小董的BLOG (gitee.io)</a>中对列表项分析时，在列表项的结构中有一个无类型指针：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> * pvOwner;                                     <span class="comment">/*指向一个任务TCB*/</span></span><br></pre></td></tr></table></figure>

<p>该指针用于指向任务的TCB（Task Control Block）。顾名思义，该结构作为一个用于控制任务的集合。它用于存储任务的状态信息，包括任务运行时的环境。<strong>每个任务都有自己的任务TCB。</strong></p>
<h2 id="结构解读"><a href="#结构解读" class="headerlink" title="结构解读"></a>结构解读</h2><p>可以在task.c中找到定义TCB的结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tskTaskControlBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">volatile</span> StackType_t	*pxTopOfStack;		<span class="comment">//栈顶指针</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> ( portUSING_MPU_WRAPPERS == 1 )		<span class="comment">//是否使用MPU</span></span></span><br><span class="line">		xMPU_SETTINGS	xMPUSettings;		</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	ListItem_t			xStateListItem;	<span class="comment">//状态列表项</span></span><br><span class="line">	ListItem_t			xEventListItem;	<span class="comment">//事件列表项	</span></span><br><span class="line">	UBaseType_t			uxPriority;			<span class="comment">//优先级</span></span><br><span class="line">	StackType_t			*pxStack;			<span class="comment">//指向堆栈起始位置</span></span><br><span class="line">	<span class="type">char</span>				pcTaskName[ configMAX_TASK_NAME_LEN ];		<span class="comment">//任务名字最大长度</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> ( portSTACK_GROWTH &gt; 0 )		<span class="comment">//判断堆栈生长方向,&gt;0为向上生长</span></span></span><br><span class="line">		StackType_t		*pxEndOfStack;		 <span class="comment">//需要额外的一个指针来判断堆栈是否溢出</span></span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> ( portCRITICAL_NESTING_IN_TCB == 1 )</span></span><br><span class="line">		UBaseType_t		uxCriticalNesting;	</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span></span><br><span class="line">		UBaseType_t		uxTCBNumber;		<span class="comment">//一个数值，每个任务都有一个唯一的值</span></span><br><span class="line">		UBaseType_t		uxTaskNumber;		<span class="comment">//存储一个特定数值</span></span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> ( configUSE_MUTEXES == 1 )	<span class="comment">//是否使用互斥量</span></span></span><br><span class="line">		UBaseType_t		uxBasePriority;		<span class="comment">//用于保存任务的基础的基础优先级</span></span><br><span class="line">		UBaseType_t		uxMutexesHeld;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> ( configUSE_APPLICATION_TASK_TAG == 1 )</span></span><br><span class="line">		TaskHookFunction_t pxTaskTag;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span>( configNUM_THREAD_LOCAL_STORAGE_POINTERS &gt; 0 )</span></span><br><span class="line">		<span class="type">void</span> *pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span>( configGENERATE_RUN_TIME_STATS == 1 )</span></span><br><span class="line">		<span class="type">uint32_t</span>		ulRunTimeCounter;		<span class="comment">//记录任务在运行状态下执行的总时间</span></span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> ( configUSE_NEWLIB_REENTRANT == 1 )</span></span><br><span class="line">    <span class="comment">/* 为任务分配一个Newlibreent结构体变量。Newlib是一个C库函数，并非FreeRTOS维护，FreeRTOS也不对使用结果负责。如果用户使用Newlib，必须熟知Newlib的细节*/</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span>	_<span class="title">reent</span> <span class="title">xNewLib_reent</span>;</span></span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span>( configUSE_TASK_NOTIFICATIONS == 1 ) 		<span class="comment">//与任务通知相关</span></span></span><br><span class="line">		<span class="keyword">volatile</span> <span class="type">uint32_t</span> ulNotifiedValue;</span><br><span class="line">		<span class="keyword">volatile</span> <span class="type">uint8_t</span> ucNotifyState;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span>( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )</span></span><br><span class="line">		<span class="type">uint8_t</span>	ucStaticallyAllocated; 		</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span>( INCLUDE_xTaskAbortDelay == 1 )</span></span><br><span class="line">		<span class="type">uint8_t</span> ucDelayAborted;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; tskTCB;</span><br><span class="line"><span class="keyword">typedef</span> tskTCB TCB_t;</span><br></pre></td></tr></table></figure>

<h3 id="状态列表项与事件列表项"><a href="#状态列表项与事件列表项" class="headerlink" title="状态列表项与事件列表项"></a>状态列表项与事件列表项</h3><p>从TCB的结构中可以发现两个定义的列表项，分别是<strong>状态列表项和事件列表项</strong>，在上一章也略微提到过，列表与列表项用于调度任务、跟踪任务状态。例如：在task.c中，定义了一些静态列表变量，其中有就绪、阻塞、挂起列表，例如当某个任务处于就绪态时，调度器就将这个任务TCB的<strong>状态列表项</strong>挂接到就绪列表。事件列表项也与之类似，当队列满的情况下，任务因入队操作而阻塞时，就会将<strong>事件列表项</strong>挂接到队列的等待入队列表上。具体实现方法和规则会在之后学习任务调度时讲到。</p>
<h3 id="uxTCBNumber与uxTaskNumber"><a href="#uxTCBNumber与uxTaskNumber" class="headerlink" title="uxTCBNumber与uxTaskNumber"></a>uxTCBNumber与uxTaskNumber</h3><p>这两个变量主要用于调试与可视化追踪。仅当宏configUSE_TRACE_FACILITY（位于FreeRTOSConfig.h中）为1时有效。变量uxTCBNumber在创建任务时<strong>由内核自动分配</strong>，每个任务对应一个值，<strong>后续不再改变</strong>。变量uxTaskNumber由<strong>API函数vTaskSetTaskNumber()来设置的</strong>，数值由函数参数指定。</p>
<p>其定义在task.c中如下，参数为对应任务的引用句柄和要设置的数值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskSetTaskNumber</span><span class="params">( TaskHandle_t xTask, <span class="type">const</span> UBaseType_t uxHandle )</span></span><br><span class="line">&#123;</span><br><span class="line">	TCB_t *pxTCB;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>( xTask != <span class="literal">NULL</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			pxTCB = ( TCB_t * ) xTask;</span><br><span class="line">			pxTCB-&gt;uxTaskNumber = uxHandle;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="任务创建的内部流程"><a href="#任务创建的内部流程" class="headerlink" title="任务创建的内部流程"></a>任务创建的内部流程</h1><p>假设当前创建了一个任务如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> TaskHandle_t xHandle；</span><br><span class="line">xTaskCreate(vTask_A,”Task A”,<span class="number">120</span>,<span class="literal">NULL</span>,<span class="number">1</span>,&amp;xHandle);</span><br></pre></td></tr></table></figure>

<p>当这个语句执行后，任务A被创建并加入就绪任务列表，我们这章的主要目的，就是看看这个语句在执行过程中，发生了什么事情。</p>
<h2 id="1、创建任务堆栈和TCB所用内存"><a href="#1、创建任务堆栈和TCB所用内存" class="headerlink" title="1、创建任务堆栈和TCB所用内存"></a>1、创建任务堆栈和TCB所用内存</h2><p>注：原博客中也就是接下来讲到的函数在我使用的基于STM32的FreeRTOS中并不存在，但是可以在对xTaskCreate的定义下找到基本类似的操作（可能是版本原因）<strong>，不过其并不是用函数封装的，但是功能基本一致</strong>。为了方便学习就使用原博客中的函数来理解。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> TCB_t *<span class="title function_">prvAllocateTCBAndStack</span><span class="params">( <span class="type">const</span> <span class="type">uint16_t</span> usStackDepth, StackType_t * <span class="type">const</span> puxStackBuffer, TCB_t * <span class="type">const</span> pxTaskBuffer )</span></span><br><span class="line">&#123;</span><br><span class="line">TCB_t *pxNewTCB;</span><br><span class="line">StackType_t *pxStack;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 分配堆栈空间*/</span></span><br><span class="line">    pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( <span class="type">size_t</span> ) usStackDepth ) * <span class="keyword">sizeof</span>( StackType_t ) ), puxStackBuffer );</span><br><span class="line">    <span class="keyword">if</span>( pxStack != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 分配TCB空间 */</span></span><br><span class="line">        pxNewTCB = ( TCB_t * ) pvPortMallocAligned( <span class="keyword">sizeof</span>( TCB_t ), pxTaskBuffer );</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>( pxNewTCB != <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 将堆栈起始位置存入TCB*/</span></span><br><span class="line">            pxNewTCB-&gt;pxStack = pxStack;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 如果TCB分配失败，释放之前申请的堆栈空间 */</span></span><br><span class="line">            <span class="keyword">if</span>( puxStackBuffer == <span class="literal">NULL</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                vPortFree( pxStack );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pxNewTCB = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>( pxNewTCB != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 如果需要，使用固定值填充堆栈 */</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span>( ( configCHECK_FOR_STACK_OVERFLOW&gt; 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark== 1 ) )</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 仅用于调试 */</span></span><br><span class="line">            ( <span class="type">void</span> ) <span class="built_in">memset</span>( pxNewTCB-&gt;pxStack, ( <span class="type">int</span> ) tskSTACK_FILL_BYTE, ( <span class="type">size_t</span> ) usStackDepth * <span class="keyword">sizeof</span>( StackType_t ) );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> pxNewTCB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本就是一些分配内存的逻辑与操作，还是比较好理解的。</p>
<h2 id="2、初始化TCB必要的字段"><a href="#2、初始化TCB必要的字段" class="headerlink" title="2、初始化TCB必要的字段"></a>2、初始化TCB必要的字段</h2><p>这些操作在我的版本中都是用预编译判断执行的，没有使用函数封装，要找到对应操作实在是有点眼花，姑且看到大部分操作都是在task.c中对xTaskCreate的定义的后面，这里为了<strong>方便理解</strong>还是使用原博主的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvInitialiseTCBVariables</span><span class="params">( TCB_t * <span class="type">const</span> pxTCB, <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName, UBaseType_t uxPriority,   </span></span><br><span class="line"><span class="params"><span class="type">const</span> MemoryRegion_t * <span class="type">const</span> xRegions, <span class="type">const</span> <span class="type">uint16_t</span> usStackDepth )</span></span><br><span class="line">&#123;</span><br><span class="line">	UBaseType_t x;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 将任务描述存入TCB */</span></span><br><span class="line">    <span class="keyword">for</span>( x = ( UBaseType_t ) <span class="number">0</span>; x &lt; ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )</span><br><span class="line">    &#123;</span><br><span class="line">        pxTCB-&gt;pcTaskName[ x ] = pcName[ x ];</span><br><span class="line">        <span class="keyword">if</span>( pcName[ x ] == <span class="number">0x00</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 确保字符串有结束 */</span></span><br><span class="line">    pxTCB-&gt;pcTaskName[ configMAX_TASK_NAME_LEN - <span class="number">1</span> ] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 调整优先级，宏configMAX_PRIORITIES的值在FreeRTOSConfig.h中设置 */</span></span><br><span class="line">    <span class="keyword">if</span>( uxPriority &gt;= ( UBaseType_t ) configMAX_PRIORITIES )</span><br><span class="line">    &#123;</span><br><span class="line">        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) <span class="number">1U</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    pxTCB-&gt;uxPriority = uxPriority;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_MUTEXES == 1 )              <span class="comment">/*使用互斥量*/</span></span></span><br><span class="line">    &#123;  </span><br><span class="line">        pxTCB-&gt;uxBasePriority = uxPriority;</span><br><span class="line">        pxTCB-&gt;uxMutexesHeld = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_MUTEXES */</span></span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">/*初始化列表项*/</span></span><br><span class="line">    vListInitialiseItem( &amp;( pxTCB-&gt;xStateListItem ) );</span><br><span class="line">    vListInitialiseItem( &amp;( pxTCB-&gt;xEventListItem ) );</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 设置列表项xStateListItem的成员pvOwner指向当前任务控制块 */</span></span><br><span class="line">    listSET_LIST_ITEM_OWNER( &amp;( pxTCB-&gt;xStateListItem ), pxTCB );</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 设置列表项xEventListItem的成员xItemValue*/</span></span><br><span class="line">    listSET_LIST_ITEM_VALUE( &amp;( pxTCB-&gt;xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority );</span><br><span class="line">    <span class="comment">/* 设置列表项xEventListItem的成员pvOwner指向当前任务控制块 */</span></span><br><span class="line">    listSET_LIST_ITEM_OWNER( &amp;( pxTCB-&gt;xEventListItem ), pxTCB );</span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( portCRITICAL_NESTING_IN_TCB ==1 )    <span class="comment">/*使能临界区嵌套功能*/</span></span></span><br><span class="line">    &#123;  </span><br><span class="line">        pxTCB-&gt;uxCriticalNesting = ( UBaseType_t ) <span class="number">0U</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* portCRITICAL_NESTING_IN_TCB */</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_APPLICATION_TASK_TAG == 1 ) <span class="comment">/*使能任务标签功能*/</span></span></span><br><span class="line">    &#123;  </span><br><span class="line">        pxTCB-&gt;pxTaskTag = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_APPLICATION_TASK_TAG */</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configGENERATE_RUN_TIME_STATS == 1 )  <span class="comment">/*使能事件统计功能*/</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        pxTCB-&gt;ulRunTimeCounter = <span class="number">0UL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configGENERATE_RUN_TIME_STATS */</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( portUSING_MPU_WRAPPERS == 1 )         <span class="comment">/*使用MPU功能*/</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        vPortStoreTaskMPUSettings( &amp;( pxTCB-&gt;xMPUSettings ), xRegions, pxTCB-&gt;pxStack, usStackDepth );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span> <span class="comment">/* portUSING_MPU_WRAPPERS */</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        ( <span class="type">void</span> ) xRegions;</span><br><span class="line">        ( <span class="type">void</span> ) usStackDepth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* portUSING_MPU_WRAPPERS */</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span>( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )<span class="comment">/*使能线程本地存储指针*/</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>( x = <span class="number">0</span>; x &lt; ( UBaseType_t )configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )</span><br><span class="line">        &#123;</span><br><span class="line">            pxTCB-&gt;pvThreadLocalStoragePointers[ x ] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_TASK_NOTIFICATIONS == 1 )   <span class="comment">/*使能任务通知功能*/</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        pxTCB-&gt;ulNotifiedValue = <span class="number">0</span>;</span><br><span class="line">        pxTCB-&gt;ucNotifyState = taskNOT_WAITING_NOTIFICATION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_NEWLIB_REENTRANT == 1 )     <span class="comment">/*使用Newlib*/</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        _REENT_INIT_PTR( ( &amp;( pxTCB-&gt;xNewLib_reent ) ) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span>( INCLUDE_xTaskAbortDelay == 1 )</span></span><br><span class="line">    &#123;</span><br><span class="line">        pxTCB-&gt;ucDelayAborted = pdFALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实大部分也就是对应TCB结构体中各个成员的初始化，其中有几点需要着重讲一下：</p>
<h3 id="对两个列表项的初始化："><a href="#对两个列表项的初始化：" class="headerlink" title="对两个列表项的初始化："></a>对两个列表项的初始化：</h3><ul>
<li><p>对状态列表项的初始化</p>
<p>使成员pvOwner指向对应的任务TCB</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>嵌入式学习</tag>
      </tags>
  </entry>
  <entry>
    <title>基于FreeRTOS的列表学习</title>
    <url>/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><em>本文参考了<a href="https://freertos.blog.csdn.net/article/details/51190095">FreeRTOS高级篇1—FreeRTOS列表和列表项研究是为了理解的博客-CSDN博客freertos list</a>进行学习</em></p>
<h1 id="列表与列表项"><a href="#列表与列表项" class="headerlink" title="列表与列表项"></a>列表与列表项</h1><p>FreeRTOS内核为了调度任务之间的关系，大量地使用了列表和列表项的数据结果来跟踪任务当前的状态。例如，处于挂起、延时、就绪的任务都会被挂接<strong>到各自的列表中</strong></p>
<p>FreeRTOS中使用指针实现列表的功能，类似于链式列表。<strong>一个列表下有多个列表项</strong>，且每个列表项中都有一个指针指向列表。</p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/1.jpg" class title="This is an image"> 

<p><strong>需要注意的是，<u>列表</u>和之前讲到任务交互时使用的<u>队列</u>是两个东西！</strong></p>
<h1 id="FreeRTOS列表项的构成"><a href="#FreeRTOS列表项的构成" class="headerlink" title="FreeRTOS列表项的构成"></a>FreeRTOS列表项的构成</h1><h2 id="全功能版列表项"><a href="#全功能版列表项" class="headerlink" title="全功能版列表项"></a>全功能版列表项</h2><p>我们可以在list.h中找到freertos对列表项的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE           <span class="comment">/*用于检测列表项数据是否完整*/</span></span><br><span class="line">     configLIST_VOLATILE TickType_t xItemValue;           <span class="comment">/*列表项值*/</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxNext</span>;</span>      <span class="comment">/*指向列表中下一个列表项*/</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxPrevious</span>;</span>  <span class="comment">/*指向列表中上一个列表项*/</span></span><br><span class="line">     <span class="type">void</span> * pvOwner;                                     <span class="comment">/*指向一个任务TCB*/</span></span><br><span class="line">     <span class="type">void</span> * configLIST_VOLATILE pvContainer;             <span class="comment">/*指向包含该列表项的列表 */</span></span><br><span class="line">     listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE          <span class="comment">/*用于检测列表项数据是否完整*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> <span class="title">ListItem_t</span>;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE 和listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE 这两个宏定义用于<strong>检查列表项的数据是否完整</strong>。</p>
<p>当使能projdefs.h中的宏configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES时，这两个宏会被替换成两个已知的数值用于检测完整性。</p>
</li>
<li><p>xItemValue为<strong>列表项值</strong>，通常是一个被跟踪的任务优先级或是一个调度事件的计数器值。</p>
<p>例如在队列的使用中，如果一个任务因为在等待从队列中读取数据而进入阻塞态，则该任务的<strong>事件列表项中的列表项值</strong>会用于保存该任务的优先级有关信息；该任务的<strong>状态列表项的列表项值</strong>会用于保存阻塞时间的有关信息（之前讲过，当有多个任务等待读取队列时，读取顺序与优先级和阻塞时间相关）。至于什么是事件列表项和状态列表项，之后的文章会讲到。</p>
<p>由于列表项值应是随时都可能更新的，因此该变量被configLIST_VOLATILE修饰，<strong>该宏被映射为C的关键字volatile</strong>。</p>
</li>
<li><p>pxNext和pxPrevious为两个结构体指针，用于指向上下列表项，实现类似于双向链表的结构，对结构体指针还不太懂的话可以参考<a href="https://dhkkk.gitee.io/2022/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/">数据结构_链表 | 小董的BLOG (gitee.io)</a>中的一些解释。</p>
</li>
<li><p>pvOwner用于指向一个任务的TCB（Task Control Block），之后的文章会讲到。</p>
</li>
<li><p>pvContainer用于指向<strong>包含该列表项的列表</strong>。</p>
</li>
</ul>
<h2 id="迷你版列表项"><a href="#迷你版列表项" class="headerlink" title="迷你版列表项"></a>迷你版列表项</h2><p>list.h中还有一个迷你版列表项的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xMINI_LIST_ITEM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			<span class="comment">//检测完整性</span></span><br><span class="line">	configLIST_VOLATILE TickType_t xItemValue;	<span class="comment">//列表项值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxNext</span>;</span>		<span class="comment">//指向下一列表项</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxPrevious</span>;</span>	<span class="comment">//指向前一列表项</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xMINI_LIST_ITEM</span> <span class="title">MiniListItem_t</span>;</span></span><br></pre></td></tr></table></figure>

<p>迷你版列表项的作用下一节讲列表时会讲到。</p>
<h2 id="初始化列表项"><a href="#初始化列表项" class="headerlink" title="初始化列表项"></a>初始化列表项</h2><p>  列表项的初始比较简单，只要确保列表项不在任何列表中即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vListInitialiseItem</span><span class="params">( ListItem_t * <span class="type">const</span> pxItem )</span></span><br><span class="line">&#123;</span><br><span class="line">     pxItem-&gt;pvContainer = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/*设置为已知值，用于检测列表项数据是否完整*/</span></span><br><span class="line">     listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem );</span><br><span class="line">     listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="FreeRTOS的列表构成"><a href="#FreeRTOS的列表构成" class="headerlink" title="FreeRTOS的列表构成"></a>FreeRTOS的列表构成</h1><h2 id="列表的定义"><a href="#列表的定义" class="headerlink" title="列表的定义"></a>列表的定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xLIST</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	listFIRST_LIST_INTEGRITY_CHECK_VALUE				<span class="comment">//检测完整性</span></span><br><span class="line">	configLIST_VOLATILE UBaseType_t uxNumberOfItems;</span><br><span class="line">	ListItem_t * configLIST_VOLATILE pxIndex;			</span><br><span class="line">	MiniListItem_t xListEnd;							</span><br><span class="line">	listSECOND_LIST_INTEGRITY_CHECK_VALUE				<span class="comment">//检测完整性</span></span><br><span class="line">&#125; List_t;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>uxNumberOfItems用于表示该列表中挂接的列表项数目，0表示列表为空。</p>
</li>
<li><p>pxIndex为一个类型为完全体列表项的结构体指针，用于<strong>遍历列表项。</strong></p>
</li>
<li><p>列表项xListEnd用于标记列表结束，<strong>因为该列表项只用于标记列表的结束，因此不需要完全体列表项的所有功能</strong>，因此使用了迷你版列表项的类型。</p>
<p>xListEnd.xItemValue被<strong>初始化为一个常数</strong>，其值与硬件架构相关，为0xFFFF（16位架构）或0xFFFFFFFF（32位架构）。</p>
</li>
</ul>
<h2 id="列表的初始化"><a href="#列表的初始化" class="headerlink" title="列表的初始化"></a>列表的初始化</h2><p>可以在list.c中找到初始化函数vListInitialise()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vListInitialise</span><span class="params">( List_t * <span class="type">const</span> pxList )</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">/*列表索引指向列表项xListEnd*/</span></span><br><span class="line">     pxList-&gt;pxIndex = ( ListItem_t * )&amp;( pxList-&gt;xListEnd );                  </span><br><span class="line">     <span class="comment">/* 设置为最大可能值为0xffff */</span></span><br><span class="line">     pxList-&gt;xListEnd.xItemValue =portMAX_DELAY;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/* 列表项xListEnd的pxNext和pxPrevious指针指向了它自己 */</span></span><br><span class="line">     pxList-&gt;xListEnd.pxNext = (ListItem_t * ) &amp;( pxList-&gt;xListEnd );</span><br><span class="line">     pxList-&gt;xListEnd.pxPrevious= ( ListItem_t * ) &amp;( pxList-&gt;xListEnd );</span><br><span class="line">     pxList-&gt;uxNumberOfItems = ( UBaseType_t) <span class="number">0U</span>;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/* 设置为已知值，用于检测列表数据是否完整*/</span></span><br><span class="line">     listSET_LIST_INTEGRITY_CHECK_1_VALUE(pxList );</span><br><span class="line">     listSET_LIST_INTEGRITY_CHECK_2_VALUE(pxList );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果宏configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES设置为1，则使能列表项数据完整性检查，则宏listSET_LIST_INTEGRITY_CHECK_1_VALUE()和listSET_LIST_INTEGRITY_CHECK_2_VALUE被一个已知值代替，默认为0x5a5a（16位架构）或者0x5a5a5a5a（32位架构）。</p>
</li>
<li><p>按照上述初始化后就应该是下图的情况：</p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/2.jpg" class title="This is an image"> 

<p>此时pxIndex、pxList-&gt;xListEnd.pxNext、pxList-&gt;xListEnd.pxPrevious都指向了 pxList-&gt;xListEnd（也可以说是xListEnd这个结构体的首元素）</p>
</li>
</ul>
<h1 id="将列表项插入列表中"><a href="#将列表项插入列表中" class="headerlink" title="将列表项插入列表中"></a>将列表项插入列表中</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vListInsert</span><span class="params">( List_t * <span class="type">const</span> pxList, ListItem_t * <span class="type">const</span> pxNewListItem )</span></span><br><span class="line">&#123;</span><br><span class="line">ListItem_t *pxIterator;		<span class="comment">//函数内定义一个列表项指针，通过列表项值的比较，找到当前输入列表项需插入的位置</span></span><br><span class="line"><span class="type">const</span> TickType_t xValueOfInsertion = pxNewListItem-&gt;xItemValue;	<span class="comment">//定义一个变量存放当前输入列表项的列表项值</span></span><br><span class="line"></span><br><span class="line">	listTEST_LIST_INTEGRITY( pxList );		<span class="comment">//检测完整性</span></span><br><span class="line">	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );		<span class="comment">//检测完整性</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*开始为输入列表项寻找合适的插入位置*/</span></span><br><span class="line">	<span class="keyword">if</span>( xValueOfInsertion == portMAX_DELAY )</span><br><span class="line">	&#123;</span><br><span class="line">		pxIterator = pxList-&gt;xListEnd.pxPrevious;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>( pxIterator = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd ); </span><br><span class="line">								  pxIterator-&gt;pxNext-&gt;xItemValue &lt;= xValueOfInsertion; </span><br><span class="line">								  pxIterator = pxIterator-&gt;pxNext ) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* There is nothing to do here, just iterating to the wanted</span></span><br><span class="line"><span class="comment">			insertion position. */</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">   <span class="comment">/******************************/</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">/*此时pxIterator为当前pxNewListItem要插入的位置*/</span></span><br><span class="line">	pxNewListItem-&gt;pxNext = pxIterator-&gt;pxNext;</span><br><span class="line">	pxNewListItem-&gt;pxNext-&gt;pxPrevious = pxNewListItem;</span><br><span class="line">	pxNewListItem-&gt;pxPrevious = pxIterator;</span><br><span class="line">	pxIterator-&gt;pxNext = pxNewListItem;</span><br><span class="line">   </span><br><span class="line">	<span class="comment">/*将列表项接入列表，列表项数目+1*/</span></span><br><span class="line">	pxNewListItem-&gt;pvContainer = ( <span class="type">void</span> * ) pxList;</span><br><span class="line">	( pxList-&gt;uxNumberOfItems )++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数中比较难以理解的地方就是关于寻找列表项插入位置的判断和循环部分，接下来将一步一步讲解：</p>
<h2 id="当列表内无列表项时（当前插入的列表项为第一个列表项）"><a href="#当列表内无列表项时（当前插入的列表项为第一个列表项）" class="headerlink" title="当列表内无列表项时（当前插入的列表项为第一个列表项）"></a>当列表内无列表项时（当前插入的列表项为第一个列表项）</h2><p>假设该列表项值为50</p>
<h3 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h3><p>不满足条件，跳过</p>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><ul>
<li><p>初始化<code>pxIterator = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd );</code>后，此时情况为：</p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/3.jpg" class title="This is an image"> 

<p>此时pxIterator成员与pxList-&gt;xListEnd的成员一一对应</p>
</li>
<li><p>条件判断<code>pxIterator-&gt;pxNext-&gt;xItemValue &lt;= xValueOfInsertion;</code></p>
<p>这里需要注意：<strong>列表初始化时，xListEnd的成员pxNext，pxPrevious是指向xListEnd的</strong></p>
<p>因此pxIterator-&gt;pxNext-&gt;xItemValue的值就是0xFFFF，是大于50的，因此不满足条件，跳出循环</p>
</li>
</ul>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><ul>
<li><p><strong>pxNewListItem-&gt;pxNext &#x3D; pxIterator-&gt;pxNext;</strong></p>
<p>pxIterator-&gt;pxNext指向pxList-&gt;xListEnd.pxnext，而pxList-&gt;xListEnd.pxnext又指向本身xListEnd；因此，<u><strong>最终pxNewListItem-&gt;pxNext指向了pxList-&gt;xListEnd</strong></u></p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/4.jpg" class title="cysgbj"> 
</li>
<li><p><strong>pxNewListItem-&gt;pxNext-&gt;pxPrevious &#x3D; pxNewListItem;</strong></p>
<p>上一步中pxNewListItem-&gt;pxNext指向了pxList-&gt;xListEnd，因此pxNewListItem-&gt;pxNext-&gt;pxPrevious等同于pxList-&gt;xListEnd.pxPrevious，而pxList-&gt;xListEnd.pxPrevious之前是指向pxList-&gt;xListEnd本身的，因此<u><strong>这一步最终的结果相当于将pxList-&gt;xListEnd.pxPrevious改变指向，指向pxNewListItem</strong></u></p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/5.jpg" class title="cysgbj"> 
</li>
<li><p><strong>pxNewListItem-&gt;pxPrevious &#x3D; pxIterator;</strong></p>
<p>由于pxIterator本身就是指向pxList-&gt;xListEnd的，因此这一步相当于：</p>
<p><u><strong>pxNewListItem-&gt;pxPrevious &#x3D; pxList-&gt;xListEnd</strong></u></p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/6.jpg" class title="cysgbj"> 
</li>
<li><p><strong>pxIterator-&gt;pxNext &#x3D; pxNewListItem;</strong></p>
<p>pxIterator-&gt;pxNext指向pxList-&gt;xListEnd.pxnext，此时pxList-&gt;xListEnd.pxnext本来是指向自己（pxList-&gt;xListEnd）的，因此这一步最终是：</p>
<p><strong><u>将pxList-&gt;xListEnd.pxnext改变指向，指向pxNewListItem</u></strong></p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/7.jpg" class title="cysgbj"> 
</li>
<li><p>综上，最终的结果为：</p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/8.jpg" class title="cysgbj"> 

<p><em>上图省略了pvContainer和pxIndex的指向和uxNumberOfItems的变化</em></p>
</li>
</ul>
<h2 id="第二次，当列表中已有列表项时，且该列表项值大于上一个"><a href="#第二次，当列表中已有列表项时，且该列表项值大于上一个" class="headerlink" title="第二次，当列表中已有列表项时，且该列表项值大于上一个"></a>第二次，当列表中已有列表项时，且该列表项值大于上一个</h2><p>假设第二个列表项值为60（第一个为50）</p>
<h3 id="if判断-1"><a href="#if判断-1" class="headerlink" title="if判断"></a>if判断</h3><p>不满足条件，跳过</p>
<h3 id="for循环-1"><a href="#for循环-1" class="headerlink" title="for循环"></a>for循环</h3><ul>
<li><p>初始化<code>pxIterator = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd );</code>后，由于在上一个列表项插入后，pxList.xListEnd中的pxNext和pxPrevious已经改变了指向，因此当前情况为：</p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/9.jpg" class title="cysgbj"> 
</li>
<li><p>条件判断<code>pxIterator-&gt;pxNext-&gt;xItemValue &lt;= xValueOfInsertion;</code></p>
<p>由上图可得知，此时pxIterator-&gt;pxNext-&gt;xItemValue为50，小于60，条件成立</p>
</li>
<li><p>执行<code>pxIterator = pxIterator-&gt;pxNext</code></p>
<p>由于pxIterator-&gt;pxNext指向pxNewListItem(1)，因此当前情况如下：</p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/10.jpg" class title="cysgbj"> 
</li>
<li><p>再次进行条件判断<code>pxIterator-&gt;pxNext-&gt;xItemValue &lt;= xValueOfInsertion;</code></p>
<p>此时pxIterator-&gt;pxNext-&gt;xItemValue为0xffff，不满足条件，循环结束。</p>
</li>
</ul>
<p><strong>综上，通过该for循环，可以根据每个列表项值的大小进行列表中的位置排序</strong></p>
<h3 id="赋值-1"><a href="#赋值-1" class="headerlink" title="赋值"></a>赋值</h3><p>这里的所有pxNewListItem在未特别说明的情况下都是指pxNewListItem(2）</p>
<ul>
<li><p><strong>pxNewListItem-&gt;pxNext &#x3D; pxIterator-&gt;pxNext;</strong></p>
<p>同第一次插入列表，<u><strong>最终pxNewListItem-&gt;pxNext指向了pxList-&gt;xListEnd</strong></u></p>
</li>
<li><p><strong>pxNewListItem-&gt;pxNext-&gt;pxPrevious &#x3D; pxNewListItem;</strong></p>
<p>同第一次插入列表，<u><strong>将pxList-&gt;xListEnd.pxPrevious改变指向，指向pxNewListItem</strong></u></p>
</li>
<li><p><strong>pxNewListItem-&gt;pxPrevious &#x3D; pxIterator;</strong></p>
<p>pxIterator在for循环中已经指向了pxNewListItem(1)，因此这里：</p>
<p><u><strong>pxNewListItem-&gt;pxPrevious指向pxNewListItem(1)</strong></u></p>
</li>
<li><p><strong>pxIterator-&gt;pxNext &#x3D; pxNewListItem;</strong></p>
<p>pxIterator-&gt;pxNext指向pxNewListItem(1)-&gt;pxnext，而pxNewListItem(1)-&gt;next最终指向了pxlist.xListEnd，因此这里相当于:</p>
<p><u><strong>改变pxNewListItem(1)-&gt;pxnext的指向，使其指向pxNewListItem(2)</strong></u></p>
</li>
</ul>
<p>综上，当前结果为：</p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/11.jpg" class title="cysgbj"> 

<p>有点乱，也可以参考下图，一样的</p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/12.jpg" class title="cysgbj">

<p>不难看出，赋值的最后两步将各个列表项相互链接</p>
<h2 id="第二次，当列表中已有列表项时，但该列表项值小于上一个"><a href="#第二次，当列表中已有列表项时，但该列表项值小于上一个" class="headerlink" title="第二次，当列表中已有列表项时，但该列表项值小于上一个"></a>第二次，当列表中已有列表项时，但该列表项值小于上一个</h2><p>假设第二个列表值为30，小于第一个列表值50</p>
<h3 id="if判断-2"><a href="#if判断-2" class="headerlink" title="if判断"></a>if判断</h3><p>不满足条件，跳过</p>
<h3 id="for循环-2"><a href="#for循环-2" class="headerlink" title="for循环"></a>for循环</h3><ul>
<li><p>初始化<code>pxIterator = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd );</code>后，由于在上一个列表项插入后，pxList.xListEnd中的pxNext和pxPrevious已经改变了指向，因此当前情况为：</p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/9.jpg" class title="cysgbj"> 
</li>
<li><p>条件判断<code>pxIterator-&gt;pxNext-&gt;xItemValue &lt;= xValueOfInsertion;</code></p>
<p>由上图可得知，此时pxIterator-&gt;pxNext-&gt;xItemValue为50，大于30，条件不成立，循环结束</p>
</li>
</ul>
<h3 id="赋值-2"><a href="#赋值-2" class="headerlink" title="赋值"></a>赋值</h3><p>这里的所有pxNewListItem在未特别说明的情况下都是指pxNewListItem(2）</p>
<ul>
<li><p><strong>pxNewListItem-&gt;pxNext &#x3D; pxIterator-&gt;pxNext;</strong></p>
<p><u><strong>不同第一次插入列表！此时pxNewListItem-&gt;pxNext最终指向了xNewListItem(1)</strong></u></p>
</li>
<li><p><strong>pxNewListItem-&gt;pxNext-&gt;pxPrevious &#x3D; pxNewListItem;</strong></p>
<p><strong>不同第一次插入列表！</strong>此时pxNewListItem-&gt;pxNext-&gt;pxPrevious 即是：</p>
<p><u><strong>pxNewListItem(1)-&gt;xPrevious指向了pxNewListItem(2)</strong></u></p>
</li>
<li><p><strong>pxNewListItem-&gt;pxPrevious &#x3D; pxIterator;</strong></p>
<p>pxIterator是直接指向pxList-&gt;xListEnd的，因此：</p>
<p><u><strong>pxNewListItem-&gt;pxPrevious 直接指向pxList-&gt;xListEnd</strong></u></p>
</li>
<li><p><strong>pxIterator-&gt;pxNext &#x3D; pxNewListItem;</strong></p>
<p>在执行这一步之前，情况如下：</p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/13.jpg" class title="cysgbj"> 

<p>这里我产生了一个疑问，pxIterator-&gt;pxNext是指向pxNewListItem(1)，那让pxNewListItem(1)&#x3D;pxNewListItem是什么意思呢？让上一个列表项指向当前列表项？这明显是不符合列表逻辑的。</p>
<p>后来在找寻问题的过程中，才发现自己又犯了老错误，pxNewListItem(1)其实也是一个指针变量，他是直接指向列表项1的内存单元的，<strong>因此pxIterator-&gt;pxNext是直接指向了列表项1的内存单元</strong>，因此改变pxIterator-&gt;pxNext是直接改变了这个指针的指向，也就是说结果是：</p>
<p><strong><u>将pxList-&gt;xListEnd.pxNext改变指向，使其指向pxNewListItem(2)</u></strong></p>
</li>
</ul>
<p>综上，最后结果为：</p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/14.jpg" class title="cysgbj"> 

<h2 id="对比两种情况"><a href="#对比两种情况" class="headerlink" title="对比两种情况"></a>对比两种情况</h2><p>第二个列表项值大于第一个的情况：</p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/11.jpg" class title="cysgbj"> 

<p>对比一下，可以看出：</p>
<ul>
<li><strong>pxList-&gt;xListEnd.pxNext总是指向列表项值最小的列表项</strong></li>
<li><strong>pxList-&gt;xListEnd.pxPrevious总是指向列表项值最大的列表项</strong></li>
<li><strong>列表项值小的列表项的pxNext总是指向列表项值大的列表项</strong></li>
<li><strong>列表项值大的列表项的PxPrevious总是指向列表项值小的列表项</strong></li>
<li><strong>首列表项的pxPrevious和尾列表项的pxNext都指向pxList-&gt;xListEnd</strong></li>
</ul>
<p>根据上述的规律，就可以清晰地明白FreeRTOS对列表的插入方式了：</p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/15.jpg" class title="cysgbj"> 

<p>因此，若要访问列表项，要通过pxList-&gt;xListEnd.pxNext访问手列表项，通过pxList-&gt;xListEnd.pxPrevious访问尾列表项。</p>
<p>实现插入的方法看了之后感觉真的很巧妙，我感觉也只能停留在理解的阶段，要自己写出来感觉难度还是很大。。。<strong>但是规律还是很好记住的😋</strong></p>
<h1 id="直接将列表项插入列表尾"><a href="#直接将列表项插入列表尾" class="headerlink" title="直接将列表项插入列表尾"></a>直接将列表项插入列表尾</h1><p>原理跟上面的是一样的，如果能理解插入的方法，相信这个理解起来就很ez了，就不多说了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vListInsertEnd</span><span class="params">( List_t * <span class="type">const</span> pxList, ListItem_t * <span class="type">const</span> pxNewListItem )</span></span><br><span class="line">&#123;</span><br><span class="line">ListItem_t* <span class="type">const</span> pxIndex = pxList-&gt;pxIndex;</span><br><span class="line"> </span><br><span class="line">         <span class="comment">/*检查列表和列表项数据的完整性，仅当configASSERT()定义时有效。*/</span></span><br><span class="line">         listTEST_LIST_INTEGRITY( pxList );</span><br><span class="line">         listTEST_LIST_ITEM_INTEGRITY(pxNewListItem );</span><br><span class="line"> </span><br><span class="line">         <span class="comment">/*向列表中插入新的列表项*/</span></span><br><span class="line">         pxNewListItem-&gt;pxNext = pxIndex;</span><br><span class="line">         pxNewListItem-&gt;pxPrevious =pxIndex-&gt;pxPrevious;</span><br><span class="line"> </span><br><span class="line">         mtCOVERAGE_TEST_DELAY();</span><br><span class="line"> </span><br><span class="line">         pxIndex-&gt;pxPrevious-&gt;pxNext =pxNewListItem;</span><br><span class="line">         pxIndex-&gt;pxPrevious = pxNewListItem;</span><br><span class="line"> </span><br><span class="line">         pxNewListItem-&gt;pvContainer = ( <span class="type">void</span>* ) pxList;</span><br><span class="line"> </span><br><span class="line">         ( pxList-&gt;uxNumberOfItems )++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在FreeRTOS中，任务的调度与列表息息相关，因此要想学好任务调度的原理，列表是第一大难关！</p>
]]></content>
      <tags>
        <tag>数据结构 嵌入式学习</tag>
      </tags>
  </entry>
  <entry>
    <title>单片机复习</title>
    <url>/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><ul>
<li><p>原码、反码、补码</p>
<p>正数的三者相同，负数反码为原码除符号位其余取反，补码为其反码+1</p>
<p><u><strong>负数的机器码是其原码的补码</strong></u></p>
</li>
<li><p>微型计算机配置高速缓冲存储器是为了解决： CPU于内存储器速度不匹配</p>
</li>
<li><p>ROM和RAM</p>
<ul>
<li>ROM：只读存储器，在单片机中用于存放程序，配有较大空间，<strong>掉电数据不丢失</strong></li>
<li>RAM：随机存储器，存放临时数据，使单片机<strong>更适用于实时控制系统</strong>，<strong>掉电数据丢失</strong></li>
<li><strong>计算机的内存容量主要指RAM</strong></li>
</ul>
</li>
<li><p><u><strong>系统总线：地址总线 AB，控制总线 CB 和双向数据总线 DB。</strong></u></p>
<ul>
<li>数据总线（Data Bus―DB）双向、三态：数据总线的根数决定了一次可以传递二进制数的<strong>位数</strong>。 </li>
<li>地址总线（Address Bus―AB）单向、三态：地址总线的位数决定了<strong>可以直接访问的存储单元(或 I&#x2F;O 口)的最大可能数 量（即容量）</strong>。 </li>
<li>控制总线（Control Bus―CB）：控制总线用来<strong>传输控制信号</strong>，数据总线和每个元件的数据线相连，为了使 CPU 能够和 其中一个元件正确通信，必须使用三态逻辑元件（特别针对输入元件）。</li>
</ul>
</li>
</ul>
<h2 id="题"><a href="#题" class="headerlink" title="题"></a>题</h2><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/1_1.jpg" class title="This is an image"> 

<h1 id="单片机硬件结构"><a href="#单片机硬件结构" class="headerlink" title="单片机硬件结构"></a>单片机硬件结构</h1><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>分为运算器和控制器</p>
<ul>
<li><p>控制器：依次取出ROM中存储单元的指令</p>
<ul>
<li>程序计数器：PC，16位，指向下一条指令的<strong>地址</strong>，复位后为0000H</li>
<li>指令寄存器</li>
<li>指令译码器</li>
<li>定时控制电路</li>
</ul>
</li>
<li><p>运算器ALU：对数据进行算术、逻辑运算</p>
<ul>
<li>算术逻辑运算部件ALU，负责运算，结果传回ACC，结果的状态传回PSW</li>
<li>累加器ACC</li>
<li><strong>程序状态寄存器PSW</strong></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">位</th>
<th align="center">7</th>
<th align="center">6</th>
<th align="center">5</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">位名</td>
<td align="center">Cy</td>
<td align="center">AC</td>
<td align="center">F0</td>
<td align="center">RS1</td>
<td align="center">RS0</td>
<td align="center">OV</td>
<td align="center">F1</td>
<td align="center">P</td>
</tr>
<tr>
<td align="center">作用</td>
<td align="center">进位&#x2F;借位</td>
<td align="center">辅助进位</td>
<td align="center">自定义</td>
<td align="center">寄存器选择</td>
<td align="center">寄存器选择</td>
<td align="center">溢出</td>
<td align="center">自定义</td>
<td align="center">奇偶效验</td>
</tr>
</tbody></table>
<ul>
<li>Cy：运算结果最高位有无进位&#x2F;错位</li>
<li>AC：运算结果低四位有无向高四位进位</li>
<li>F0、F1：用户自定义</li>
<li>RS1、RS0：一起决定当前寄存器组(00对应寄存器0组，依次增加)</li>
<li>OV：数据是否溢出</li>
<li>P：1的个数为奇&#x2F;偶</li>
</ul>
<h2 id="时钟电路"><a href="#时钟电路" class="headerlink" title="时钟电路"></a>时钟电路</h2><ul>
<li>XTAL1:片内振荡电路输入端</li>
<li>XTAL2：输出端</li>
</ul>
<p>当外部信号源为单片机提供时钟时，1接地，2接信号源</p>
<h2 id="EA"><a href="#EA" class="headerlink" title="EA"></a>EA</h2><p><strong>EA（反）</strong>为1时CPU从片内读取指令，为0时访问外部</p>
<h2 id="并行IO口"><a href="#并行IO口" class="headerlink" title="并行IO口"></a>并行IO口</h2><h3 id="P1"><a href="#P1" class="headerlink" title="P1"></a>P1</h3><p>通用输入、输出接口</p>
<img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/p1.jpg" class title="This is an image"> 

<h4 id="作输出时："><a href="#作输出时：" class="headerlink" title="作输出时："></a>作输出时：</h4><ul>
<li><p><strong>输出的数据通过内部总线送入锁存器保存</strong></p>
</li>
<li><p>判断数据的每一位。</p>
<p>为1时，Q&#x3D;1，Q（反）&#x3D;0，VT截止，Vcc向引脚输出高电平。</p>
</li>
</ul>
<p><strong>上拉电阻的作用</strong>：当VT截止时，使输出强制为1，若没有上拉电阻，输出可能由于噪音上下浮动。</p>
<h4 id="作输入时："><a href="#作输入时：" class="headerlink" title="作输入时："></a>作输入时：</h4><ul>
<li><strong>先向锁存器写1（准双向），使VT一直为截止状态。</strong>否则VT导通会拉低输入信号。</li>
<li>CPU执行读指令时，2导通，<strong>数据通过2直接进入</strong>内部总线，因此内部总线信号跟随引脚变化。</li>
</ul>
<h3 id="P2"><a href="#P2" class="headerlink" title="P2"></a>P2</h3><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/p2.jpg" class title="This is an image"> 

<p>有两种用途，准双向IO和高8位地址总线</p>
<p>当用作IO时，控制信号使开关接左侧，Q输出1使VT截止。</p>
<h3 id="P3"><a href="#P3" class="headerlink" title="P3"></a>P3</h3><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/p3.jpg" class title="This is an image"> 

<p><strong>用户可自行操作第二功能实现相关功能，P3默认为准双向IO</strong></p>
<p>第二功能包括：串口收发、外部中断、定时器输出等</p>
<h3 id="P0"><a href="#P0" class="headerlink" title="P0"></a>P0</h3><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/p0.jpg" class title="This is an image"> 

<p>可作为准双向IO，<strong>IO时必须外接上拉电阻</strong>。第二功能时提供外部存储地址低8位<strong>和P2组成16位地址</strong>，之后用作数据总线（此时锁存器会保存低八位地址）。</p>
<p>P0具有高阻态</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>四个IO均为准双向，<strong>在用作输入时都应向锁存器写“1”</strong></li>
<li>除P1外，其余端口都有第二功能：<ul>
<li>P0：低八位地址和数据总线</li>
<li>P2：高八位地址</li>
<li>P3：自定义功能</li>
</ul>
</li>
<li><strong>P0作为通用IO时需要外接上拉电阻！</strong></li>
<li><strong><u>P0、P2作地址时剩下引脚不能作为IO使用；但是P3各个口独立，未用作第二功能的可以作为IO使用</u></strong></li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>51单片机存储器<strong>物理</strong>上分为四个空间：</p>
<ul>
<li>片内<strong>程序</strong>存储器</li>
<li>片外<strong>程序</strong>存储器</li>
<li>片内<strong>数据</strong>存储器</li>
<li>片外<strong>数据</strong>存储器</li>
</ul>
<p>从用户使用的逻辑上分为三个区域：</p>
<ul>
<li>片内外统一编址的程序存储器	0000H-FFFFH(64KB)</li>
<li>片内数据存储	00-FFH 128B </li>
<li>片外数据存储    0000H-FFFFH</li>
</ul>
<h3 id="程序存储器"><a href="#程序存储器" class="headerlink" title="程序存储器"></a>程序存储器</h3><p>程序存储器由ROM和EPROM构成，掉电后数据不丢失</p>
<p>用于存放程序和程序运行时所需的常数。<strong>51片内有4K ROM，但地址线为16位，因此做多可以扩展到64KB</strong>。当PC值超过内部ROM容量时会自动转向外部寻址。\EA&#x3D;1时为寻址内部ROM。</p>
<p>MOVC指令用于访问程序存储器。</p>
<h3 id="数据存储器"><a href="#数据存储器" class="headerlink" title="数据存储器"></a>数据存储器</h3><p>数据存储器由RAM和专用寄存器组成，掉电后数据丢失</p>
<p>用于存放程序运算的中间结果、标志位、数据缓冲等。51片内有128+128B的数据存储器，可扩充至64KB</p>
<p>内部数据存储器分为低128B和高128B</p>
<img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/ram.jpg" class title="This is an image"> 

<h4 id="低128B：RAM区"><a href="#低128B：RAM区" class="headerlink" title="低128B：RAM区"></a>低128B：RAM区</h4><ul>
<li><p><strong>通用寄存器区</strong>，供用户使用，用于临时存放8位数据</p>
<p>通过修改程序状态寄存器PSW中的RS1和RS0实现选择，00H-1FH 128位</p>
</li>
<li><p><strong>位寻址区</strong>，提供地址读写数据 </p>
<p>RAM中的20H-2FH，128位</p>
</li>
<li><p><strong>数据缓存区</strong></p>
</li>
</ul>
<h4 id="特殊功能寄存器SFR"><a href="#特殊功能寄存器SFR" class="headerlink" title="特殊功能寄存器SFR"></a>特殊功能寄存器SFR</h4><p>包括51中有特殊功能的寄存器，如ACC、PSW、P0-P3等</p>
<p><u><strong>不包括PC</strong></u></p>
<h2 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h2><h3 id="时钟周期（振荡周期）"><a href="#时钟周期（振荡周期）" class="headerlink" title="时钟周期（振荡周期）"></a>时钟周期（振荡周期）</h3><p>也叫振荡周期，<strong>为振荡器频率的倒数</strong>，是时序中的<strong>最小单位</strong></p>
<h3 id="状态周期"><a href="#状态周期" class="headerlink" title="状态周期"></a>状态周期</h3><p>两个振荡周期，一个完成运算，一个完成传送</p>
<h3 id="机器周期"><a href="#机器周期" class="headerlink" title="机器周期"></a>机器周期</h3><p>执行一条指令的一个阶段的时间。<strong>是单片机的基本操作周期</strong>。1个机器周期&#x3D;6个状态周期&#x3D;12个振荡周期</p>
<h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><p>执行一条指令的周期，通常含有1~4个机器周期。</p>
<p>51单片机分为单周期指令、双周期指令、四周期指令，分别对应n个机器周期。<strong>只有乘法和除法是四周砌指令。</strong></p>
<p>因此，晶振周期为12MHz时：</p>
<ul>
<li>振荡周期&#x3D;1&#x2F;12us</li>
<li>机器周期&#x3D;1us</li>
<li>指令周期：1、2、4us</li>
</ul>
<h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><h3 id="复位方式"><a href="#复位方式" class="headerlink" title="复位方式"></a>复位方式</h3><ul>
<li>上电复位</li>
<li>按键复位</li>
</ul>
<h3 id="复位后寄存器状态"><a href="#复位后寄存器状态" class="headerlink" title="复位后寄存器状态"></a>复位后寄存器状态</h3><ul>
<li><strong>P0~P3：0FFH（全高电平）</strong></li>
<li><strong>PC：0000H</strong></li>
<li><strong>SP：07H</strong></li>
<li><strong>PSW:  00H</strong></li>
</ul>
<p><strong>51单片机在电复位时RAM保持不变</strong></p>
<h3 id="低功耗模式"><a href="#低功耗模式" class="headerlink" title="低功耗模式"></a>低功耗模式</h3><ul>
<li>休眠模式：只有外部中断工作</li>
<li>空闲模式（待机）：只有CPU停止工作</li>
</ul>
<h2 id="错题"><a href="#错题" class="headerlink" title="错题"></a>错题</h2><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/1.jpg" class title="This is an image"> 



<img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/2.jpg" class title="This is an image"> 



<img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/7.jpg" class title="This is an image"> 

<p><strong><u>由于RAM片内外访问指令一个是MOV一个是MOVX，因此其地址可以重叠。外部地址总线16位对应64KB，而内部地址可以与其重合，因此RAM最大总量是大于64KB的</u></strong></p>
<h1 id="51指令系统"><a href="#51指令系统" class="headerlink" title="51指令系统"></a>51指令系统</h1><p><a href="https://dhkkk.gitee.io/2022/10/14/51%E5%8D%95%E7%89%87%E6%9C%BA%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/">51单片机汇编指令查询 | 小董的BLOG (gitee.io)</a></p>
<h2 id="题-1"><a href="#题-1" class="headerlink" title="题"></a>题</h2><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/3.jpg" class title="This is an image"> 



<img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/4.jpg" class title="This is an image"> 

<p><strong>一般只有A能参与这些逻辑运算</strong></p>
<img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/5.jpg" class title="This is an image"> 

<p><strong>经典</strong></p>
<img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/6.jpg" class title="This is an image"> 

<p><strong>规定</strong></p>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><h2 id="中断请求标志寄存器"><a href="#中断请求标志寄存器" class="headerlink" title="中断请求标志寄存器"></a>中断请求标志寄存器</h2><h3 id="定时器-x2F-计数器控制寄存器TCON"><a href="#定时器-x2F-计数器控制寄存器TCON" class="headerlink" title="定时器&#x2F;计数器控制寄存器TCON"></a>定时器&#x2F;计数器控制寄存器TCON</h3><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/tcon.jpg" class title="This is an image"> 

<ul>
<li>IT 0&#x2F;1:外部中断触发方式，0低电平触发，1下降沿触发</li>
<li>IE 0&#x2F;1:中断请求标志位，触发中断后硬件自动清零</li>
<li>TF 0&#x2F;1:定时器&#x2F;计数器溢出中断标志位，触发中断后自动清零</li>
<li>TR 0&#x2F;1:启停定时器</li>
</ul>
<p>一般就只需设置IT和TR</p>
<h3 id="串行口控制寄存器SCON"><a href="#串行口控制寄存器SCON" class="headerlink" title="串行口控制寄存器SCON"></a>串行口控制寄存器SCON</h3><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/scon.jpg" class title="This is an image"> 

<ul>
<li>TI:发送中断标志位，每发送完一帧数据后硬件会对其置1，<strong>需用户自行软件清零！</strong></li>
<li>RI:接收中断标志位，规则同上。</li>
</ul>
<h3 id="中断允许寄存器IE"><a href="#中断允许寄存器IE" class="headerlink" title="中断允许寄存器IE"></a>中断允许寄存器IE</h3><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/ie.jpg" class title="This is an image"> 

<ul>
<li>EA：总中断允许位</li>
<li>ES：串口中断允许位</li>
<li>ET：定时器中断允许位</li>
<li>EX：外部中断允许位</li>
</ul>
<p>都是置1允许</p>
<p>若要使用某个中断，必须先开启中断允许位，复位后清零</p>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>I开头为TCON寄存器，控制<strong>定时器</strong>中断触发的方法和标志位</li>
<li>RI和TI为SCON寄存器，控制<strong>串口</strong>相关</li>
<li>E开头为中断允许寄存器IE</li>
</ul>
<h2 id="中断优先级"><a href="#中断优先级" class="headerlink" title="中断优先级"></a>中断优先级</h2><p>由中断优先级寄存器IP控制</p>
<img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/ip.jpg" class title="This is an image"> 

<ul>
<li>PX:外部中断优先级设置</li>
<li>PT:定时器中断优先级设置</li>
<li>PS:串口中断优先级设置</li>
</ul>
<h2 id="中断响应过程"><a href="#中断响应过程" class="headerlink" title="中断响应过程"></a>中断响应过程</h2><h3 id="中断请求"><a href="#中断请求" class="headerlink" title="中断请求"></a>中断请求</h3><p>硬件完成，请求完成后对应标志位置1</p>
<h3 id="中断查询"><a href="#中断查询" class="headerlink" title="中断查询"></a>中断查询</h3><p>CPU检测TCON和SCON中各标志位状态，确定是哪个中断</p>
<h3 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h3><p>响应条件：</p>
<ul>
<li><strong>EA使能</strong></li>
<li><strong>该中断允许位也使能</strong></li>
<li>有中断请求</li>
<li>无同级或高级中断正在运行</li>
</ul>
<h3 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h3><p>中断服务程序</p>
<h3 id="中断返回"><a href="#中断返回" class="headerlink" title="中断返回"></a>中断返回</h3><p>复位置位的标志位，重新执行原程序（PC被弹出堆栈）</p>
<h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><ul>
<li>打开对应中断允许位</li>
<li>设置触发方式</li>
<li>开启总中断允许</li>
<li>编写服务函数</li>
</ul>
<h2 id="题-2"><a href="#题-2" class="headerlink" title="题"></a>题</h2><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/zd1.jpg" class title="This is an image"> 

<h1 id="定时器-x2F-计数器"><a href="#定时器-x2F-计数器" class="headerlink" title="定时器&#x2F;计数器"></a>定时器&#x2F;计数器</h1><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>T1、T2分别由两个8位特殊功能寄存器TH和TL组成。当它对外部事件进行计数时，作为计数器使用；当对内部固<strong>定频率的机器周期进行计数时</strong>，便可以达到定时的目的。</p>
<h2 id="两种工作模式"><a href="#两种工作模式" class="headerlink" title="两种工作模式"></a>两种工作模式</h2><ul>
<li><p>计数器工作模式</p>
<p>对外部事件进行计数，计数脉冲来自P3中的对应引脚。</p>
<p>下降沿触发</p>
<p><strong>最高频率为振荡频率的1&#x2F;24，因为识别下降沿需要2个机器周期，即24个振荡周期</strong></p>
</li>
<li><p>定时器工作模式</p>
<p>计数脉冲为内部时钟脉冲，也就是每个机器周期+1，<strong>因此计数频率为振荡频率的1&#x2F;12</strong>，得到的时间：定时器计数值*机器周期时间</p>
</li>
</ul>
<p>当设置好定时器后，定时器就将独立工作，不再占用CPU，只有溢出时才会申请中断。</p>
<h2 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h2><h3 id="工作模式寄存器TMOD"><a href="#工作模式寄存器TMOD" class="headerlink" title="工作模式寄存器TMOD"></a>工作模式寄存器TMOD</h3><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/tmod.jpg" class title="This is an image"> 

<ul>
<li>GATE：门控位，使用外部中断引脚的高电平来启动定时器（前提是该定时器已被置位运行）</li>
<li>C&#x2F;(&#x2F;T)：1为计数器模式，0为定时器模式</li>
<li>M1，M0：同时控制定时器的工作模式，同PSW中的RS用法</li>
</ul>
<h3 id="控制寄存器TCON"><a href="#控制寄存器TCON" class="headerlink" title="控制寄存器TCON"></a>控制寄存器TCON</h3><p>上一节中断中已讲过，控制定时器的开启。</p>
<h2 id="定时器的工作方式"><a href="#定时器的工作方式" class="headerlink" title="定时器的工作方式"></a>定时器的工作方式</h2><h3 id="方式0"><a href="#方式0" class="headerlink" title="方式0"></a>方式0</h3><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/mod0.jpg" class title="This is an image"> 

<p>易得其定时时间为：(2^13 - 初值)*机器周期</p>
<p>计算后的值低5位赋给TL，高8位赋给TH</p>
<h3 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h3><p>16位计数器，其余与方式0一样。</p>
<h3 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h3><p>方式2为8位定时器</p>
<ul>
<li>TL用作定时，TH用于保存初值。当TL溢出后，中断标志置位，<strong>同时自动将TH中的值重新装载进TL</strong>，无需用户再手动重新装入初值。</li>
</ul>
<p>更加精准，但计时范围小。</p>
<h3 id="方式3"><a href="#方式3" class="headerlink" title="方式3"></a>方式3</h3><ul>
<li>只有T0能被设置为模式3，T1若为模式3，则停止计数，保存原样。</li>
</ul>
<h4 id="T0为模式3时"><a href="#T0为模式3时" class="headerlink" title="T0为模式3时"></a>T0为模式3时</h4><p>TH和TL分别单独工作</p>
<ul>
<li>TL：使用T0的状态控制位，同方式2，但是溢出后需用户手动装入初值</li>
<li>TH：<strong>被固定为一个内部定时器</strong>，受T1控制位的TR1控制启停，同上占用T1的中断请求TF1</li>
</ul>
<h4 id="T0为模式3时，T1的设置"><a href="#T0为模式3时，T1的设置" class="headerlink" title="T0为模式3时，T1的设置"></a>T0为模式3时，T1的设置</h4><p>T1仍可设置为方式0、1、2，但由于中断被占用，只能将输出送往串口</p>
<h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><ul>
<li><p>设置模式TMOD</p>
</li>
<li><p>赋初值TL、TH</p>
</li>
<li><p>开启中断ET、EA</p>
</li>
<li><p>开启定时器TR</p>
</li>
</ul>
<h1 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h1><p>串行通信：数据的各位在同一根数据线上逐位发送、接收。</p>
<p>串行通信按同步方式分为异步通信和同步通信</p>
<h2 id="同步通信"><a href="#同步通信" class="headerlink" title="同步通信"></a>同步通信</h2><p>数据传输速率高，但是要求发送时钟和接收时钟严格同步</p>
<h2 id="异步通信"><a href="#异步通信" class="headerlink" title="异步通信"></a>异步通信</h2><p>数据组成数据帧方式，收、发端相互独立、互不同步，只需规定收发数据的帧格式即可相互识别。</p>
<h3 id="数据帧格式"><a href="#数据帧格式" class="headerlink" title="数据帧格式"></a>数据帧格式</h3><ul>
<li>起始位：低电平有效</li>
<li>数据位：5~8位</li>
<li>奇偶校验位</li>
<li>停止位：高电平有效</li>
</ul>
<h3 id="波特率"><a href="#波特率" class="headerlink" title="波特率"></a>波特率</h3><p>每秒传输二进制数码的位数，每位的传输时间为1&#x2F;波特率</p>
<h2 id="51单片机的串口通信"><a href="#51单片机的串口通信" class="headerlink" title="51单片机的串口通信"></a>51单片机的串口通信</h2><p>51内部有一个可编程全双工串口。</p>
<h3 id="串口相关寄存器"><a href="#串口相关寄存器" class="headerlink" title="串口相关寄存器"></a>串口相关寄存器</h3><h4 id="串行数据缓冲器SBUF"><a href="#串行数据缓冲器SBUF" class="headerlink" title="串行数据缓冲器SBUF"></a>串行数据缓冲器SBUF</h4><p>包括发送和接收寄存器，但在逻辑上只有一个SBUF，在使用时可用作发送和接收。（物理上有两个完全独立的SBUF，但是他们地址是一样的）</p>
<h4 id="串行控制寄存器SCON"><a href="#串行控制寄存器SCON" class="headerlink" title="串行控制寄存器SCON"></a>串行控制寄存器SCON</h4><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/scon2.jpg" class title="This is an image"> 

<ul>
<li><p>SM0、1工作方式选择位</p>
<img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/smod.jpg" class title="This is an image"> 
</li>
<li><p>SM2:多机通信控制位</p>
</li>
<li><p>REN：<strong>允许接收控制位</strong></p>
</li>
<li><p>TB8：方式2、3的<strong>发送</strong>第九位</p>
</li>
<li><p>RB8：方式2、3的接收第九位</p>
</li>
</ul>
<h4 id="电源控制寄存器PCON"><a href="#电源控制寄存器PCON" class="headerlink" title="电源控制寄存器PCON"></a>电源控制寄存器PCON</h4><p>其中第七位SMOD为1波特率加倍</p>
<h2 id="基础流程"><a href="#基础流程" class="headerlink" title="基础流程"></a>基础流程</h2><ul>
<li><strong><u>配置SCON</u></strong></li>
<li><strong><u>数据送往SBUF</u></strong></li>
<li><strong><u>发送、接收数据</u></strong></li>
<li><strong><u>中断置位</u></strong></li>
</ul>
<h2 id="题-3"><a href="#题-3" class="headerlink" title="题"></a>题</h2><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/8.jpg" class title="This is an image"> 

<h1 id="常用的一些寄存器"><a href="#常用的一些寄存器" class="headerlink" title="常用的一些寄存器"></a>常用的一些寄存器</h1><h2 id="片内特殊功能寄存器SFR"><a href="#片内特殊功能寄存器SFR" class="headerlink" title="片内特殊功能寄存器SFR"></a>片内特殊功能寄存器SFR</h2><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/sfr.jpg" class title="This is an image"> 

<p>大多数特殊寄存器都在这里，<strong>但不包括PC！！</strong></p>
<h2 id="程序状态寄存器PSW"><a href="#程序状态寄存器PSW" class="headerlink" title="程序状态寄存器PSW"></a>程序状态寄存器PSW</h2><p>用于表示运算结果的状态</p>
<table>
<thead>
<tr>
<th align="center">位</th>
<th align="center">7</th>
<th align="center">6</th>
<th align="center">5</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">位名</td>
<td align="center">Cy</td>
<td align="center">AC</td>
<td align="center">F0</td>
<td align="center">RS1</td>
<td align="center">RS0</td>
<td align="center">OV</td>
<td align="center">F1</td>
<td align="center">P</td>
</tr>
<tr>
<td align="center">作用</td>
<td align="center">进位&#x2F;借位</td>
<td align="center">辅助进位</td>
<td align="center">自定义</td>
<td align="center">寄存器选择</td>
<td align="center">寄存器选择</td>
<td align="center">溢出</td>
<td align="center">自定义</td>
<td align="center">奇偶效验</td>
</tr>
</tbody></table>
<h2 id="中断允许寄存器IE（管理中断允许）E开头"><a href="#中断允许寄存器IE（管理中断允许）E开头" class="headerlink" title="中断允许寄存器IE（管理中断允许）E开头"></a>中断允许寄存器IE（管理中断允许）E开头</h2><p>用于管理所有中断</p>
<img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/ie.jpg" class title="This is an image"> 

<h2 id="中断优先级寄存器IP（管理中断优先级）P开头"><a href="#中断优先级寄存器IP（管理中断优先级）P开头" class="headerlink" title="中断优先级寄存器IP（管理中断优先级）P开头"></a>中断优先级寄存器IP（管理中断优先级）P开头</h2><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/ip.jpg" class title="This is an image"> 

<p>外部中断2位，定时器2位，串口1位，共5位</p>
<h2 id="定时器工作模式寄存器TMOD（管理定时器工作模式）"><a href="#定时器工作模式寄存器TMOD（管理定时器工作模式）" class="headerlink" title="定时器工作模式寄存器TMOD（管理定时器工作模式）"></a>定时器工作模式寄存器TMOD（管理定时器工作模式）</h2><p>8位，下4位控制T0，上4位控制T1</p>
<h2 id="定时器中断控制寄存器TCON（管理定时器启动、定时器和外部中断的中断标志位）"><a href="#定时器中断控制寄存器TCON（管理定时器启动、定时器和外部中断的中断标志位）" class="headerlink" title="定时器中断控制寄存器TCON（管理定时器启动、定时器和外部中断的中断标志位）"></a>定时器中断控制寄存器TCON（管理定时器启动、定时器和外部中断的中断标志位）</h2><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/tcon.jpg" class title="This is an image"> 

<p>其中IT和IE为控制外部中断的位</p>
<p>需要操作的位只有IT和TR，其他都会自动复位</p>
<h2 id="串行控制寄存器SCON（管理串口中断位和串口配置）"><a href="#串行控制寄存器SCON（管理串口中断位和串口配置）" class="headerlink" title="串行控制寄存器SCON（管理串口中断位和串口配置）"></a>串行控制寄存器SCON（管理串口中断位和串口配置）</h2><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/scon2.jpg" class title="This is an image"> 

<h2 id="电源控制寄存器PCON（波特率翻倍）"><a href="#电源控制寄存器PCON（波特率翻倍）" class="headerlink" title="电源控制寄存器PCON（波特率翻倍）"></a>电源控制寄存器PCON（波特率翻倍）</h2><p>仅串口中需使用其第七位翻倍波特率</p>
<h1 id="题-4"><a href="#题-4" class="headerlink" title="题"></a>题</h1><ul>
<li><p>堆栈的作用：保护现场和断点</p>
</li>
<li><p>JB为判断当前位，为1则跳转</p>
</li>
</ul>
<img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/wxz.jpg" class title="This is an image"> 

<p>如果是A，就是直接寻址，C则为位寻址，位寻址只能操作位</p>
<img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/ct.jpg" class title="This is an image"> 

<ul>
<li>C&#x2F;(&#x2F;T)：<strong>0为定时器模式</strong></li>
</ul>
]]></content>
      <tags>
        <tag>嵌入式学习</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构_链表</title>
    <url>/2022/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="1-链表的概念"><a href="#1-链表的概念" class="headerlink" title="1.链表的概念"></a>1.链表的概念</h1><p>通过多个<strong>节点</strong>将多个数据元素组成一个链表。</p>
<ul>
<li>节点：数据元素的存储映像， 由<strong>数据域和指针域</strong>两部分组成。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>数据元素的个数可以自由扩充</li>
<li>插入、删除等操作不必移动数据，只需修改链接指针，修改效率较高</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>存储密度小</li>
<li>存取效率不高，必须采用顺序存取，即存取数据元素时，只能按链表的顺序进行访问（顺藤摸瓜）</li>
</ul>
<h1 id="2-创建一个单向列表"><a href="#2-创建一个单向列表" class="headerlink" title="2.创建一个单向列表"></a>2.创建一个单向列表</h1><p>单向列表即每个节点之间的联系是单向的，仅通过一个指针链接。</p>
<p>创建列表有两种方法：前插法和后插法。</p>
<h2 id="前插法"><a href="#前插法" class="headerlink" title="前插法"></a>前插法</h2><p>新的节点链接到上一节点的开头</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> num; 	<span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">last</span>;</span>	<span class="comment">//指针域</span></span><br><span class="line">&#125;test;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setlist</span><span class="params">(test* linkhead, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">   test *tmp=(test*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(test));<span class="comment">//分配动态内存，防止生成野指针</span></span><br><span class="line">   tmp-&gt;num=data;</span><br><span class="line">   tmp-&gt;last=linkhead-&gt;last;</span><br><span class="line">   linkhead-&gt;last=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> a[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   test* head=(test*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(test));</span><br><span class="line">   head-&gt;last=<span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)</span><br><span class="line">   &#123;</span><br><span class="line">      setlist(head,a[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   test* p= head-&gt;last;</span><br><span class="line">   <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p-&gt;num);</span><br><span class="line">      p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前插法创建链表的步骤为（以创建两个节点为例）:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setlist</span><span class="params">(test* linkhead, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//开辟一个新节点</span></span><br><span class="line">   test *tmp=(test*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(test));</span><br><span class="line">   <span class="comment">//写入需要的数据</span></span><br><span class="line">   tmp-&gt;num=data;</span><br><span class="line">   <span class="comment">//将节点的指针域指向linkhead的指针域</span></span><br><span class="line">   tmp-&gt;last=linkhead-&gt;last;</span><br><span class="line">   <span class="comment">//将linkhead的指针域指向新节点首地址</span></span><br><span class="line">   linkhead-&gt;last=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，创建第一个节点时，该节点的指针域先指向NULL后，linkhead指针域再指向该节点首地址。</p>
<p>当刚创建第二个节点时，情况如下：</p>
<img src="/images/loading.png" data-original="/2022/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/1.jpg" class title="This is an image"> 

<p>当执行<code>tmp-&gt;last=linkhead-&gt;last;</code>时，由于linkhead的指针域此时指向tmp(1)（这里的1指第一块节点的内存空间）的首地址，<strong>所以tmp(2)的指针域会通过linkhead直接也指向tmp(1)的首地址:</strong></p>
<img src="/images/loading.png" data-original="/2022/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/2.jpg" class title="This is an image"> 

<p>这样之后，两个节点就通过指针链接在了一起，且tmp(2)在tmp(1)之前。</p>
<p>由此可以看出，前插法的原理就是以linkhead为媒介来链接节点，<strong>linkhead本身是不存储数据的</strong></p>
<p>最后，执行<code>linkhead-&gt;last=tmp;</code>，<strong>将linkhead指针域指向第二个节点首地址，以供第三个节点的指针域找到第二个节点。</strong></p>
<img src="/images/loading.png" data-original="/2022/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/3.jpg" class title="This is an image"> 

<p>以此类推，假如现在创建了4个节点，那情况就应该像这样：</p>
<img src="/images/loading.png" data-original="/2022/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/4.jpg" class title="This is an image"> 

<p>在例程中，由于前插法得到的链表顺序为最后输入的数据开始，所以最后打印的结果为3 2 1</p>
<h2 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h2><p>相对于前插法，尾插法使用起来逻辑会更加清晰，因为其链接顺序是在每一个节点后，所以尾插法要更容易理解一些。</p>
<p>在<a href="https://dhkkk.gitee.io/2022/08/01/C-%E7%BB%93%E6%9E%84%E4%BD%93/">结构体复习 | 小董的BLOG (gitee.io)</a>中讲到的列表就是使用的尾插法，核心代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">30</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;test;</span><br><span class="line"></span><br><span class="line">test *<span class="title function_">creat</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	test *linkhead,*linkend,*tmp;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp=(test*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(test));<span class="comment">//分配动态内存</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %s&quot;</span>,&amp;tmp-&gt;num,tmp-&gt;name);</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			linkhead=tmp;<span class="comment">//第一次先将当前节点赋给链头链尾</span></span><br><span class="line">			linkend=tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//若不是第一次，先将当前节点存入上一个节点的next中，再将linkend更新为当前节点以供下一次访问</span></span><br><span class="line">		&#123;                                                                <span class="comment">//当前节点的next</span></span><br><span class="line">			linkend-&gt;next=tmp;<span class="comment">//通过linkend直接指向内存中的一个struct list变量使其指向tmp的内存</span></span><br><span class="line">			linkend=tmp;</span><br><span class="line">         <span class="comment">//以第二个节点为例，先将第linkend（也就是tmp(1)）的指针域指向二个节点首地址</span></span><br><span class="line">         <span class="comment">//再将linkend指向tmp(2)，以供后面的节点重复23、24行的操作</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	linkend-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> linkhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果说前插法是通过linkhead为媒介进行链接，那尾插法就是通过linkend为媒介链接各节点。</p>
<h1 id="3-双向链表的创建"><a href="#3-双向链表的创建" class="headerlink" title="3.双向链表的创建"></a>3.双向链表的创建</h1><p>同样分为使用前插法和后插法，但是尾插法会简单很多，所以先讲一下尾插法</p>
<h2 id="尾插法创建双向链表"><a href="#尾插法创建双向链表" class="headerlink" title="尾插法创建双向链表"></a>尾插法创建双向链表</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">30</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">last</span>;</span>	<span class="comment">//存放上一节点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">next</span>;</span>	<span class="comment">//存放下一节点</span></span><br><span class="line">&#125;test;</span><br><span class="line"></span><br><span class="line">test *<span class="title function_">creat</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	test *linkhead,*linkend,*tmp;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp=(test*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(test)); </span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %s&quot;</span>,&amp;tmp-&gt;num,tmp-&gt;name);</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			linkhead=tmp;</span><br><span class="line">			linkend=tmp;</span><br><span class="line">			linkhead-&gt;last=<span class="literal">NULL</span>; <span class="comment">//因为链头没有上一节点，固其last指针域指向NULL</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			tmp-&gt;last=linkend;	<span class="comment">//把上一节点地址存入本节点的last指针中</span></span><br><span class="line">			linkend-&gt;next=tmp;</span><br><span class="line">			linkend=tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	linkend-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> linkhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尾插法由于其创建链表的方式为顺序创建，因此只需在原有的基础上添加存放上一节点的指针就行了</p>
<p>使用双向链表会增加内存，但是就可以通过任意节点找到其他节点了。</p>
<h2 id="使用前插法创建双向链表"><a href="#使用前插法创建双向链表" class="headerlink" title="使用前插法创建双向链表"></a>使用前插法创建双向链表</h2><p>使用前插法的话会稍微麻烦一些，而且理解起来也会有点绕，感觉用尾插法好一些。</p>
<p>（这是我自己写的方法，感觉有点绕）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> num; 	<span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">last</span>;</span>	</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">next</span>;</span>	</span><br><span class="line">&#125;test;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> time=<span class="number">1</span>;</span><br><span class="line">test* <span class="title function_">InsertList</span><span class="params">(test *head,<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">   test *tmp,*end;</span><br><span class="line">   tmp=(test *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (test));</span><br><span class="line">	<span class="keyword">if</span>(time==<span class="number">1</span>) <span class="comment">//建立第一个节点时将该节点作为链尾</span></span><br><span class="line">	&#123;</span><br><span class="line">		tmp-&gt;num=val;</span><br><span class="line">		tmp-&gt;last=head-&gt;last;</span><br><span class="line">		head-&gt;last=tmp;	</span><br><span class="line">		end=tmp;	<span class="comment">//end作为链尾将一直指向第一个建立的节点，后续不再改变end</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		tmp-&gt;num=val;</span><br><span class="line">		tmp-&gt;last=head-&gt;last;</span><br><span class="line">		head-&gt;last-&gt;next=tmp;	<span class="comment">//将上一个节点的next指针指向当前节点（有点套娃的感觉）</span></span><br><span class="line">		head-&gt;last=tmp;</span><br><span class="line">		tmp-&gt;next=<span class="literal">NULL</span>; <span class="comment">//每个节点的next先清零，为了让最后一个节点指向null</span></span><br><span class="line">	&#125;</span><br><span class="line">	++time;</span><br><span class="line">	<span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> a[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   test *linkhead, *linkend;</span><br><span class="line">   linkhead=(test *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (test));</span><br><span class="line">   linkhead-&gt;last=<span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">2</span>;i&gt;=<span class="number">0</span>;--i) <span class="comment">//由于是前插法，所以输入倒序输入</span></span><br><span class="line">   &#123;</span><br><span class="line">      linkend=InsertList(linkhead,a[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   test *p1,*p2;</span><br><span class="line">   p1=linkhead-&gt;last;</span><br><span class="line">   p2=linkend;</span><br><span class="line">   <span class="keyword">while</span>(p1!=<span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p1-&gt;num);</span><br><span class="line">      p1=p1-&gt;last;      </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span>(p2!=<span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p2-&gt;num);</span><br><span class="line">      p2=p2-&gt;next;      </span><br><span class="line">   &#125;</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/images/loading.png" data-original="/2022/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/5.jpg" class title="This is an image"> 

<p>在写这个双向链表时我遇见了个问题：对于linkend变量，我在主函数中定义后，像通过像linkhead一样的方式对linkend进行改变，但是始终无法实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertList</span><span class="params">(test *head,test *end;<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">   test *tmp,*end;</span><br><span class="line">   tmp=(test *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (test));</span><br><span class="line">	<span class="keyword">if</span>(time==<span class="number">1</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		tmp-&gt;num=val;</span><br><span class="line">		tmp-&gt;last=head-&gt;last;</span><br><span class="line">		head-&gt;last=tmp;	</span><br><span class="line">		end=tmp;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		tmp-&gt;num=val;</span><br><span class="line">		tmp-&gt;last=head-&gt;last;</span><br><span class="line">		head-&gt;last-&gt;next=tmp;	</span><br><span class="line">		head-&gt;last=tmp;</span><br><span class="line">		tmp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	++time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   test *linkhead, *linkend;</span><br><span class="line">   linkhead=(test *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (test));</span><br><span class="line">   linkhead-&gt;last=<span class="literal">NULL</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在主函数中没有对linkend分配内存，linkend将成为一个野指针，无法指向字符值常量。</p>
<p>但是如果分配了内存，由于linkhead是通过last成员来寻找链表，但是linkend却无法像linkhead一样正常实现功能，在经过整整一天的查找资料＆调试后，终于发现了原因：</p>
<p>当一个函数的形参是结构体指针时，<strong>这个形参本身的地址（不是所指向的地址）和实参的地址（也不是所指向的地址）是不同的</strong>。用例程举例：</p>
<ul>
<li><strong>&amp;linkend≠&amp;end，</strong>因此，<strong>在函数中改变形参end所指向的内容是完全不会影响实参linkend的，因为此时这两位可以理解成两个变量</strong></li>
</ul>
<p>那这时大家肯定会有个疑惑：那linkhead为什么就可以实现想要链表功能呢？</p>
<p>我们仔细看InsertList函数中的内容，你肯定会发现，函数中没有出现直接操作linkhead的操作，只有操作linkhead成员的操作，<strong>这里就引出了一个折磨了我半天的知识点</strong>：</p>
<ul>
<li><p>对于一个结构体指针形参，形参名的地址和实参名的地址是不能划等号的，<strong>但是形参成员的地址和实参成员的地址是完全相同的</strong>，用例程举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;linkend≠&amp;end</span><br><span class="line">linkend-&gt;next=end-&gt;next      (=是等于的意思，不是赋值的意思)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>其实这里的解释有点类似于在<a href="https://dhkkk.gitee.io/2022/08/01/C-%E7%BB%93%E6%9E%84%E4%BD%93/">结构体复习 | 小董的BLOG (gitee.io)</a>最后我对一重指针的解释：</p>
<ul>
<li><strong>假如有两个并列的指针指向同一个变量，你不能通过改变其中一个指针的指向来影响另一个指针的指向</strong></li>
</ul>
<p>那么这时又引出了一个问题，形参end和实参linkend指向哪里？</p>
<p>先说一下结论：<strong>linkend和end都指向linkend的第一个成员num的地址。</strong></p>
<p>也就是说，<strong>形参end和实参linkend作为两个不同的指针变量，他们指向了同一个地址</strong>（也许可以通过这一特性来写一个链表？但是我不想写了😋）</p>
<p>其实这个知识点符合我们对形参和指针变量的认知，所以这里比较重要的点其实是：</p>
<ul>
<li>不同于数组，<strong>结构体指针名地址≠第一个成员的地址，但指针名指向第一个成员的地址</strong>，可以理解为，结构体指针名指向一块内存，该内存是由若干个结构体成员组成的，这些成员的类型在定义结构体时确定。</li>
</ul>
<p>这也加深了我对<code>end=(LNode*)malloc(sizeof (LNode));</code>的理解，<strong>其实就是一个指针指向了一块内存，但是可以通过结构体的方式访问这块内存中的成员</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>当一个函数的参数是结构体指针时，操作这个函数的形参名不会影响实参，同时这个形参名的作用域只限于函数体；但是操作这个形参的任何成员等同于直接操作实参的对应成员，因为它们本身的地址是相同的</strong></li>
<li><strong>结构体指针名指向第一个成员的地址</strong></li>
</ul>
<p><strong>所以，结构体指针并不一定要指向一个明确的结构体，当他指向一块内存时，可以通过直接赋值结构体指针成员的方式操作这块内存</strong>（这块内存其实就是一个隐式的，没有具体名字的结构体）</p>
<p>一些感想：好久没有遇到过这么折磨的问题了，一开始完全没有头绪，网络上对于这方面的讲解也是几乎没有，还好找到了这篇博客启发了我[C语言理解指针作为形参作用](<a href="https://blog.csdn.net/qq_36733983/article/details/92184983?ops_request_misc=%7B%22request_id%22:%22166891705416800213084052%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&amp;request_id=166891705416800213084052&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-92184983-null-null.142%5Ev65%5Epc_rank_34_queryrelevant25,201%5Ev3%5Eadd_ask,213%5Ev2%5Et3_esquery_v3&amp;utm_term=C">https://blog.csdn.net/qq_36733983/article/details/92184983?ops_request_misc=%7B%22request%5Fid%22%3A%22166891705416800213084052%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=166891705416800213084052&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-92184983-null-null.142^v65^pc_rank_34_queryrelevant25,201^v3^add_ask,213^v2^t3_esquery_v3&amp;utm_term=C</a> 指针作为参数的作用域&amp;spm&#x3D;1018.2226.3001.4187)（博客中用的C++，但是原理是完全相同的）</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab</title>
    <url>/2022/11/09/matlab/</url>
    <content><![CDATA[<p><strong>内容大部分来自<a href="https://www.w3cschool.cn/matlab/matlab-5use28gb.html">MATLAB介绍_w3cschool</a>只是cv一下方便自己查阅</strong></p>
<h1 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h1><h2 id="常用运算符和特殊字符"><a href="#常用运算符和特殊字符" class="headerlink" title="常用运算符和特殊字符"></a>常用运算符和特殊字符</h2><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">目的</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>+</strong></td>
<td align="center">加；加法运算符</td>
</tr>
<tr>
<td align="center"><strong>-</strong></td>
<td align="center">减；减法运算符</td>
</tr>
<tr>
<td align="center">*****</td>
<td align="center">标量和矩阵乘法运算符</td>
</tr>
<tr>
<td align="center"><strong>.*</strong></td>
<td align="center">数组乘法运算符</td>
</tr>
<tr>
<td align="center"><strong>^</strong></td>
<td align="center">标量和矩阵求幂运算符</td>
</tr>
<tr>
<td align="center"><strong>.^</strong></td>
<td align="center">数组求幂运算符</td>
</tr>
<tr>
<td align="center">*<em>*</em></td>
<td align="center">矩阵左除</td>
</tr>
<tr>
<td align="center"><strong>&#x2F;</strong></td>
<td align="center">矩阵右除</td>
</tr>
<tr>
<td align="center">**.**</td>
<td align="center">阵列左除</td>
</tr>
<tr>
<td align="center"><strong>.&#x2F;</strong></td>
<td align="center">阵列右除</td>
</tr>
<tr>
<td align="center"><strong>:</strong></td>
<td align="center">向量生成；子阵提取</td>
</tr>
<tr>
<td align="center"><strong>( )</strong></td>
<td align="center">下标运算；参数定义</td>
</tr>
<tr>
<td align="center"><strong>[ ]</strong></td>
<td align="center">矩阵生成</td>
</tr>
<tr>
<td align="center"><strong>.</strong></td>
<td align="center">点乘运算，常与其他运算符联合使用</td>
</tr>
<tr>
<td align="center"><strong>…</strong></td>
<td align="center">续行标志；行连续运算符</td>
</tr>
<tr>
<td align="center"><strong>,</strong></td>
<td align="center">分行符（该行结果不显示）</td>
</tr>
<tr>
<td align="center"><strong>;</strong></td>
<td align="center"><strong>语句结束；分行符（该行结果显示）</strong></td>
</tr>
<tr>
<td align="center"><strong>%</strong></td>
<td align="center"><strong>注释标志</strong></td>
</tr>
<tr>
<td align="center"><strong>_</strong></td>
<td align="center">引用符号和转置运算符</td>
</tr>
<tr>
<td align="center"><strong>._</strong></td>
<td align="center">非共轭转置运算符</td>
</tr>
<tr>
<td align="center"><strong>&#x3D;</strong></td>
<td align="center">赋值运算符</td>
</tr>
</tbody></table>
<h2 id="特殊变量和常量"><a href="#特殊变量和常量" class="headerlink" title="特殊变量和常量"></a>特殊变量和常量</h2><table>
<thead>
<tr>
<th align="center">Name</th>
<th align="center">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>ans</strong></td>
<td align="center">默认的变量名，以应答最近依次操作运算结果</td>
</tr>
<tr>
<td align="center"><strong>eps</strong></td>
<td align="center">浮点数的相对误差</td>
</tr>
<tr>
<td align="center"><strong>i,j</strong></td>
<td align="center">虚数单位，定义为 i2 &#x3D; j2 &#x3D; -1</td>
</tr>
<tr>
<td align="center"><strong>Inf</strong></td>
<td align="center">代表无穷大</td>
</tr>
<tr>
<td align="center"><strong>NaN</strong></td>
<td align="center">代表不定值（不是数字）</td>
</tr>
<tr>
<td align="center"><strong>pi</strong></td>
<td align="center">圆周率</td>
</tr>
</tbody></table>
<h2 id="matlab命名变量"><a href="#matlab命名变量" class="headerlink" title="matlab命名变量"></a>matlab命名变量</h2><ul>
<li>名称为字母开头，后可接任意数量的下划线、字母、数字</li>
<li>区分大小写</li>
</ul>
<h2 id="保存工作进度"><a href="#保存工作进度" class="headerlink" title="保存工作进度"></a>保存工作进度</h2><p>MATLAB使用save命令保存工作区中的所有变量，然后作为一个扩展名为.mat的文件，在当前目录中。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">save myfile</span><br><span class="line">load myfile</span><br></pre></td></tr></table></figure>

<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="显示已使用的变量"><a href="#显示已使用的变量" class="headerlink" title="显示已使用的变量"></a>显示已使用的变量</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">who</span><br><span class="line">whos</span><br><span class="line">clear <span class="comment">%删除所有（或指定）的变量%</span></span><br></pre></td></tr></table></figure>

<h2 id="延伸行"><a href="#延伸行" class="headerlink" title="延伸行"></a>延伸行</h2><ul>
<li>使用<code>...</code>将当前行延伸至下一行</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">initial_velocity = <span class="number">0</span>;</span><br><span class="line">acceleration = <span class="number">9.8</span>;</span><br><span class="line">time = <span class="number">20</span>;</span><br><span class="line">final_velocity = initial_velocity ...</span><br><span class="line">    + acceleration * time</span><br></pre></td></tr></table></figure>

<h2 id="格式命令"><a href="#格式命令" class="headerlink" title="格式命令"></a>格式命令</h2><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">format short</td>
<td align="center">显示4位小数</td>
</tr>
<tr>
<td align="center">format long</td>
<td align="center">显示16位小数</td>
</tr>
<tr>
<td align="center">format bank</td>
<td align="center">显示两位小数</td>
</tr>
<tr>
<td align="center">format rat</td>
<td align="center">显示有理表达式</td>
</tr>
<tr>
<td align="center">format +</td>
<td align="center">正数</td>
</tr>
</tbody></table>
<ul>
<li>在命令后加<code>e</code>则会显示对应的指数形式</li>
</ul>
<h2 id="创建矩阵"><a href="#创建矩阵" class="headerlink" title="创建矩阵"></a>创建矩阵</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">m = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">m =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line">     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>同理可创建行、列向量。</p>
<h1 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h1><h2 id="向量、矩阵相关"><a href="#向量、矩阵相关" class="headerlink" title="向量、矩阵相关"></a>向量、矩阵相关</h2><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用&#x2F;目的</th>
</tr>
</thead>
<tbody><tr>
<td align="center">cat</td>
<td align="center">连接数组</td>
</tr>
<tr>
<td align="center">find</td>
<td align="center">查找非零元素的索引</td>
</tr>
<tr>
<td align="center">length</td>
<td align="center">计算元素数量</td>
</tr>
<tr>
<td align="center">linspace</td>
<td align="center">创建间隔向量</td>
</tr>
<tr>
<td align="center">logspace</td>
<td align="center">创建对数间隔向量</td>
</tr>
<tr>
<td align="center">max</td>
<td align="center">返回最大元素</td>
</tr>
<tr>
<td align="center">min</td>
<td align="center">返回最小元素</td>
</tr>
<tr>
<td align="center">prod</td>
<td align="center">计算数组元素的连乘积</td>
</tr>
<tr>
<td align="center">reshape</td>
<td align="center">重新调整矩阵的行数、列数、维数</td>
</tr>
<tr>
<td align="center">size</td>
<td align="center">计算数组大小</td>
</tr>
<tr>
<td align="center">sort</td>
<td align="center">排序每个列</td>
</tr>
<tr>
<td align="center">sum</td>
<td align="center">每列相加</td>
</tr>
<tr>
<td align="center">eye</td>
<td align="center">创建一个单位矩阵</td>
</tr>
<tr>
<td align="center">ones</td>
<td align="center">生成全1矩阵</td>
</tr>
<tr>
<td align="center">zeros</td>
<td align="center">生成零矩阵</td>
</tr>
<tr>
<td align="center">cross</td>
<td align="center">计算矩阵交叉乘积</td>
</tr>
<tr>
<td align="center">dot</td>
<td align="center">计算矩阵点积</td>
</tr>
<tr>
<td align="center">det</td>
<td align="center">计算数组的行列式</td>
</tr>
<tr>
<td align="center">inv</td>
<td align="center">计算矩阵的逆</td>
</tr>
<tr>
<td align="center">pinv</td>
<td align="center">计算矩阵的伪逆</td>
</tr>
<tr>
<td align="center">rank</td>
<td align="center">计算矩阵的秩</td>
</tr>
<tr>
<td align="center">rref</td>
<td align="center">将矩阵化成行最简形</td>
</tr>
<tr>
<td align="center">cell</td>
<td align="center">创建单元数组</td>
</tr>
<tr>
<td align="center">celldisp</td>
<td align="center">显示单元数组</td>
</tr>
<tr>
<td align="center">cellplot</td>
<td align="center">显示单元数组的图形表示</td>
</tr>
<tr>
<td align="center">num2cell</td>
<td align="center">将数值阵列转化为异质阵列</td>
</tr>
<tr>
<td align="center">deal</td>
<td align="center">匹配输入和输出列表</td>
</tr>
<tr>
<td align="center">iscell</td>
<td align="center">判断是否为元胞类型</td>
</tr>
</tbody></table>
<h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用&#x2F;目的</th>
</tr>
</thead>
<tbody><tr>
<td align="center">axis</td>
<td align="center">人工选择坐标轴尺寸</td>
</tr>
<tr>
<td align="center">fplot</td>
<td align="center">智能绘图功能</td>
</tr>
<tr>
<td align="center">grid</td>
<td align="center">显示网格线</td>
</tr>
<tr>
<td align="center">plot</td>
<td align="center">生成XY图</td>
</tr>
<tr>
<td align="center">print</td>
<td align="center">打印或绘图到文件</td>
</tr>
<tr>
<td align="center">title</td>
<td align="center">把文字置于顶部</td>
</tr>
<tr>
<td align="center">xlabel</td>
<td align="center">将文本标签添加到x轴</td>
</tr>
<tr>
<td align="center">ylabel</td>
<td align="center">将文本标签添加到y轴</td>
</tr>
<tr>
<td align="center">axes</td>
<td align="center">创建轴对象</td>
</tr>
<tr>
<td align="center">close</td>
<td align="center">关闭当前的绘图</td>
</tr>
<tr>
<td align="center">close all</td>
<td align="center">关闭所有绘图</td>
</tr>
<tr>
<td align="center">figure</td>
<td align="center">打开一个新的图形窗口</td>
</tr>
<tr>
<td align="center">gtext</td>
<td align="center">通过鼠标在指定位置放注文</td>
</tr>
<tr>
<td align="center">hold</td>
<td align="center">保持当前图形</td>
</tr>
<tr>
<td align="center">legend</td>
<td align="center">鼠标放置图例</td>
</tr>
<tr>
<td align="center">refresh</td>
<td align="center">重新绘制当前图形窗口</td>
</tr>
<tr>
<td align="center">set</td>
<td align="center">指定对象的属性，如轴</td>
</tr>
<tr>
<td align="center">subplot</td>
<td align="center">在子窗口中创建图</td>
</tr>
<tr>
<td align="center">text</td>
<td align="center">在图上做标记</td>
</tr>
<tr>
<td align="center">bar</td>
<td align="center">创建条形图</td>
</tr>
<tr>
<td align="center">loglog</td>
<td align="center">创建双对数图</td>
</tr>
<tr>
<td align="center">polar</td>
<td align="center">创建极坐标图像</td>
</tr>
<tr>
<td align="center">semilogx</td>
<td align="center">创建半对数图（对数横坐标）</td>
</tr>
<tr>
<td align="center">semilogy</td>
<td align="center">创建半对数图（对数纵坐标）</td>
</tr>
<tr>
<td align="center">stairs</td>
<td align="center">创建阶梯图</td>
</tr>
<tr>
<td align="center">stem</td>
<td align="center">创建针状图</td>
</tr>
</tbody></table>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="常用的数据类型"><a href="#常用的数据类型" class="headerlink" title="常用的数据类型"></a>常用的数据类型</h2><table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>int8</code></td>
<td align="center"><code>8</code>位有符号整数</td>
</tr>
<tr>
<td align="center"><code>uint8</code></td>
<td align="center"><code>8</code>位无符号整数</td>
</tr>
<tr>
<td align="center"><code>int16</code></td>
<td align="center"><code>16</code>位有符号整数</td>
</tr>
<tr>
<td align="center"><code>uint16</code></td>
<td align="center"><code>16</code>位无符号整数</td>
</tr>
<tr>
<td align="center"><code>int32</code></td>
<td align="center"><code>32</code>位有符号整数</td>
</tr>
<tr>
<td align="center"><code>uint32</code></td>
<td align="center"><code>32</code>位无符号整数</td>
</tr>
<tr>
<td align="center"><code>int64</code></td>
<td align="center"><code>64</code>位有符号整数</td>
</tr>
<tr>
<td align="center"><code>uint64</code></td>
<td align="center"><code>64</code>位无符号整数</td>
</tr>
<tr>
<td align="center"><code>single</code></td>
<td align="center">单精度数值数据</td>
</tr>
<tr>
<td align="center"><code>double</code></td>
<td align="center">双精度数值数据</td>
</tr>
<tr>
<td align="center"><code>logical</code></td>
<td align="center">逻辑值为<code>1</code>或<code>0</code>，分别代表<code>true</code>和<code>false</code></td>
</tr>
<tr>
<td align="center"><code>char</code></td>
<td align="center">字符数据(字符串作为字符向量存储)</td>
</tr>
</tbody></table>
<ul>
<li><p>但是用法和C不同，matlab中用法类似于函数（matlab的变量不用任何定义语句）</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">str = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line">n = <span class="number">2345</span></span><br><span class="line">d = double(n)</span><br><span class="line">un = uint32(<span class="number">789.50</span>)</span><br><span class="line">rn = <span class="number">5678.92347</span></span><br><span class="line">c = int32(rn)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="数据类型确认函数"><a href="#数据类型确认函数" class="headerlink" title="数据类型确认函数"></a>数据类型确认函数</h2><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">描述说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>is</code></td>
<td align="center">检测状态</td>
</tr>
<tr>
<td align="center"><code>isa</code></td>
<td align="center">确定输入是否是指定类的对象</td>
</tr>
<tr>
<td align="center"><code>iscell</code></td>
<td align="center">确定输入是单元格数组</td>
</tr>
<tr>
<td align="center"><code>iscellstr</code></td>
<td align="center">确定输入是字符串的单元格数组</td>
</tr>
<tr>
<td align="center"><code>ischar</code></td>
<td align="center">确定项目是否是字符数组</td>
</tr>
<tr>
<td align="center"><code>isfield</code></td>
<td align="center">确定输入是否是结构数组字段</td>
</tr>
<tr>
<td align="center"><code>isfloat</code></td>
<td align="center">确定输入是否为浮点数组</td>
</tr>
<tr>
<td align="center"><code>ishghandle</code></td>
<td align="center">确定是否用于处理图形对象句柄</td>
</tr>
<tr>
<td align="center"><code>isinteger</code></td>
<td align="center">确定输入是否为整数数组</td>
</tr>
<tr>
<td align="center"><code>isjava</code></td>
<td align="center">确定输入是否为Java对象</td>
</tr>
<tr>
<td align="center"><code>islogical</code></td>
<td align="center">确定输入是否为逻辑数组</td>
</tr>
<tr>
<td align="center"><code>isnumeric</code></td>
<td align="center">确定输入是否是数字数组</td>
</tr>
<tr>
<td align="center"><code>isobject</code></td>
<td align="center">确定输入是否为MATLAB对象</td>
</tr>
<tr>
<td align="center"><code>isreal</code></td>
<td align="center">检查输入是否为实数数组</td>
</tr>
<tr>
<td align="center"><code>isscalar</code></td>
<td align="center">确定输入是否为标量</td>
</tr>
<tr>
<td align="center"><code>isstr</code></td>
<td align="center">确定输入是否是字符数组</td>
</tr>
<tr>
<td align="center"><code>isstruct</code></td>
<td align="center">确定输入是否是结构数组</td>
</tr>
<tr>
<td align="center"><code>isvector</code></td>
<td align="center">确定输入是否为向量</td>
</tr>
<tr>
<td align="center"><code>class</code></td>
<td align="center">确定对象的类</td>
</tr>
<tr>
<td align="center"><code>validateattributes</code></td>
<td align="center">检查数组的有效性</td>
</tr>
<tr>
<td align="center"><code>whos</code></td>
<td align="center">在工作区中列出变量，其大小和类型</td>
</tr>
</tbody></table>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">目的&#x2F;作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bitand(a, b)</td>
<td align="left">当a、b是一个或数个无符号整数或无符号整数数组，返回参数a和b位和，</td>
</tr>
<tr>
<td align="left">bitcmp(a)</td>
<td align="left">a的补码</td>
</tr>
<tr>
<td align="left">bitget(a,pos)</td>
<td align="left">在指定位置pos中获取位，在整数数组a中</td>
</tr>
<tr>
<td align="left">bitor(a, b)</td>
<td align="left">对数a和b按位或</td>
</tr>
<tr>
<td align="left">bitset(a, pos)</td>
<td align="left">a的集合点在一个特定的位置pos</td>
</tr>
<tr>
<td align="left">bitshift(a, k)</td>
<td align="left">返回一个移到左K位，相当于乘以2K。K负值对应的位权转移或除以2|K|向负无穷舍入到最近的整数。任何溢出位都被截断。</td>
</tr>
<tr>
<td align="left">bitxor(a, b)</td>
<td align="left">对数a和b按位异或</td>
</tr>
<tr>
<td align="left">swapbytes</td>
<td align="left">交换字节顺序</td>
</tr>
</tbody></table>
<h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">intersect(A,B)</td>
<td align="left">设置两个数组的交集；返回A和B所共有的值。返回的值按排序顺序排列。</td>
</tr>
<tr>
<td align="left">intersect(A,B,’rows’)</td>
<td align="left">将A和B的每一行作为单个实体处理，并返回A和B的公共行。返回的矩阵的行按排序顺序排列。</td>
</tr>
<tr>
<td align="left">ismember(A,B)</td>
<td align="left">返回与A大小相同的数组，包含1（true），其中A的元素在其他地方的B中找到，它返回0（false）。</td>
</tr>
<tr>
<td align="left">ismember(A,B,’rows’)</td>
<td align="left">将A和B的每一行作为单个实体处理，并返回一个包含1（true）的向量，其中矩阵A的行也是B的行；否则，它返回0（false）。</td>
</tr>
<tr>
<td align="left">issorted(A)</td>
<td align="left">如果A的元素按排序顺序返回逻辑1（true），否则返回逻辑0（false）。输入A可以是向量，也可以是N-by-1或1-by-N的字符串数组。如果A和sort（A）的输出相等，则A被认为是排序的。</td>
</tr>
<tr>
<td align="left">issorted(A, ‘rows’)</td>
<td align="left">如果二维矩阵A的行按排序顺序返回逻辑1（真），否则返回逻辑0（假）。 如果A和排序（A）的输出相等，则认为矩阵A被排序。</td>
</tr>
<tr>
<td align="left">setdiff(A,B)</td>
<td align="left">设置两个数组的差值；返回不在B中的值。返回数组中的值按排序顺序排列。</td>
</tr>
<tr>
<td align="left">setdiff(A,B,’rows’)</td>
<td align="left">将每一行A和B行作为单个实体处理，并返回一个不在B中的行。返回的矩阵的行按排序顺序排列。“行”选项不支持单元格数组。</td>
</tr>
<tr>
<td align="left">setxor</td>
<td align="left">设置两个数组的异或</td>
</tr>
<tr>
<td align="left">union</td>
<td align="left">设置两个数组的并集</td>
</tr>
<tr>
<td align="left">unique</td>
<td align="left">数组中唯一的值</td>
</tr>
</tbody></table>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (...)</span><br><span class="line">	.....;</span><br><span class="line">	.....;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(...)</span><br><span class="line">	<span class="keyword">case</span> .. 	<span class="comment">%无冒号</span></span><br><span class="line">		....;</span><br><span class="line">		....;</span><br><span class="line">	<span class="keyword">case</span> ..</span><br><span class="line">		....	<span class="comment">%单行可以不加分号</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>其他用法与C基本相同</li>
<li>end后不须跟分号（即使后面还有语句）</li>
</ul>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while()</span><br><span class="line">	...;</span><br><span class="line">	...;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for循环有三种用法：</p>
<ul>
<li><p>initval:endval  默认步长为+1，递增</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> a = <span class="number">10</span>:<span class="number">20</span> </span><br><span class="line">	...;</span><br><span class="line">	...;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>initval:step:endval  step可自定义步长</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> a = <span class="number">1.0</span>: <span class="number">-0.1</span>: <span class="number">0.0</span></span><br><span class="line">	...;</span><br><span class="line">	...;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>索引数组</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> a = [<span class="number">24</span>,<span class="number">18</span>,<span class="number">17</span>,<span class="number">23</span>,<span class="number">28</span>]</span><br><span class="line">	...;</span><br><span class="line">	...;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h1><h2 id="元素索引"><a href="#元素索引" class="headerlink" title="元素索引"></a>元素索引</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">rv = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>];</span><br><span class="line">sub_rv = rv(<span class="number">3</span>:<span class="number">7</span>)</span><br><span class="line">rv(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="向量转置"><a href="#向量转置" class="headerlink" title="向量转置"></a>向量转置</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">r = [ <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> ];</span><br><span class="line">tr = r&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="求向量的模"><a href="#求向量的模" class="headerlink" title="求向量的模"></a>求向量的模</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">v = [<span class="number">1</span>: <span class="number">2</span>: <span class="number">20</span>];</span><br><span class="line">sv = v.* v;    </span><br><span class="line">dp = sum(sv);    </span><br><span class="line">mag = <span class="built_in">sqrt</span>(dp);  </span><br></pre></td></tr></table></figure>

<h2 id="向量点积"><a href="#向量点积" class="headerlink" title="向量点积"></a>向量点积</h2><p>若要求取向量的点积，不能直接使用运算符求得，需使用函数dot(a,b)</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">v1 = [<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>];</span><br><span class="line">v2 = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>];</span><br><span class="line">dp = <span class="built_in">dot</span>(v1, v2);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>*</code>号用于运算矩阵乘法，而<code>.*</code>用于数组的乘法（数组的乘法有一套自己的算法）</li>
</ul>
<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="矩阵索引"><a href="#矩阵索引" class="headerlink" title="矩阵索引"></a>矩阵索引</h2><ul>
<li><p>第m行，第n列的一个元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mx(m,n);</span><br></pre></td></tr></table></figure>
</li>
<li><p>第m列的所有元素</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a = [ <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>; <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>];</span><br><span class="line">v = a(:,<span class="number">4</span>) <span class="comment">%第4列的所有元素，并返回一个列向量</span></span><br></pre></td></tr></table></figure>

<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a = [ <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>; <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>];</span><br><span class="line">a(:, <span class="number">2</span>:<span class="number">3</span>) <span class="comment">%第2-3列的所有元素</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注：索引从1开始，而不是0</strong></p>
<h2 id="删除行或列"><a href="#删除行或列" class="headerlink" title="删除行或列"></a>删除行或列</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = [ 1 2 3 4 5; 2 3 4 5 6; 3 4 5 6 7; 4 5 6 7 8];</span><br><span class="line">a( 4 , : ) = []</span><br></pre></td></tr></table></figure>

<h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a = [ <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> ; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>];</span><br><span class="line">b = [ <span class="number">7</span> <span class="number">5</span> <span class="number">6</span> ; <span class="number">2</span> <span class="number">0</span> <span class="number">8</span>; <span class="number">5</span> <span class="number">7</span> <span class="number">1</span>];</span><br><span class="line">c = a / b	<span class="comment">%a右乘b的逆矩阵(inv(b))</span></span><br><span class="line">d = a \ b	<span class="comment">%b左乘a的逆矩阵</span></span><br></pre></td></tr></table></figure>

<ul>
<li>必须为方阵，因为只有方阵才有逆矩阵</li>
</ul>
<h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a = [ <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>; <span class="number">1</span> <span class="number">2</span> <span class="number">5</span>]</span><br><span class="line">det(a)</span><br></pre></td></tr></table></figure>

<ul>
<li>行列式一定为方阵</li>
<li>转置不改变行列式的值</li>
</ul>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = [7 9 5; 6 1 9; 4 3 2];</span><br><span class="line">a(:, :, 2)= [ 1 2 3; 4 5 6; 7 8 9];</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">a(:,:,1) =</span><br><span class="line">     7     9     5</span><br><span class="line">     6     1     9</span><br><span class="line">     4     3     2</span><br><span class="line"></span><br><span class="line">a(:,:,2) =</span><br><span class="line">     1     2     3</span><br><span class="line">     4     5     6</span><br><span class="line">     7     8     9</span><br></pre></td></tr></table></figure>

<p>或使用cat函数：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">b = <span class="built_in">cat</span>(<span class="number">3</span>,a,[ <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]); <span class="comment">%维度+要串联的阵列</span></span><br></pre></td></tr></table></figure>

<h1 id="单元阵列"><a href="#单元阵列" class="headerlink" title="单元阵列"></a>单元阵列</h1><p>单元阵列的阵列中每个单元格可以存储不同的维度和数据类型的数组的索引单元格</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">C = cell(dim1,...,dimN) <span class="comment">%dim 是一个标量整数或整数向量，指定单元格阵列C的尺寸</span></span><br></pre></td></tr></table></figure>

<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">c = cell(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">c = &#123;<span class="string">&#x27;Red&#x27;</span>, <span class="string">&#x27;Blue&#x27;</span>, <span class="string">&#x27;Green&#x27;</span>, <span class="string">&#x27;Yellow&#x27;</span>, <span class="string">&#x27;White&#x27;</span>; <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">c = </span><br><span class="line">    <span class="string">&#x27;Red&#x27;</span>    <span class="string">&#x27;Blue&#x27;</span>    <span class="string">&#x27;Green&#x27;</span>    <span class="string">&#x27;Yellow&#x27;</span>    <span class="string">&#x27;White&#x27;</span></span><br><span class="line">    [  <span class="number">1</span>]    [   <span class="number">2</span>]    [    <span class="number">3</span>]    [     <span class="number">4</span>]    [    <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<h2 id="单元阵列索引"><a href="#单元阵列索引" class="headerlink" title="单元阵列索引"></a>单元阵列索引</h2><p>可以使用大括号或小括号索引，索引方法与前相同</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="一般函数格式"><a href="#一般函数格式" class="headerlink" title="一般函数格式"></a>一般函数格式</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[out1,out2,...]</span> = <span class="title">fun_name</span><span class="params">(in1,in2,...)</span></span></span><br><span class="line"><span class="comment">%帮助文本</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">power = @(x, n) x.^n;</span><br><span class="line">result1 = power(<span class="number">7</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h1 id="绘图-1"><a href="#绘图-1" class="headerlink" title="绘图"></a>绘图</h1><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">plot</span>(x, y), xlabel(<span class="string">&#x27;x&#x27;</span>), ylabel(<span class="string">&#x27;Sin(x)&#x27;</span>), title(<span class="string">&#x27;Sin(x) Graph&#x27;</span>),</span><br></pre></td></tr></table></figure>

<h2 id="绘制多条曲线"><a href="#绘制多条曲线" class="headerlink" title="绘制多条曲线"></a>绘制多条曲线</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = [<span class="number">-10</span> : <span class="number">0.01</span>: <span class="number">10</span>];</span><br><span class="line">y = <span class="number">3</span>*x.^<span class="number">4</span> + <span class="number">2</span> * x.^<span class="number">3</span> + <span class="number">7</span> * x.^<span class="number">2</span> + <span class="number">2</span> * x + <span class="number">9</span>;</span><br><span class="line">g = <span class="number">5</span> * x.^<span class="number">3</span> + <span class="number">9</span> * x + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">plot</span>(x, y, <span class="string">&#x27;r&#x27;</span>, x, g, <span class="string">&#x27;g&#x27;</span>) <span class="comment">% &#x27;r&#x27;,&#x27;g&#x27;代表曲线颜色</span></span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;y(x)&#x27;</span>,<span class="string">&#x27;g(x)&#x27;</span>);</span><br></pre></td></tr></table></figure>

<img src="/images/loading.png" data-original="/2022/11/09/matlab/p1.jpg" class title="This is an image"> 

<h2 id="设置轴刻度"><a href="#设置轴刻度" class="headerlink" title="设置轴刻度"></a>设置轴刻度</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">axis ( [xmin xmax ymin ymax] )</span><br></pre></td></tr></table></figure>

<h1 id="代数"><a href="#代数" class="headerlink" title="代数"></a>代数</h1><h2 id="声明一个代数"><a href="#声明一个代数" class="headerlink" title="声明一个代数"></a>声明一个代数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">syms x </span><br></pre></td></tr></table></figure>

<h2 id="解代数方程"><a href="#解代数方程" class="headerlink" title="解代数方程"></a>解代数方程</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">solve(x^<span class="number">2</span> <span class="number">-7</span>*x + <span class="number">12</span> == <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>或：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">eq=<span class="string">&#x27;x^2 -7*x + 12 == 0&#x27;</span>;</span><br><span class="line">result=solve(eq);</span><br></pre></td></tr></table></figure>

<p>若要单独显示各个根：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">disp</span>(result(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">disp</span>(result(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">disp</span>(result(<span class="number">3</span>));</span><br><span class="line"><span class="built_in">disp</span>(result(<span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>我的matlab必须手动打印结果，不知道为什么</strong></li>
</ul>
<h1 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h1><p>当计算一个一元多次项时，可以使用行向量表示，例如：</p>
<p>方程 P(x) &#x3D; x^4 + 7x^3 - 5x + 9 可以表示为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p = [1 7 0 -5 9]；</span><br></pre></td></tr></table></figure>

<p>求解：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">polyval(p,<span class="number">4</span>) <span class="comment">%计算当x=4时多项式的值</span></span><br></pre></td></tr></table></figure>

<p>还可以通过输入矩阵的方式计算多个值：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">p = [<span class="number">1</span> <span class="number">7</span> <span class="number">0</span>  <span class="number">-5</span> <span class="number">9</span>];</span><br><span class="line">X = [<span class="number">1</span> <span class="number">2</span> <span class="number">-3</span> <span class="number">4</span>; <span class="number">2</span> <span class="number">-5</span> <span class="number">6</span> <span class="number">3</span>; <span class="number">3</span> <span class="number">1</span> <span class="number">0</span> <span class="number">2</span>; <span class="number">5</span> <span class="number">-7</span> <span class="number">3</span> <span class="number">8</span>];</span><br><span class="line">polyval(p, X);</span><br><span class="line"></span><br><span class="line"><span class="comment">%结果：</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">        <span class="number">2307</span>       <span class="number">-1769</span>        <span class="number">-939</span>        <span class="number">4499</span></span><br><span class="line">        <span class="number">2314</span>       <span class="number">-2376</span>        <span class="number">-249</span>        <span class="number">4695</span></span><br><span class="line">        <span class="number">2256</span>       <span class="number">-1892</span>        <span class="number">-549</span>        <span class="number">4310</span></span><br><span class="line">        <span class="number">4570</span>       <span class="number">-4532</span>       <span class="number">-1062</span>        <span class="number">9269</span></span><br></pre></td></tr></table></figure>

<h2 id="使用多项式的曲线拟合"><a href="#使用多项式的曲线拟合" class="headerlink" title="使用多项式的曲线拟合"></a>使用多项式的曲线拟合</h2><p>当我们要对离散点拟合一条曲线时，可以使用polyfit函数，该函数的作用是通过最小二乘法的方式<strong>拟合出一条曲线的多项式</strong>。</p>
<ul>
<li>polyfit(x,y,n)	n为需要拟合的最高次幂，具体求法可参考[MATLAB polyfit曲线拟合及拟合最高次幂的选择](<a href="https://blog.csdn.net/weixin_39796363/article/details/116188595?ops_request_misc=%7B%22request_id%22:%22166808186016782425129618%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&amp;request_id=166808186016782425129618&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-6-116188595-null-null.142%5Ev63%5Epc_rank_34_queryrelevant25,201%5Ev3%5Eadd_ask,213%5Ev2%5Et3_esquery_v3&amp;utm_term=matlab">https://blog.csdn.net/weixin_39796363/article/details/116188595?ops_request_misc=%7B%22request%5Fid%22%3A%22166808186016782425129618%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=166808186016782425129618&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-6-116188595-null-null.142^v63^pc_rank_34_queryrelevant25,201^v3^add_ask,213^v2^t3_esquery_v3&amp;utm_term=matlab</a> polyfit&amp;spm&#x3D;1018.2226.3001.4187)</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]; y = [<span class="number">5.5</span> <span class="number">43.1</span> <span class="number">128</span> <span class="number">290.7</span> <span class="number">498.4</span> <span class="number">978.67</span>]; </span><br><span class="line">p = polyfit(x,y,<span class="number">5</span>)   </span><br></pre></td></tr></table></figure>

<p>此时p为一个多项式，可以使用polyval在坐标集上拟合出该曲线</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x2 = <span class="number">1</span>:<span class="number">0.1</span>:<span class="number">6</span>;          </span><br><span class="line">y2 = polyval(p,x2);</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;o&#x27;</span>,x2,y2)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>C++_IO库</title>
    <url>/2022/10/31/C++-7/</url>
    <content><![CDATA[<h1 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h1><p>在之前的一些用到输入与输出的程序都是用户对流的读写，也就是使用的iostream类，但是C++中的IO处理并不止通过流进行读写，为了支持不同的IO操作，标准库中还定义了其他的一些IO类，他们被包含在不同的头文件中：</p>
<table>
<thead>
<tr>
<th align="center">头文件</th>
<th align="center">类</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">iostream</td>
<td align="center">(w)istream<br>(w)ostream<br>(w)iostream</td>
<td align="center">从<strong>普通流</strong>中读写数据</td>
</tr>
<tr>
<td align="center">fstream</td>
<td align="center">(w)ifstream<br>(w)ofstream<br>(w)fstream</td>
<td align="center">从<strong>文件流</strong>中读写数据</td>
</tr>
<tr>
<td align="center">sstream</td>
<td align="center">(w)istringstream<br>(w)ostringstream<br>(w)stringstream</td>
<td align="center">从<strong>字符串流</strong>中读写数据</td>
</tr>
</tbody></table>
<ul>
<li>在类和其函数前添加w则为正常类对象、函数等（例如wcin，wcout）的宽字符版。</li>
</ul>
<h2 id="IO类型间的关系"><a href="#IO类型间的关系" class="headerlink" title="IO类型间的关系"></a>IO类型间的关系</h2><p>类型ifstream和istringstream都<strong>继承</strong>自istream，因此，我们如何使用istream，就如何使用其他IO类型。在之后介绍的标准库的流特性<strong>均可以无差别地使用于各个IO类型</strong>。</p>
<h1 id="IO类型的特性"><a href="#IO类型的特性" class="headerlink" title="IO类型的特性"></a>IO类型的特性</h1><h2 id="IO对象不能拷贝"><a href="#IO对象不能拷贝" class="headerlink" title="IO对象不能拷贝"></a>IO对象不能拷贝</h2><p>当我们定义了一些IO对象时（通常是用于IO操作的一些函数），之前也使用过，是不能对这些对象进行拷贝或赋值的操作的，<strong>因此当我们操作流时，通常都是使用引用的方式传递和返回流</strong>，这也意味着这些IO操作函数的返回类型要定义为IO类的引用，参数中的流也需定义为IO类的引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;in, person &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in&gt;&gt;item.name&gt;&gt;item.addr;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;<span class="comment">//上一章讲到的read函数就是一个IO操作函数</span></span><br></pre></td></tr></table></figure>

<h2 id="条件状态"><a href="#条件状态" class="headerlink" title="条件状态"></a>条件状态</h2><p>当使用IO操作流时可能会发生多种错误，为了查询这些错误，标准库中定义了相关函数和标准以访问当前流的条件状态。</p>
<p>流分为以下几个状态：（这些状态为IO类中定义）</p>
<table>
<thead>
<tr>
<th align="center">badbit</th>
<th align="center">当前流已崩溃</th>
</tr>
</thead>
<tbody><tr>
<td align="center">failbit</td>
<td align="center">当前IO操作失败了</td>
</tr>
<tr>
<td align="center">eofbit</td>
<td align="center">当前流到达了文件结束</td>
</tr>
<tr>
<td align="center">goodbit</td>
<td align="center">为0代表流正常</td>
</tr>
</tbody></table>
<ul>
<li>可以对这些状态位进行位运算</li>
<li>badbit表示系统级错误，是不可恢复的错误。通常一旦被置位，流就无法再使用了。</li>
<li>failbit表示可恢复的错误，修正后流可以机械使用。<strong>badbit被置位后failbit也会被置位</strong>。</li>
<li>如果文件结束，failbit和eofbit<strong>都会被置位</strong>。</li>
<li>上面三位<strong>任意一位有置位情况goodbit都会被置位</strong>。</li>
</ul>
<p>以下是IO类的一些查询函数：</p>
<table>
<thead>
<tr>
<th align="center">类的子函数</th>
<th align="center">作用</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">eof()</td>
<td align="center">查询eofbit状态</td>
<td align="center">若对应状态位<strong>置位</strong>则返回ture</td>
</tr>
<tr>
<td align="center">fail()</td>
<td align="center">查询failbit状态</td>
<td align="center">若对应状态位<strong>置位</strong>则返回ture</td>
</tr>
<tr>
<td align="center">bad()</td>
<td align="center">查询badbit状态</td>
<td align="center">若对应状态位<strong>置位</strong>则返回ture</td>
</tr>
<tr>
<td align="center">good()</td>
<td align="center">查询goodbit状态</td>
<td align="center">若对应状态位<strong>置位</strong>则返回ture</td>
</tr>
<tr>
<td align="center">clear()</td>
<td align="center">将流中所有条件状态位复位</td>
<td align="center">void</td>
</tr>
<tr>
<td align="center">rdstate()</td>
<td align="center">返回当前流的状态</td>
<td align="center">一种包含所有状态位信息的类，但类型同状态位</td>
</tr>
<tr>
<td align="center">clear(flag)</td>
<td align="center">复位指定状态位</td>
<td align="center">void</td>
</tr>
<tr>
<td align="center">setstate(flag)</td>
<td align="center">置位指定状态位</td>
<td align="center">void</td>
</tr>
</tbody></table>
<h3 id="管理条件状态"><a href="#管理条件状态" class="headerlink" title="管理条件状态"></a>管理条件状态</h3><p>每进行一次流操作后恢复上一次的条件状态：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> oldstate = cin.<span class="built_in">rdstate</span>();</span><br><span class="line">cin.<span class="built_in">clear</span>();</span><br><span class="line">cin&gt;&gt;....<span class="comment">//一次输入流操作</span></span><br><span class="line">cin.<span class="built_in">setstate</span>(oldstate);</span><br></pre></td></tr></table></figure>

<p>通过位操作一次操作多个状态位：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设当前所有状态置位</span></span><br><span class="line">cin.<span class="built_in">clear</span>(cin.<span class="built_in">rdstate</span>() &amp; ~cin.failbit &amp; ~cin.badbit)<span class="comment">//只复位failbit，badbit</span></span><br></pre></td></tr></table></figure>

<h2 id="输出流的缓冲"><a href="#输出流的缓冲" class="headerlink" title="输出流的缓冲"></a>输出流的缓冲</h2><h3 id="刷新缓冲区"><a href="#刷新缓冲区" class="headerlink" title="刷新缓冲区"></a>刷新缓冲区</h3><p>之前讲到过输出endl可以刷新缓冲区，还有以下操作也可以刷新</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;endl; <span class="comment">//换行</span></span><br><span class="line">cout&lt;&lt;flush; <span class="comment">//不添加任何额外字符</span></span><br><span class="line">cout&lt;&lt;ends; <span class="comment">//添加一个空字符</span></span><br></pre></td></tr></table></figure>

<h3 id="刷新缓冲区的作用"><a href="#刷新缓冲区的作用" class="headerlink" title="刷新缓冲区的作用"></a>刷新缓冲区的作用</h3><p>我其实也不是特别理解，姑且谈一下我的理解，这是网上的一个例程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">setvbuf</span>( stdout, <span class="literal">NULL</span>, _IOLBF, <span class="number">1024</span> );  <span class="comment">//设置控制台输出为行缓存模式，把缓冲区与流相关 </span></span><br><span class="line">	cout &lt;&lt;<span class="string">&quot;hello world\n&quot;</span>&lt;&lt;endl;                </span><br><span class="line">	<span class="built_in">Sleep</span>(<span class="number">5000</span>);                            </span><br><span class="line">	cout &lt;&lt;<span class="string">&quot;leeboy&quot;</span> &lt;&lt;endl;                 </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果第四行不刷新缓冲区，则4行内容会和7行在5s后一起输出，所以刷新缓冲区的作用应该是立即输出当前内容？而按照网上说法，如果不刷新缓冲区，输出是由系统每隔一段时间检测输出流是否有内容。</p>
<h3 id="unitbuf操作符"><a href="#unitbuf操作符" class="headerlink" title="unitbuf操作符"></a>unitbuf操作符</h3><p>如果想设置每一次输出后自动刷新缓冲区，可以：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;std::unitbuf;</span><br><span class="line">cout&lt;&lt;std::nounitbuf;<span class="comment">//恢复正常缓冲模式</span></span><br></pre></td></tr></table></figure>

<h3 id="关联输入和输出流"><a href="#关联输入和输出流" class="headerlink" title="关联输入和输出流"></a>关联输入和输出流</h3><p>关联后任何试图从输入流读取数据的操作都会先刷新关联的输出流</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin&gt;&gt;std::ival;<span class="comment">//默认情况下cin和cerr都关联到了cout</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C_杂项</title>
    <url>/2022/10/30/C-%E6%9D%82%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="位域结构体"><a href="#位域结构体" class="headerlink" title="位域结构体"></a>位域结构体</h1><p>有时候，信息存储的时候，并不需要一个完整的字节，而只需占几个或一个二进制位就能满足需求。例如存放一个bool类型的变量，只需要true或者false即可，这种情况下，只需要0或者1一位二进制位即可。为了节省存储空间，并使处理简便，C语言又提供了一种数据结构，称为“位域”或“位段”。<strong>所谓“位域”是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。</strong>每个域有一个域名，允许在程序中按域名进行操作。<strong>这样就可以把几个不同的对象用一个字节的二进制位域来表示。</strong></p>
<p>格式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">net_pro_cdu</span>  </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="type">unsigned</span>  <span class="type">char</span> acs:<span class="number">4</span> </span><br><span class="line">    <span class="type">unsigned</span>  <span class="type">char</span> :<span class="number">0</span>  </span><br><span class="line">    <span class="type">unsigned</span>  <span class="type">char</span> ace:<span class="number">4</span>  </span><br><span class="line">    <span class="type">unsigned</span>  <span class="type">char</span> dve:<span class="number">4</span> </span><br><span class="line">&#125; Ncdu;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>无位域名的位域不能使用，仅用来填充、调整尾置（如第四行）</li>
<li>位大小不能超过定义用的类型（如上述例子位数不能超过8）</li>
</ul>
<h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><p>声明一个变量是易变的，可以防止编译器对程序一些变量运算的过度优化。</p>
<h1 id="for循环执行顺序"><a href="#for循环执行顺序" class="headerlink" title="for循环执行顺序"></a>for循环执行顺序</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">     <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行顺序解抛<br>执行的顺序如下：<br>第一步 ： i&#x3D;0  初始化值<br>第二步 ： i&lt;5 进行条件判断，如果为真，则继续执行<br>第三步 ： 执行循环体的内容<br>第四步 ： i++ 变量i自增<br>第五步 ： 回到第二步，条件判断为真，则执行循环体内容，再到i++一直循环，<br>直到第二步的判断条件为假，则退出该循环</p>
<p>原文链接：<a href="https://blog.csdn.net/weixin_44080187/article/details/123429045">https://blog.csdn.net/weixin_44080187/article/details/123429045</a></p>
]]></content>
      <tags>
        <tag>C语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C++_类</title>
    <url>/2022/10/26/C++-6/</url>
    <content><![CDATA[<h1 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h1><h2 id="定义一个类"><a href="#定义一个类" class="headerlink" title="定义一个类"></a>定义一个类</h2><p>C++中可以使用struct和class构建一个类，struct为继承C语言留下，但用法与C不同。struct和class使用方法完全相同，只是对类成员默认的访问权限不同，这点后面会谈到。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span>/<span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	string addr;</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在类的外部定义成员函数"><a href="#在类的外部定义成员函数" class="headerlink" title="在类的外部定义成员函数"></a>在类的外部定义成员函数</h2><p>C++的struct与C最不同的一点就是C++可以在类中定义函数，例如上述类中声明了一个返回值为int型的函数。</p>
<p>该函数的内容可以在类中定义，也可以只在类中声明，再在外部定义。在外部定义时需注意以下几点：</p>
<ul>
<li>函数类型声明、函数名、参数列表必须和声明中一致</li>
<li>由于函数是在类中声明，在定义时需声明其命名空间（声明函数名）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">person::test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定义一个返回类的函数"><a href="#定义一个返回类的函数" class="headerlink" title="定义一个返回类的函数"></a>定义一个返回类的函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	string addr;</span><br><span class="line">   <span class="function">person&amp; <span class="title">copy</span><span class="params">(<span class="type">const</span> person &amp;x)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      name=x.name;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>该函数同样可以在类外定义，规则同上一节</p>
</li>
<li><p>函数返回的类型<strong>必须为引用</strong>，因为返回的值应该为一个左值</p>
</li>
<li><p>若函数参数也为一个类对象，也必须为引用格式</p>
</li>
<li><p>return *this意为返回该调用该函数的对象，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">person test1,test2;</span><br><span class="line">test1.name=&quot;dhk&quot;; test2.name=&quot;aca&quot;;</span><br><span class="line">test1.copy(test2);</span><br><span class="line">cout&lt;&lt;test1.name; //输出&quot;aca&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数体中的name和addr为调用该函数的对象的类成员</p>
</li>
</ul>
<h2 id="定义类相关的非成员函数"><a href="#定义类相关的非成员函数" class="headerlink" title="定义类相关的非成员函数"></a>定义类相关的非成员函数</h2><h3 id="通过定义流的引用直接操作类成员的输入输出"><a href="#通过定义流的引用直接操作类成员的输入输出" class="headerlink" title="通过定义流的引用直接操作类成员的输入输出"></a>通过定义流的引用直接操作类成员的输入输出</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;in, person &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in&gt;&gt;item.name&gt;&gt;item.addr;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;out, person &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    out&lt;&lt;<span class="string">&quot;NAME: &quot;</span>&lt;&lt;item.name&lt;&lt;endl;</span><br><span class="line">    out&lt;&lt;<span class="string">&quot;ADDR: &quot;</span>&lt;&lt;item.addr&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>istream和ostream需提前声明其命名空间</li>
<li>IO类不能被拷贝，因此当其作为参数时<strong>必须通过引用传递值</strong></li>
<li>此处print函数的参数item可以不使用引用</li>
</ul>
<h1 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h1><p>当我们定义一个类对象时，并没有对每一个类成员进行初始化，这时，编译器便通过一个特殊的构造函数来控制当前初始化，此函数叫做默认构造函数，<strong>该函数会对所有成员进行默认初始化。</strong></p>
<p>但是如果我们想在定义类对象时就对一些成员进行我们想要的初始化该怎么办呢？这时我们就可以自己定义构造函数对一些类成员进行想要的初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span></span><br><span class="line">&#123;	</span><br><span class="line">   <span class="built_in">person</span>()=<span class="keyword">default</span>;</span><br><span class="line">   <span class="built_in">person</span>(string s1, string s2) &#123;name=s1;addr=s2;&#125;</span><br><span class="line">   <span class="built_in">person</span>(person &amp;item) &#123;<span class="built_in">copy</span>(item);&#125;</span><br><span class="line">   <span class="built_in">person</span>(istream &amp;in) &#123;<span class="built_in">read</span>(in,*<span class="keyword">this</span>);&#125;</span><br><span class="line"><span class="comment">/**********************以上为构造函数*******************/</span>      </span><br><span class="line">	string name;</span><br><span class="line">	string addr;</span><br><span class="line">   <span class="function">person&amp; <span class="title">copy</span><span class="params">(<span class="type">const</span> person &amp;x)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      name=x.name;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;in, person &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in&gt;&gt;item.name&gt;&gt;item.addr;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   person a;</span><br><span class="line">   <span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;dhk&quot;</span>)</span>,<span class="title">s2</span><span class="params">(<span class="string">&quot;aca&quot;</span>)</span></span>; <span class="function">person <span class="title">b</span><span class="params">(s1,s2)</span></span>;</span><br><span class="line">   <span class="function">person <span class="title">c</span><span class="params">(b)</span></span>;</span><br><span class="line">   <span class="function">person <span class="title">d</span><span class="params">(cin)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在person类中一共定义了四个构造函数，下面将分别讲解这四个构造函数的含义和相关知识：</p>
<ul>
<li><p><code>person()=default;</code>默认构造函数</p>
<p>当一个类中定义了其他构造函数时，编译器便不会自动生成默认构造函数。因此，若没有此函数，主函数中24行便会报错，原因是没有与当前定义情况匹配的构造函数。</p>
</li>
<li><p><code>person(string s1, string s2)</code></p>
<p>如主函数25行，当初始化参数为两个string对象时，会进入该构造函数，该构造函数的作用是将类成员赋值为两个string对象。需要注意：</p>
<ul>
<li><p>大括号内为构造函数的函数体，可以在此完成一系列的初始化</p>
</li>
<li><p>这里也有一种构造初始值列表的初始化方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">person</span>(string s1, string s2): <span class="built_in">name</span>(s1),<span class="built_in">addr</span>(s2) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>两种方式作用完全相同，但是实现的原理有所差异，这点后面会讲到。</p>
</li>
</ul>
</li>
<li><p><code>person(person &amp;item)</code></p>
<p>如主函数26行，类初始化的参数也可以为一个类对象，该构造函数会直接将输入参数用于执行copy函数，相当于通过copy函数间接给类成员赋值。</p>
</li>
<li><p><code>person(istream &amp;in)</code></p>
<p>如27行，输入参数为一个IO类型的引用，需要注意此时read函数第二个参数为*this</p>
</li>
</ul>
<h2 id="构造函数初始值列表和赋值的区别"><a href="#构造函数初始值列表和赋值的区别" class="headerlink" title="构造函数初始值列表和赋值的区别"></a>构造函数初始值列表和赋值的区别</h2><p>之前我们讲到了构造函数对类成员的操作有两种：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">person</span>(string s1, string s2) &#123;name=s1;addr=s2;&#125;</span><br><span class="line"><span class="built_in">person</span>(string s1, string s2): <span class="built_in">name</span>(s1),<span class="built_in">addr</span>(s2) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>两个操作在效果上一样，但是第一种操作根源上为赋值，而第二种操作才是初始化，在大部分情况下二者区别不大但是如果当类成员为引用或者const类型时，此时将不能赋值，但是可以初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">person</span>(<span class="type">int</span> i) &#123;a=i;r=i&#125; <span class="comment">//错误的，不能给引用和常量赋值</span></span><br><span class="line">   <span class="built_in">person</span>(<span class="type">int</span> i): <span class="built_in">a</span>(i),<span class="built_in">r</span>(i) &#123;&#125; <span class="comment">//正确</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> &amp;r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="访问控制和封装"><a href="#访问控制和封装" class="headerlink" title="访问控制和封装"></a>访问控制和封装</h1><p>前面讲到了使用class和struct唯一区别是对类成员默认的访问权限不同，C++中可以使用访问说明符来管理类成员的访问权限以达到更好的封装。如果使用struct，则在第一个访问说明符前的成员默认为public，class则相反。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;	</span><br><span class="line">   <span class="keyword">public</span>: <span class="comment">//以下成员在整个程序中都可以被访问</span></span><br><span class="line">   <span class="built_in">person</span>()=<span class="keyword">default</span>;</span><br><span class="line">   <span class="built_in">person</span>(string s1, string s2) &#123;name=s1;addr=s2;&#125;</span><br><span class="line">   <span class="built_in">person</span>(person &amp;item) &#123;<span class="built_in">copy</span>(item);&#125;</span><br><span class="line">   <span class="built_in">person</span>(istream &amp;in) &#123;<span class="built_in">read</span>(in,*<span class="keyword">this</span>);&#125;  </span><br><span class="line">   <span class="keyword">private</span>: <span class="comment">//以下成员只可以被类的成员函数访问</span></span><br><span class="line">	string name;</span><br><span class="line">	string addr;</span><br><span class="line">   <span class="function">person&amp; <span class="title">copy</span><span class="params">(<span class="type">const</span> person &amp;x)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      name=x.name;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意，private说明符后的成员<strong>只可以被类的成员函数访问，</strong>像前面讲到的read和print函数不属于类的成员函数，因此无法访问private中的成员。</p>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>若想非类成员函数访问private内容,可以在类中<strong>使用friend关键字对其进行友元声明</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> istream &amp;<span class="title">read</span><span class="params">(istream &amp;in, person &amp;item)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">friend</span> ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;out, person &amp;item)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;in, person &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in&gt;&gt;item.name&gt;&gt;item.addr;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;out, person &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    out&lt;&lt;<span class="string">&quot;NAME: &quot;</span>&lt;&lt;item.name&lt;&lt;endl;</span><br><span class="line">    out&lt;&lt;<span class="string">&quot;ADDR: &quot;</span>&lt;&lt;item.addr&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>友元声明也适用于声明其他类及其成员函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">test</span>;</span><br><span class="line">   <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">test::test1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="关于类的静态成员"><a href="#关于类的静态成员" class="headerlink" title="关于类的静态成员"></a>关于类的静态成员</h1><p>在仔细阅读了书籍过后个人觉得用处不是特别大，如果以后用到了相关知识再在这里补充，目前就不写了。</p>
]]></content>
      <tags>
        <tag>C++学习</tag>
      </tags>
  </entry>
  <entry>
    <title>51单片机汇编指令查询</title>
    <url>/2022/10/14/51%E5%8D%95%E7%89%87%E6%9C%BA%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h1 id="1、寻址"><a href="#1、寻址" class="headerlink" title="1、寻址"></a>1、寻址</h1><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p>寻找操作数的地址的各种方式。</p>
<h3 id="1-立即寻址"><a href="#1-立即寻址" class="headerlink" title="1.立即寻址"></a>1.立即寻址</h3><p>直接使用操作数将操作数存入相关地址中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV R0,#26H</span><br><span class="line">MOV DPTR,#2000H</span><br></pre></td></tr></table></figure>

<ul>
<li>立即数可以是8位或16位</li>
<li>立即数前必须加<code>#</code></li>
</ul>
<h3 id="2-直接寻址"><a href="#2-直接寻址" class="headerlink" title="2.直接寻址"></a>2.直接寻址</h3><p>将操作数视为地址，并将该地址存储的数据转递到相关地址中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV A,30H //相当于对30H进行解引用，将30H值传入A中</span><br></pre></td></tr></table></figure>

<h3 id="3-寄存器寻址"><a href="#3-寄存器寻址" class="headerlink" title="3.寄存器寻址"></a>3.寄存器寻址</h3><p>直接使用寄存器名字作为地址并对进行解引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV A,R1 //*R1</span><br></pre></td></tr></table></figure>

<h3 id="4-寄存器间接寻址"><a href="#4-寄存器间接寻址" class="headerlink" title="4.寄存器间接寻址"></a>4.寄存器间接寻址</h3><p>指定寄存器的内容为操作数的地址，该地址存储的内容才是操作数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV A,@R0 // @R0相当于**R0</span><br></pre></td></tr></table></figure>

<ul>
<li>需使用间址符<code>@</code></li>
<li>对外部RAM进行读取时必须采用该方式</li>
</ul>
<h3 id="5-变址寻址"><a href="#5-变址寻址" class="headerlink" title="5.变址寻址"></a>5.变址寻址</h3><p>通过对基地址进行偏移获得当前操作数地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV A,#06H</span><br><span class="line">MOVC A,@A+PC</span><br></pre></td></tr></table></figure>

<p>由于这里（@A+PC）整体应为一个地址，所以这里要对<strong>A使用间址符取06H作为地址</strong>的偏移量，因此该两行指令的意思为：将（@A+PC）地址中存储的数据传入A中</p>
<h3 id="6-相对寻址"><a href="#6-相对寻址" class="headerlink" title="6.相对寻址"></a>6.相对寻址</h3><p>直接以PC作为基地址，只写出相对偏移量，有两种方式：</p>
<h4 id="无条件转移："><a href="#无条件转移：" class="headerlink" title="无条件转移："></a>无条件转移：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SJMP 08H //使PC转移至当前PC值+08H（当前PC为下一指令地址）</span><br></pre></td></tr></table></figure>

<h4 id="条件转移："><a href="#条件转移：" class="headerlink" title="条件转移："></a>条件转移：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JZ LOP //仅当（A）=0时执行，LOP为标号</span><br></pre></td></tr></table></figure>

<h3 id="7-位寻址"><a href="#7-位寻址" class="headerlink" title="7.位寻址"></a>7.位寻址</h3><h1 id="2、指令系统"><a href="#2、指令系统" class="headerlink" title="2、指令系统"></a>2、指令系统</h1><h2 id="1-数据传送指令"><a href="#1-数据传送指令" class="headerlink" title="1.数据传送指令"></a>1.数据传送指令</h2><ul>
<li>片内数据传送：MOV	访问内部RAM</li>
<li>片外数据传送：MOVX    访问外部RAM</li>
<li>程序存储器数据传送：MOVC    访问内外ROM</li>
</ul>
<h2 id="2-数据交换指令"><a href="#2-数据交换指令" class="headerlink" title="2.数据交换指令"></a>2.数据交换指令</h2><ul>
<li><p>字节交换（全部）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XCH A,Rn</span><br><span class="line">XCH A,@Ri //寄存器区只有R0和R1可用作间接寻址</span><br></pre></td></tr></table></figure>
</li>
<li><p>字节交换（低四位）：XCHD</p>
</li>
<li><p>字节交换（高低互换）：SWAP</p>
</li>
</ul>
<h2 id="3-堆栈操作指令"><a href="#3-堆栈操作指令" class="headerlink" title="3.堆栈操作指令"></a>3.堆栈操作指令</h2><ul>
<li>入栈：PUSH	SP先变化再压栈</li>
<li>出栈：POP      先出栈再变化SP</li>
</ul>
<h2 id="4-算术运算指令"><a href="#4-算术运算指令" class="headerlink" title="4.算术运算指令"></a>4.算术运算指令</h2><ul>
<li>加法<ul>
<li>不带进位： ADD</li>
<li>带进位（Cy）：ADDC</li>
<li>加一：INC</li>
</ul>
</li>
<li>减法<ul>
<li>不带进位：SUB</li>
<li>带进位：SUBB</li>
<li>减一：DEC</li>
</ul>
</li>
<li>乘法：MUL</li>
<li>除法：DIV</li>
</ul>
<h2 id="5-逻辑运算指令"><a href="#5-逻辑运算指令" class="headerlink" title="5.逻辑运算指令"></a>5.逻辑运算指令</h2><ul>
<li>逻辑与：ANL</li>
<li>逻辑或：ORL</li>
<li>逻辑异或：XRL</li>
<li>取反：CPL</li>
<li>清零：CLR</li>
<li>移位<ul>
<li>不带进位：RL&#x2F;RR 左移&#x2F;右移1位</li>
<li>带进位：RLC&#x2F;RRC ~</li>
</ul>
</li>
</ul>
<h2 id="6-位运算"><a href="#6-位运算" class="headerlink" title="6.位运算"></a>6.位运算</h2><p>该运算对象仅针对Cy和bit型对象</p>
<ul>
<li>位传送：MOV</li>
<li>置1：SETB</li>
<li>清0：CLR</li>
<li>取非：CPL</li>
<li>取与：ANL</li>
<li>取或：ORL</li>
</ul>
<h2 id="7-控制转移类指令"><a href="#7-控制转移类指令" class="headerlink" title="7.控制转移类指令"></a>7.控制转移类指令</h2><ul>
<li><p>无条件转移：LJMP  3字节，直接转移至该16位地址</p>
</li>
<li><p>相对转移：SJMP</p>
</li>
<li><p>条件转移：**(条件转移皆为相对PC的转移)**</p>
<ul>
<li><p>累加器<u><strong>判0</strong></u>：JZ&#x2F;JNZ</p>
</li>
<li><p>进位Cy判断：JC&#x2F;JNC</p>
</li>
<li><p>任意位判断：JB&#x2F;JNB&#x2F;JBC</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JB bit,rel</span><br><span class="line">// bit: 判断位  rel：偏移量</span><br></pre></td></tr></table></figure>
</li>
<li><p>比较<strong>不相等</strong>判断（不相等为满足条件）:CJNE</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CJNE A,#data,rel</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>减1<strong>不为0</strong>判断转移：DJNZ</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>嵌入式学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C++的语句与函数</title>
    <url>/2022/10/11/C++-5/</url>
    <content><![CDATA[<h1 id="try语句与异常处理"><a href="#try语句与异常处理" class="headerlink" title="try语句与异常处理"></a>try语句与异常处理</h1><p>通常的异常处理包括三部分：</p>
<ul>
<li>throw表达式：使用throw表达式表示当前程序遇到了某个问题（异常声明）</li>
<li>try语句块：与catch配合用于处理各类异常声明</li>
<li>一套异常类：用于传递具体的异常信息（异常声明的含义）</li>
</ul>
<h2 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::runtime_error;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a!=b) <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;ERROR!!!&quot;</span>);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;good&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(runtime_error err)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;err.<span class="built_in">what</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="throw表达式"><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a!=b) <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;ERROR!!!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>格式：throw+异常类+初始化异常类对象</p>
<ul>
<li><p>该初始化的对象只用于提供一些关于异常的辅助信息（用户自行定义）</p>
</li>
<li><p>异常类为一系列在库中定义的类型，使用时需要声明其命名空间，以下是几种常用的异常类，在头文件stdexcept中</p>
<table>
<thead>
<tr>
<th align="center">exception</th>
<th align="center">一般错误</th>
</tr>
</thead>
<tbody><tr>
<td align="center">runtime_error</td>
<td align="center">运行时才能检测出的任务</td>
</tr>
<tr>
<td align="center">range_error</td>
<td align="center">运行时：生成结果超出有意义的值域范围的错误</td>
</tr>
<tr>
<td align="center">overflow_error</td>
<td align="center">运行时：计算上溢错误</td>
</tr>
<tr>
<td align="center">underflow_error</td>
<td align="center">运行时：计算下溢错误</td>
</tr>
<tr>
<td align="center">logic_error</td>
<td align="center">程序逻辑错误</td>
</tr>
<tr>
<td align="center">domain_error</td>
<td align="center">逻辑错误：参数对应的结果不存在</td>
</tr>
<tr>
<td align="center">invalid_error</td>
<td align="center">逻辑错误：无效参数</td>
</tr>
<tr>
<td align="center">length_error</td>
<td align="center">逻辑错误：超出对象类型长度</td>
</tr>
<tr>
<td align="center">out_of_range</td>
<td align="center">逻辑错误：超出有效范围</td>
</tr>
</tbody></table>
<ul>
<li><p>除exception外其他类型都<strong>必须</strong>用一个字符串初始化，而exception则不允许这种初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(a!=b) <span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;good&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(exception)</span><br><span class="line">&#123;</span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;ERROR!!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="try语句块"><a href="#try语句块" class="headerlink" title="try语句块"></a>try语句块</h2><p>格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123; &#125;<span class="comment">//程序正常逻辑，异常类在此throw出 </span></span><br><span class="line"><span class="built_in">catch</span>(异常声明)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="built_in">catch</span>(异常声明)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当try内一旦提出异常类时，就不再执行该throw表达式后的内容；反之，若没有throw任何异常，则不会触发任何catch语句，程序正常执行完try语句。</li>
<li>catch括号中需定义一个对象，类型为触发的异常类，这些异常类只有一个子函数what，用于输出初始化时的字符串（不能用于exception类）</li>
</ul>
<p>当有多个try语句块嵌套时，当最内部try提出了一个异常，会由内到外执行catch，若最终都没有对应catch，则程序转到terminate的标准库函数，该函数行为与系统有关，通常执行该函数会导致程序非正常退出。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><ul>
<li>形参实参之间的转递为值拷贝</li>
<li>C++中建议用引用类型的形参代替指针形参，引用类型同样可以达到修改值的内容，并且可以避免拷贝，因为引用是与实参绑定的。</li>
</ul>
<h2 id="数组的传递"><a href="#数组的传递" class="headerlink" title="数组的传递"></a>数组的传递</h2><p>以下三种对形参的定义是等价的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">(<span class="type">const</span> <span class="type">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">b</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">c</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p>编译器在编译时只会检查传入的参数类型是否为const int*型，甚至不会检查传入数组的长度是否超出形参大小。</p>
<h3 id="数组的引用形参"><a href="#数组的引用形参" class="headerlink" title="数组的引用形参"></a>数组的引用形参</h3><p>可以使用数组的引用作为形参：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> (&amp;arr)[<span class="number">10</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">auto</span> elem : arr)</span><br><span class="line">      cout&lt;&lt;elem&lt;&lt;endl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用数组的引用作为形参需要注意：</p>
<ul>
<li>初始化时必须使用括号括起&amp;arr</li>
<li>输入的实参<strong>必须为一个int [10]类型</strong>的对象</li>
</ul>
<h2 id="函数的返回类型"><a href="#函数的返回类型" class="headerlink" title="函数的返回类型"></a>函数的返回类型</h2><h3 id="返回引用"><a href="#返回引用" class="headerlink" title="返回引用"></a>返回引用</h3><p>函数返回引用可以理解为返回的为一个地址</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> <span class="title">test1</span><span class="params">(string s ,string::size_type num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> s[num];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> &amp;<span class="title">test2</span><span class="params">(string &amp;s ,string::size_type num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> s[num];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">srting <span class="title">s</span><span class="params">(<span class="string">&quot;test&quot;</span>)</span></span>;</span><br><span class="line">   cout&lt;&lt;<span class="built_in">test1</span>(s,<span class="number">0</span>)&lt;&lt;endl; <span class="comment">//t</span></span><br><span class="line">   <span class="built_in">test2</span>(s,<span class="number">0</span>)=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">   cout&lt;&lt;s[<span class="number">0</span>]&lt;&lt;endl;       <span class="comment">//a</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个函数的返回值为引用时，该返回值为左值而非右值，因此可以像使用其他左值一样使用这个返回值</p>
<p>（注：左值≠地址，它仍然是一个值）</p>
<ul>
<li><p><strong>不可返回局部变量的引用</strong>，由于局部变量在函数完成后会被释放，因此在函数完成后引用会找不到它的对象。例如上一个例程，如果把test2()函数改为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> &amp;<span class="title">test2</span><span class="params">(string s ,string::size_type num)</span><span class="comment">//此处形参不再是引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> s[num];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">srting <span class="title">s</span><span class="params">(<span class="string">&quot;test&quot;</span>)</span></span>;</span><br><span class="line">   <span class="built_in">test2</span>(s,<span class="number">0</span>)=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">   cout&lt;&lt;s[<span class="number">0</span>]&lt;&lt;endl;      <span class="comment">//t</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的返回值为对s的引用，但s本身为一个局部变量，在函数完成时已经被释放，因此该引用是无效的（但是这样<strong>返回形参的引用</strong>编译器并不会报错，而返回<strong>函数内定义的局部变量</strong>的引用会报错）</p>
<p>但如果形参定义为引用，由于引用本身是不占用存储空间的，所以’a’可以通过引用直接向s[0]赋值</p>
</li>
</ul>
<h3 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a>返回数组指针</h3><ul>
<li><p>尾置返回类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[10]</span></span><br></pre></td></tr></table></figure>

<p>声明函数的返回值为一个含有十个整数的数组的指针</p>
</li>
<li><p>使用decltype</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> test[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(test) *<span class="built_in">func</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;test;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	cout&lt;&lt;*(*func+<span class="number">1</span>); <span class="comment">//输出2</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>decltype(test)的结果是一个数组，因此函数前要用*声明返回值为指针</li>
<li>使用此方法返回的是一个数组的整体地址，而不是首地址，类型为int*[5]，因此一次解引用的结果才是首地址</li>
</ul>
</li>
</ul>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>正常的调用函数一般比等价的表达式要慢（保存寄存器、拷贝等操作），因此对于规模较小的函数可以定义为内联函数类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">fuc</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h2><p>将函数隐式地定义为内联函数，但函数内只能有一条return语句，且返回值必须为字面值</p>
]]></content>
      <tags>
        <tag>C++学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C++_表达式</title>
    <url>/2022/10/03/C++-4/</url>
    <content><![CDATA[<h1 id="1、基础内容"><a href="#1、基础内容" class="headerlink" title="1、基础内容"></a>1、基础内容</h1><p>表达式是<strong>由一个或多个运算对象组成</strong>，对表达式求值得到的是一个<strong>结果</strong>，字面值和变量时最简单的表达式。</p>
<h2 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h2><p>当一个对象被用作右值时，使用的是该对象的值；而被用作左值时，使用的时对象的内存。</p>
<ul>
<li>赋值运算符需要一个非常量左值为其左侧运算对象</li>
<li>取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，该指针为右值</li>
<li>解引用求值结果为左值</li>
</ul>
<h2 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h2><p>部分运算符是没有明确指明执行顺序的，例如&lt;&lt;运算符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;i&lt;&lt;<span class="string">&quot;&quot;</span>&lt;&lt;++i;</span><br></pre></td></tr></table></figure>

<p>++i和i没有明确的先后关系，因此编译器可能做出任何行为。</p>
<p>当多个函数会影响同一对象时，当同时调用这些函数时，调用函数的顺序也没有明确的先后关系。</p>
<h1 id="2、算术运算符"><a href="#2、算术运算符" class="headerlink" title="2、算术运算符"></a>2、算术运算符</h1><h2 id="bool类型"><a href="#bool类型" class="headerlink" title="bool类型"></a>bool类型</h2><p>bool类型原则不应参与运算，在运算时会自动转化为int型的1，只要计算结果不为0，都将返回ture</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>C++大部分同优先级运算都满足从左至右的规律，赋值则相反</p>
<h2 id="递增运算"><a href="#递增运算" class="headerlink" title="递增运算"></a>递增运算</h2><p>C++中，<strong>非必要不使用</strong>后置递增&#x2F;减符（i++&#x2F;i–)，因为前置运算为将对象本身作为左值返回，而后置则要额外的空间存储原始值，并将这个额外存储的原始值副本作为右值返回，因此，使用后置操作会消耗更多内存，这在相对复杂的工作中是消耗巨大的。</p>
<h2 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h2><p>关于符号位的处理没有明确规定，因此位运算最好用来处理无符号类型</p>
<h1 id="3、类型转换"><a href="#3、类型转换" class="headerlink" title="3、类型转换"></a>3、类型转换</h1><p>C++的类型转换格式不同于C：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cast-name&lt;类型&gt;(表达式)</span><br></pre></td></tr></table></figure>

<p>最常用的cast-name为<code>static_cast</code>和<code>const_cast</code></p>
<h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>任何有明确定义的类型转换（除了底层const）都可以使用static_cast</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *p = &amp;d;<span class="comment">//d不能为常量（底层const）</span></span><br><span class="line"><span class="type">double</span> *dp = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>*&gt;(p);</span><br></pre></td></tr></table></figure>

<h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p><strong>专用</strong>于改变底层const，其作用为改变const性质</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* pc;</span><br><span class="line"><span class="type">char</span> *p=<span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(pc);</span><br></pre></td></tr></table></figure>

<p>需要注意，可以有以下用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* pc;</span><br><span class="line"><span class="type">char</span> *p=<span class="built_in">const_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(pc);</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++学习</tag>
      </tags>
  </entry>
  <entry>
    <title>python_2</title>
    <url>/2022/09/16/python-2/</url>
    <content><![CDATA[<h1 id="开始编程"><a href="#开始编程" class="headerlink" title="开始编程"></a>开始编程</h1><h2 id="1、条件控制"><a href="#1、条件控制" class="headerlink" title="1、条件控制"></a>1、条件控制</h2><p>一般形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1:</span><br><span class="line">    statement_block_1</span><br><span class="line"><span class="keyword">elif</span> condition_2:</span><br><span class="line">    statement_block_2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement_block_3</span><br></pre></td></tr></table></figure>

<ul>
<li>记得在条件后加<code>:</code></li>
<li>Python 中用 <strong>elif</strong> 代替了 <strong>else if</strong>，所以if语句的关键字为：<strong>if – elif – else</strong></li>
<li>python中没有switch语句</li>
</ul>
<h2 id="2、循环语句"><a href="#2、循环语句" class="headerlink" title="2、循环语句"></a>2、循环语句</h2><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><p>可以与else配合使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while &lt;expr&gt;:</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line">else:</span><br><span class="line">    &lt;additional_statement(s)&gt;</span><br></pre></td></tr></table></figure>

<h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><p>一般格式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;dhk&#x27;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> a: </span><br><span class="line">	<span class="built_in">print</span>(x,end=<span class="string">&#x27;&#x27;</span>) <span class="comment">#dhk</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;error!!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>不同于C，python的for语句常用来遍历某个可迭代对象，如列表、字符串，如上的循环中，x每次只取遍历对象的<strong>最基本单位并自动递增</strong>。</p>
<h3 id="range函数"><a href="#range函数" class="headerlink" title="range函数"></a>range函数</h3><p>生成一个数字序列，格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>):</span><br><span class="line">   <span class="built_in">print</span>(x,end=<span class="string">&#x27;&#x27;</span>)<span class="comment">#13579</span></span><br></pre></td></tr></table></figure>

<p>range函数的指定区间同样<strong>遵循左闭右开</strong>的原则</p>
<h3 id="pass语句"><a href="#pass语句" class="headerlink" title="pass语句"></a>pass语句</h3><p>空语句，表示空</p>
<h2 id="3、迭代器"><a href="#3、迭代器" class="headerlink" title="3、迭代器"></a>3、迭代器</h2><p>迭代是Python最强大的功能之一，是<strong>访问集合元素的一种方式</strong>。</p>
<p>迭代器是一个<strong>可以记住遍历的位置</strong>的对象。</p>
<p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    <span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    it = <span class="built_in">iter</span>(<span class="built_in">list</span>)  <span class="comment"># 创建迭代器对象</span></span><br><span class="line">    it2 = <span class="built_in">iter</span>(<span class="built_in">list</span>)  <span class="comment"># 创建迭代器对象</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">        <span class="keyword">if</span> x != <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">print</span>(x, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(x)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(it2))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(it2))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(it2))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(it2))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1 2 3 4</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="把一个类作为迭代器使用："><a href="#把一个类作为迭代器使用：" class="headerlink" title="把一个类作为迭代器使用："></a>把一个类作为迭代器使用：</h3><p>若想把一个类作为迭代器使用，需要在类中实现两个方法：</p>
<ul>
<li><p><code>__iter__()</code>:返回一个特殊的迭代器对象， 这个迭代器对象实现了 <strong>next</strong>() 方法并通过 StopIteration 异常标识迭代的完成。</p>
</li>
<li><p><code>__next__()</code>:返回下一个迭代器对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">class</span> <span class="title class_">MyNumbers</span>:</span><br><span class="line">       <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">           self.a = <span class="number">1</span></span><br><span class="line">           <span class="keyword">return</span> self</span><br><span class="line">  </span><br><span class="line">       <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">           <span class="keyword">if</span> self.a &lt;= <span class="number">20</span>:</span><br><span class="line">               x = self.a</span><br><span class="line">               self.a += <span class="number">1</span></span><br><span class="line">               <span class="keyword">return</span> x</span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               <span class="keyword">raise</span> StopIteration <span class="comment">#挂起StopIteration标志迭代完成，不能用return</span></span><br><span class="line">   a = MyNumbers()</span><br><span class="line">   i = <span class="built_in">iter</span>(a)</span><br><span class="line">   <span class="keyword">for</span> x <span class="keyword">in</span> i:</span><br><span class="line">       <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="comment">#1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 </span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4、生成器"><a href="#4、生成器" class="headerlink" title="4、生成器"></a>4、生成器</h2><p> 在 Python 中，使用了 yield 的函数被称为生成器（generator）。</p>
<p>在调用生成器运行的过程中，<strong>每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值</strong>, 并在下一次执行 next() 方法时从当前位置继续运行。</p>
<ul>
<li>生成器函数返回的是一个<strong>迭代器对象</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>): <span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n): </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">f = fibonacci(<span class="number">10</span>) <span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(f), end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure>

<h2 id="5、函数"><a href="#5、函数" class="headerlink" title="5、函数"></a>5、函数</h2><p>规则：</p>
<ul>
<li>函数代码块以 <strong>def</strong> 关键词开头，后接函数标识符名称和圆括号 **()**。</li>
<li>函数内容以冒号 <strong>:</strong> 起始，并且缩进。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def 函数名（参数列表）:</span><br><span class="line">    函数体</span><br></pre></td></tr></table></figure>

<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>在调用函数时，实参可以是key&#x3D;value的形式，称为关键字参数。</p>
<p>凡是按照这种形式定义的实参，可以不按照从左到右的顺序定义，但仍能为指定的形参赋值。</p>
<ul>
<li><p><strong>关键字参数在位置参数后面</strong>，因为python函数在解析参数时，是按照顺序来的，<strong>位置参数</strong>是必须先满足，才考虑其他可变参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params">age, name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;名字: &quot;</span>, name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;年龄: &quot;</span>, age)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  </span><br><span class="line">printinfo(<span class="number">50</span>, name=<span class="string">&quot;runoob&quot;</span>) <span class="comment">#age为位置参数，name为关键字参数</span></span><br></pre></td></tr></table></figure>

<p>需要注意：</p>
<ul>
<li><strong>位置参数的输入必须和定义时的位置相同</strong></li>
<li><strong>关键字参数的输入必须在位置参数之后</strong></li>
</ul>
</li>
</ul>
<h3 id="当参数不定长时"><a href="#当参数不定长时" class="headerlink" title="当参数不定长时"></a>当参数不定长时</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> arg1, *vartuple </span>):</span><br></pre></td></tr></table></figure>

<p>加了星号 ***** 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数</p>
<p>当参数添加双星号******时，传入的参数将以字典的形式保存</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">**dic</span>)</span><br><span class="line">	<span class="built_in">print</span>(dic)</span><br><span class="line">func(**&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment">#or</span></span><br><span class="line">func(a=<span class="number">1</span>,b=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>Python 使用 <strong>lambda</strong> 来创建匿名函数</p>
<ul>
<li>lambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="built_in">sum</span> = <span class="keyword">lambda</span> arg1, arg2: arg1 + arg2</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用sum函数</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;相加后的值为 : &quot;</span>, <span class="built_in">sum</span>( <span class="number">10</span>, <span class="number">20</span> ))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;相加后的值为 : &quot;</span>, <span class="built_in">sum</span>( <span class="number">20</span>, <span class="number">20</span> ))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">30</span></span><br><span class="line"><span class="string">40</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="强制位置参数＆命名关键字参数"><a href="#强制位置参数＆命名关键字参数" class="headerlink" title="强制位置参数＆命名关键字参数"></a>强制位置参数＆命名关键字参数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a, b, c成为限定位置形参</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b, c, /, d</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#这时参数kw1, kw2必须传入关键字参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">其他形参, *, kw1, kw2</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="6、类"><a href="#6、类" class="headerlink" title="6、类"></a>6、类</h2><p>Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。</p>
<p>定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    i = <span class="number">12345</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):<span class="comment">#类中的函数称作类的方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br></pre></td></tr></table></figure>

<p>类的初始化（构造方法）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>:</span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n, a</span>): <span class="comment">#类的方法必须包含self，且其必须为第一个参数</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br></pre></td></tr></table></figure>

<p>创建一个类的实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = MyClass()</span><br></pre></td></tr></table></figure>

<p>访问类的属性、方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;MyClass 类的属性 i 为：&quot;</span>, x.i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;MyClass 类的方法 f 输出为：&quot;</span>, x.f())</span><br></pre></td></tr></table></figure>

<h4 id="类的继承："><a href="#类的继承：" class="headerlink" title="类的继承："></a>类的继承：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span>:</span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,a,w</span>):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>(<span class="title class_ inherited__">people</span>):</span><br><span class="line">    grade = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,a,w,g</span>):</span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(self.name,self.age,self.grade))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">s = student(<span class="string">&#x27;ken&#x27;</span>,<span class="number">10</span>,<span class="number">60</span>,<span class="number">3</span>)</span><br><span class="line">s.speak()</span><br></pre></td></tr></table></figure>

<ul>
<li>子类中若出现了父类同名的方法，则在调用该子类方法时使用的内容也是子类中定义的内容</li>
</ul>
<p>私有属性与方法：</p>
<p>在方法或属性的开头加两个下划线，<strong>声明</strong>（不包含在变量名中）该属性为私有，不能在类的外部被使用或直接访问</p>
<h1 id="文件间的引用"><a href="#文件间的引用" class="headerlink" title="文件间的引用"></a>文件间的引用</h1><h2 id="1、import语句"><a href="#1、import语句" class="headerlink" title="1、import语句"></a>1、import语句</h2><p>想使用一个 Python 源文件，只需在另一个源文件里执行 import 语句导入该模块</p>
<ul>
<li>一个模块只会被导入一次，不管你执行了多少次 <strong>import</strong>。这样可以防止导入模块被一遍又一遍地执行。</li>
</ul>
<h2 id="2、from-import语句"><a href="#2、from-import语句" class="headerlink" title="2、from..import语句"></a>2、from..import语句</h2><p>从模块中导入指定的部分，例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> test_file <span class="keyword">import</span> test_fuction1,test_fuction2</span><br><span class="line"><span class="comment">#从test_file.py中导入两个函数</span></span><br></pre></td></tr></table></figure>

<h2 id="3、使用模块中的变量、函数"><a href="#3、使用模块中的变量、函数" class="headerlink" title="3、使用模块中的变量、函数"></a>3、使用模块中的变量、函数</h2><p>通过 modname.itemname 这样的表示法来访问模块内的函数</p>
]]></content>
      <tags>
        <tag>python学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C++字符串、向量和数组</title>
    <url>/2022/09/15/C++-3/</url>
    <content><![CDATA[<h1 id="字符串、向量和数组"><a href="#字符串、向量和数组" class="headerlink" title="字符串、向量和数组"></a>字符串、向量和数组</h1><h2 id="1、using声明"><a href="#1、using声明" class="headerlink" title="1、using声明"></a>1、using声明</h2><p>作用：使用using声明命名空间的相关成员后，后续不需再声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">cin&gt;&gt;i;</span><br></pre></td></tr></table></figure>

<ul>
<li>每个名字都需要独立的using声明</li>
</ul>
<h2 id="2、string类型"><a href="#2、string类型" class="headerlink" title="2、string类型"></a>2、string类型</h2><ul>
<li>使用前需包含头文件<code>&lt;string&gt;</code>(没有.h)，且需声明string定义于命名空间中</li>
</ul>
<h3 id="初始化string类型的方法"><a href="#初始化string类型的方法" class="headerlink" title="初始化string类型的方法"></a>初始化string类型的方法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1;</span><br><span class="line">string s2=s1;</span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(<span class="string">&quot;value&quot;</span>)</span></span>;</span><br><span class="line">string s3 =<span class="string">&quot;value&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(n,<span class="string">&#x27;c&#x27;</span>)</span></span>;<span class="comment">//此处只能为字符</span></span><br></pre></td></tr></table></figure>

<h3 id="读写string对象"><a href="#读写string对象" class="headerlink" title="读写string对象"></a>读写string对象</h3><p>当要将标准输入内容读取到一个string对象时，string对象会自动忽略开头的空白（空格、换行等），从第一个真正的字符开始，直到遇到遇到下一个空白（但读取结束的标准是换行）</p>
<h3 id="使用getline函数读取一整行"><a href="#使用getline函数读取一整行" class="headerlink" title="使用getline函数读取一整行"></a>使用getline函数读取一整行</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(cin,s);</span><br></pre></td></tr></table></figure>

<p>getline只有当读取到换行符时才会结束，并且这个换行符会被丢弃。</p>
<h3 id="相加问题"><a href="#相加问题" class="headerlink" title="相加问题"></a>相加问题</h3><p>string对象可以相加，string对象也可以与字面值相加，<strong>但字面值不能与字面值相加！</strong></p>
<h3 id="单独处理字符"><a href="#单独处理字符" class="headerlink" title="单独处理字符"></a>单独处理字符</h3><p>C++11提供了一种语句：范围for</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string <span class="built_in">str</span>(<span class="string">&quot;something&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(auto c:<span class="built_in">str</span>)	cout&lt;&lt;c&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<ul>
<li>每次循环中，都会把序列中的<strong>基础元素</strong>存入c中</li>
</ul>
<p>还可以通过引用等方式单独改变字符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;something&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:str)	c=<span class="built_in">toupper</span>(c);<span class="comment">//大写转换函数</span></span><br></pre></td></tr></table></figure>

<h3 id="下标问题"><a href="#下标问题" class="headerlink" title="下标问题"></a>下标问题</h3><p>C++支持对字符串使用下标运算符<code>[]</code>访问字符串的单个字符，规则同python，但貌似C++不支持截取。</p>
<h2 id="3、vector类型"><a href="#3、vector类型" class="headerlink" title="3、vector类型"></a>3、vector类型</h2><p>要想使用vector，需包含<code>&lt;vector&gt;</code>头文件。<strong>类型vector表示对象的集合</strong></p>
<p>与python中的class意义类似。</p>
<p>实例化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; b;</span><br></pre></td></tr></table></figure>

<h3 id="定义与初始化"><a href="#定义与初始化" class="headerlink" title="定义与初始化"></a>定义与初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(b)</span></span>; <span class="comment">//a包含b中所有元素的副本 a和b的类型需相同</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a=b;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n,val)</span></span>; <span class="comment">//a中有n个重复的val</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>; <span class="comment">//包含n个对象</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a&#123;A,B,C&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a=&#123;A,B,C&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="向vector对象尾部添加元素"><a href="#向vector对象尾部添加元素" class="headerlink" title="向vector对象尾部添加元素"></a>向vector对象尾部添加元素</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">a.<span class="built_in">push_back</span>(<span class="number">1</span>);<span class="comment">//a=&#123;1&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a.<span class="built_in">empty</span>(); <span class="comment">//如果a不含元素则返回真</span></span><br><span class="line">a.<span class="built_in">size</span>(); <span class="comment">//返回元素个数</span></span><br></pre></td></tr></table></figure>

<p>其他的类函数参考书p91</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>vector对象同样支持使用下标运算符进行单个元素的索引，但不能通过下标添加元素。</p>
<h2 id="4、迭代器"><a href="#4、迭代器" class="headerlink" title="4、迭代器"></a>4、迭代器</h2><p>迭代器（iterator）是一种可以遍历容器元素的数据类型。迭代器是一个变量，相当于容器和操纵容器的算法之间的中介。<strong>C++更趋向于使用迭代器而不是数组下标操作</strong>，因为标准库为每一种标准容器（如vector、map和list等）定义了一种迭代器类型，而只有少数容器（如vector）支持数组下标操作访问容器元素。可以通过迭代器指向你想访问容器的元素地址，通过*x打印出元素值。这和我们所熟知的指针极其类似。</p>
<p>C语言有指针，指针用起来十分灵活高效。<br>C++语言有迭代器，迭代器相对于指针而言功能更为丰富。</p>
<h3 id="迭代器的使用"><a href="#迭代器的使用" class="headerlink" title="迭代器的使用"></a>迭代器的使用</h3><p>可以看出，迭代器的基本使用和指针极其相似</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;string&gt; v&#123;<span class="string">&quot;aaaa&quot;</span>,<span class="string">&quot;bbbb&quot;</span>&#125;;</span><br><span class="line">	<span class="keyword">auto</span> i=v.<span class="built_in">begin</span>();</span><br><span class="line">	cout&lt;&lt;*(i+<span class="number">1</span>); <span class="comment">//bbbb</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器运算符"><a href="#迭代器运算符" class="headerlink" title="迭代器运算符"></a>迭代器运算符</h3><ul>
<li><p>获得迭代器所指元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*iter  <span class="keyword">or</span>  iter-&gt;mem</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取迭代器长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">i.<span class="built_in">end</span>()-i.<span class="built_in">begin</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; v&#123;<span class="string">&quot;aaaa&quot;</span>,<span class="string">&quot;bbbb&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> i=v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//vector&lt;string&gt;::iterator i; 类型</span></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;12345&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> i=str.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//string::iterator i; 类型</span></span><br><span class="line"></span><br><span class="line">对应的只读类型</span><br><span class="line"><span class="comment">//vector&lt;string&gt;::const_iterator v;</span></span><br><span class="line"><span class="comment">//string::const_iterator str;</span></span><br></pre></td></tr></table></figure>

<h3 id="当需要对迭代器进行遍历时，需注意for循环的条件3："><a href="#当需要对迭代器进行遍历时，需注意for循环的条件3：" class="headerlink" title="当需要对迭代器进行遍历时，需注意for循环的条件3："></a>当需要对迭代器进行遍历时，需注意for循环的条件3：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> i=v.<span class="built_in">begin</span>(); i !=v.<span class="built_in">end</span>(); ++i)<span class="comment">//应使用++i，这是因为end为元素10之后的位置	</span></span><br><span class="line">	&#123;</span><br><span class="line">		*i=*i*<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> a:v) cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、数组"><a href="#5、数组" class="headerlink" title="5、数组"></a>5、数组</h2><p>大部分规定与C相同。</p>
<ul>
<li><p>定义数组时不允许用auto关键字由初始值推断类型。</p>
</li>
<li><p>可使用decltype(数组名)定义数组类型。</p>
</li>
<li><p><strong>数组不是类类型，因此没有成员函数。</strong></p>
<p>因此C++11引入了begin、end函数来查询数组相关元素的<strong>地址</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p=<span class="built_in">begin</span>(a);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意：end()和vector类型的子函数.end()不同，end()函数返回的是数组最后一个元素的地址，而vector类型的end子函数返回的是最后一个元素的后一位地址</p>
<h3 id="单个元素类型"><a href="#单个元素类型" class="headerlink" title="单个元素类型"></a>单个元素类型</h3><p>通常对数组的单个类型定义为size_t型，该类型为一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小</p>
<p><strong>要使用该类型，应包含cstddef头文件</strong></p>
<h3 id="C与C-的字符串风格"><a href="#C与C-的字符串风格" class="headerlink" title="C与C++的字符串风格"></a>C与C++的字符串风格</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">10</span>]=<span class="string">&quot;dhk&quot;</span>; <span class="comment">//C风格</span></span><br><span class="line"><span class="function">string <span class="title">a</span><span class="params">(<span class="string">&quot;dhk&quot;</span>)</span></span>;	<span class="comment">//C++风格</span></span><br></pre></td></tr></table></figure>

<p>在C中，通常我们要对字符串进行一些例如比较、拷贝、连接等的操作时，通常使用的是标准库中的相关字符串长度，相较于C++中string类型的变量可以对存放字符串的变量直接进行运算等操作，C的字符串风格更加繁琐，且极容易在数组的内存方面引发严重问题</p>
<h4 id="混用规则："><a href="#混用规则：" class="headerlink" title="混用规则："></a>混用规则：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">a</span><span class="params">(<span class="string">&quot;dhk&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">char</span> *str=a;<span class="comment">//错误，a的类型为string，而str类型为char*，冲突</span></span><br><span class="line"><span class="type">char</span> *str=a.<span class="built_in">c_str</span>();<span class="comment">//正确。c_str()函数返回的是C风格字符串（一个地址）</span></span><br></pre></td></tr></table></figure>

<p>上述用法相当于是<strong>又</strong>在内存中创建了一个”dhk”字符串，而用于找到该字符串的指针一旦改变，该字符串就将不能再被找到，因此通常对存放该类型的指针进行const操作。其规则类似C中的<code>char *str=&quot;dhk&quot;</code>所遵循的规则。</p>
<h3 id="使用数组初始化vector类型"><a href="#使用数组初始化vector类型" class="headerlink" title="使用数组初始化vector类型"></a>使用数组初始化vector类型</h3><p>C++不允许用一个数组为另一个数组赋初值，也不允许通过vector类型对象为一个数组初始化，但是允许通过数组为vector对象初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(begin(a),end(a))</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="6、多维数组"><a href="#6、多维数组" class="headerlink" title="6、多维数组"></a>6、多维数组</h2><p>一些基础内容同C，详见<u>二维数组复习 | 小董的BLOG (gitee.io)</u></p>
<p>多维数组可以理解为数组的数组例如<code>int a[3][4]</code>可以理解为a数组包含三个元素，而这三个元素都为大小为4的数组</p>
<h3 id="下标引用"><a href="#下标引用" class="headerlink" title="下标引用"></a>下标引用</h3><h3 id="使用范围for语句和下标引用处理多维数组"><a href="#使用范围for语句和下标引用处理多维数组" class="headerlink" title="使用范围for语句和下标引用处理多维数组"></a>使用范围for语句和下标引用处理多维数组</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">size_t</span> x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;row : a)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;col : row)</span><br><span class="line">	&#123;</span><br><span class="line">		col=x;</span><br><span class="line">		x++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++学习</tag>
      </tags>
  </entry>
  <entry>
    <title>python_1</title>
    <url>/2022/09/14/python-1/</url>
    <content><![CDATA[<h1 id="1、基本数据类型"><a href="#1、基本数据类型" class="headerlink" title="1、基本数据类型"></a>1、基本数据类型</h1><ul>
<li>变量不需要声明，也没有类型。</li>
<li>python允许同时给多个变量赋值</li>
</ul>
<h2 id="标准数据类型："><a href="#标准数据类型：" class="headerlink" title="标准数据类型："></a>标准数据类型：</h2><ul>
<li>Number</li>
<li>String</li>
<li>List</li>
<li>Tuple（元组）</li>
<li>Set（集合）</li>
<li>Dictionary（字典）</li>
</ul>
<h3 id="1、Number（数字）"><a href="#1、Number（数字）" class="headerlink" title="1、Number（数字）"></a>1、Number（数字）</h3><p>Python3 支持 int、float、bool、<strong>complex（复数）</strong>。</p>
<ul>
<li>可使用type(<em>变量</em> )函数查询变量类型</li>
<li>可用isinstance(<em>变量，类型</em> )判断变量是否为想要的类型，为真返回Ture</li>
</ul>
<p>del 语句可用删除对对象的引用</p>
<p>在数值的计算中，<code>/</code>返回浮点数，<code>//</code>返回整数，在混合计算时会把整数转化为浮点数</p>
<ul>
<li><code>//</code>返回的不一定是整型的数，这与分母分子的类型有关</li>
</ul>
<p>python可以使用<code>**</code>来进行幂运算，如5的平方：<code>5**2</code></p>
<ul>
<li><strong>number为不可变类型，</strong>例如变量赋值 <strong>a&#x3D;5</strong> 后再赋值 <strong>a&#x3D;10</strong>，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a</li>
</ul>
<h3 id="2、String（字符串）"><a href="#2、String（字符串）" class="headerlink" title="2、String（字符串）"></a>2、String（字符串）</h3><p>python中的字符串可用单引号或双引号括起来</p>
<p>字符串的截取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#变量[头下标:尾下标:截取步长]</span></span><br><span class="line"><span class="comment">#若截取步长为负数则逆向读取</span></span><br><span class="line"><span class="comment">#第一个字符索引值为0，末尾字符为-1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;dhk&quot;</span>*<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;dhk&quot;</span>+<span class="string">&quot;dhk&quot;</span>)</span><br><span class="line"><span class="comment">#dhkdhk</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字符串的截取遵循<strong>左闭右开</strong>的原则</li>
<li>字符索引：变量[索引下标]</li>
<li>屏蔽转义字符：在字符串前（引号外）添加一个r</li>
<li><strong>python字符串不能被改变，也就是说不能给单个索引位置赋值</strong></li>
</ul>
<p>字符串的格式化：<code>print(&quot;%s %d&quot; % (&#39;abc&#39;, 10))</code></p>
<h4 id="f-string"><a href="#f-string" class="headerlink" title="f-string"></a>f-string</h4><p> 格式化字符串以 <strong>f</strong> 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">&#x27;Runoob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;Hello <span class="subst">&#123;name&#125;</span>&#x27;</span>  <span class="comment"># 替换变量</span></span><br><span class="line"><span class="string">&#x27;Hello Runoob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;<span class="subst">&#123;<span class="number">1</span>+<span class="number">2</span>&#125;</span>&#x27;</span>         <span class="comment"># 使用表达式</span></span><br><span class="line"><span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;<span class="subst">&#123;w[<span class="string">&quot;name&quot;</span>]&#125;</span>: <span class="subst">&#123;w[<span class="string">&quot;url&quot;</span>]&#125;</span>&#x27;</span></span><br><span class="line"><span class="string">&#x27;Runoob: www.runoob.com&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="3、List（列表）"><a href="#3、List（列表）" class="headerlink" title="3、List（列表）"></a>3、List（列表）</h3><p>定义方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">10.1</span>,<span class="string">&#x27;abcd&#x27;</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>基本使用同字符串，也可以索引、截取，使用步长截取（包括逆向）等。</li>
<li><strong>列表内的元素可改变！</strong></li>
<li>逆向读取不会将元素内容逆向</li>
</ul>
<h4 id="更新列表："><a href="#更新列表：" class="headerlink" title="更新列表："></a>更新列表：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br><span class="line">list1.append(<span class="string">&#x27;Baidu&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;更新后的列表 : &quot;</span>, list1)	<span class="comment">#更新后的列表 :  [&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;, &#x27;Baidu&#x27;]</span></span><br></pre></td></tr></table></figure>

<h4 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> <span class="built_in">list</span>[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h3 id="4、Tuple（元组）"><a href="#4、Tuple（元组）" class="headerlink" title="4、Tuple（元组）"></a>4、Tuple（元组）</h3><p>定义方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=(<span class="number">1</span>,<span class="number">10.1</span>,<span class="string">&#x27;abcd&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>基本使用同字符串，也可以索引、截取，使用步长截取（包括逆向）等。</p>
</li>
<li><p>元组在输入时可能没有括号，例如<code>t = 12345, 54321, &#39;hello!&#39;</code></p>
</li>
<li><p><strong>元组内元素不可改变，但可以包含可变的对象，比如列表</strong></p>
</li>
<li><p>包含0和1个的元组有额外的语法规则：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = ()    <span class="comment"># 空元组</span></span><br><span class="line">tup2 = (<span class="number">20</span>,) <span class="comment"># 一个元素，需要在元素后添加逗号,否则括号会被当作运算符使用</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5、Set（集合）"><a href="#5、Set（集合）" class="headerlink" title="5、Set（集合）"></a>5、Set（集合）</h3><p>定义方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=() <span class="comment">#空集合需用小括号</span></span><br><span class="line">b=&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">c=<span class="built_in">set</span>(<span class="string">&#x27;abcde&#x27;</span>) <span class="comment">#使用set函数</span></span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li><p><strong>输出时会自动去掉重复的元素（从第二次重复的元素开始删除）</strong></p>
</li>
<li><p>可以进行集合运算</p>
</li>
<li><p><strong>不可像前面几个类型一样进行索引</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(a-b) <span class="comment">#将a中与b相同的元素去掉后输出a</span></span><br><span class="line"><span class="built_in">print</span>(a|b) <span class="comment"># 并集</span></span><br><span class="line"><span class="built_in">print</span>(a&amp;b) <span class="comment">#交集</span></span><br><span class="line"><span class="built_in">print</span>(a^b) <span class="comment">#非交集</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6、Dictionary（字典）"><a href="#6、Dictionary（字典）" class="headerlink" title="6、Dictionary（字典）"></a>6、Dictionary（字典）</h3><p>字典是一种映射类型，它是一个无序的 <strong>键(key) : 值(value)</strong> 的集合。</p>
<p>定义方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;a&#x27;</span> : <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span> :<span class="number">3</span>&#125;  <span class="comment">#&#x27;:&#x27;前为“键”，后为“值”</span></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line">a= &#123;&#125;</span><br><span class="line">a[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span></span><br><span class="line">a[<span class="string">&#x27;b&#x27;</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment">#&#123;&#x27;a&#x27;: &#x27;abcd&#x27;, &#x27;b&#x27;: &#x27;123&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(a.keys()) <span class="comment">#dict_keys([&#x27;a&#x27;, &#x27;b&#x27;])</span></span><br><span class="line"><span class="built_in">print</span>(a.values()) <span class="comment">#dict_values([&#x27;abcd&#x27;, &#x27;123&#x27;])</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&#x27;b&#x27;</span>])	<span class="comment">#2    访问字典里的值</span></span><br></pre></td></tr></table></figure>

<p>键的特性：</p>
<ul>
<li>同一个键出现两次时只有后一个值会被记住</li>
<li>键必须是不可变的，因此可以是数字、字符串、元组，而不能是列表等可以改变的变量</li>
</ul>
<p>同时遍历多个序列和用单个字典表示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">questions = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;lancelot&#x27;</span>, <span class="string">&#x27;quest&#x27;</span>:<span class="string">&#x27;the holy grail&#x27;</span>, <span class="string">&#x27;favorite color&#x27;</span>:<span class="string">&#x27;blue&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> q, a <span class="keyword">in</span> questions.items():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">f&#x27;What is your <span class="subst">&#123;q&#125;</span>?  It is <span class="subst">&#123;a&#125;</span>.&#x27;</span>)</span><br><span class="line"><span class="comment">###############################or#########################################</span></span><br><span class="line">questions = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;quest&#x27;</span>, <span class="string">&#x27;favorite color&#x27;</span>]</span><br><span class="line">answers = [<span class="string">&#x27;lancelot&#x27;</span>, <span class="string">&#x27;the holy grail&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> q, a <span class="keyword">in</span> <span class="built_in">zip</span>(questions, answers): <span class="comment">#索引多个序列</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">f&#x27;What is your <span class="subst">&#123;q&#125;</span>?  It is <span class="subst">&#123;a&#125;</span>.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">What is your name?  It is lancelot.</span></span><br><span class="line"><span class="string">What is your quest?  It is the holy grail.</span></span><br><span class="line"><span class="string">What is your favorite color?  It is blue.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="综上"><a href="#综上" class="headerlink" title="综上"></a>综上</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">10.1</span>,<span class="string">&#x27;abcd&#x27;</span>]  <span class="comment">#列表</span></span><br><span class="line">a=(<span class="number">1</span>,<span class="number">10.1</span>,<span class="string">&#x27;abcd&#x27;</span>)	<span class="comment">#元组</span></span><br><span class="line">a=&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;	<span class="comment">#集合</span></span><br><span class="line">a = &#123;<span class="string">&#x27;a&#x27;</span> : <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span> :<span class="number">3</span>&#125; <span class="comment">#字典</span></span><br></pre></td></tr></table></figure>

<h1 id="2、推导式"><a href="#2、推导式" class="headerlink" title="2、推导式"></a>2、推导式</h1><p>Python 推导式是一种独特的数据处理方式，<strong>可以从一个数据序列构建另一个新的数据序列的结构体</strong>。</p>
<p>Python 支持各种数据结构的推导式：</p>
<ul>
<li>列表(list)推导式</li>
<li>字典(dict)推导式</li>
<li>集合(set)推导式</li>
<li>元组(tuple)推导式</li>
</ul>
<h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><p>格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表 <span class="keyword">if</span> 条件]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>表达式：新构建的列表的元素，可以是有返回值的函数</p>
</li>
<li><p>变量＆列表：我的理解是定义一个新变量，通过这个新变量将现有列表元素传入<strong>表达式</strong>中</p>
</li>
<li><p>条件：对变量进行筛选</p>
</li>
</ul>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">b = [i/<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="comment">#定义变量i，i来自列表a中的可以整除2的元素，最后返回i/2的值作为新列表b的元素</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment">#[1.0, 2.0, 3.0, 4.0, 5.0]</span></span><br></pre></td></tr></table></figure>

<p>同时定义多个变量存放值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vec1 = [2, 4, 6]</span><br><span class="line">vec2 = [4, 3, -9]</span><br><span class="line">[x*y for x in vec1 for y in vec2] </span><br><span class="line">[x+y for x in vec1 for y in vec2]</span><br><span class="line">[vec1[i]*vec2[i] for i in range(len(vec1))]</span><br></pre></td></tr></table></figure>

<p>在矩阵列表中使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = [[1, 2, 3], [4, 5, 6]]</span><br><span class="line">b = [row[0] for row in a]</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>

<h2 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h2><p>格式与列表推导式几乎相同，只是将表达式换成了<code>key:value</code>的格式，具体见下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>] <span class="comment"># 传入推导式的为一个列表</span></span><br><span class="line">b = &#123;k: <span class="built_in">chr</span>(k) <span class="keyword">for</span> k <span class="keyword">in</span> a.keys()&#125;</span><br><span class="line"><span class="built_in">print</span>(b)	<span class="comment">#&#123;97: &#x27;a&#x27;, 98: &#x27;b&#x27;, 99: &#x27;c&#x27;, 100: &#x27;d&#x27;, 101: &#x27;e&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">97</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">98</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">99</span>: <span class="string">&#x27;c&#x27;</span>, <span class="number">100</span>: <span class="string">&#x27;d&#x27;</span>, <span class="number">101</span>: <span class="string">&#x27;e&#x27;</span>&#125;<span class="comment"># 传入推导式的为一个字典</span></span><br><span class="line">b = &#123;k: <span class="built_in">chr</span>(k) <span class="keyword">for</span> k <span class="keyword">in</span> a.keys()&#125;</span><br><span class="line"><span class="built_in">print</span>(b)	<span class="comment">#&#123;97: &#x27;a&#x27;, 98: &#x27;b&#x27;, 99: &#x27;c&#x27;, 100: &#x27;d&#x27;, 101: &#x27;e&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>但如果如下操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">97</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">98</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">99</span>: <span class="string">&#x27;c&#x27;</span>, <span class="number">100</span>: <span class="string">&#x27;d&#x27;</span>, <span class="number">101</span>: <span class="string">&#x27;e&#x27;</span>&#125;</span><br><span class="line">b = &#123;k: i <span class="keyword">for</span> i <span class="keyword">in</span> a.values() <span class="keyword">for</span> k <span class="keyword">in</span> a.keys()&#125;</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment">#&#123;97: &#x27;e&#x27;, 98: &#x27;e&#x27;, 99: &#x27;e&#x27;, 100: &#x27;e&#x27;, 101: &#x27;e&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>目前还不知道原因。</p>
<h2 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h2><p>规则格式与列表推导式相同</p>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;abracadabra&#x27;</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>&#125; <span class="comment">#判断不是abc的字母</span></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment">#&#123;&#x27;d&#x27;, &#x27;r&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a)) <span class="comment">#&lt;class &#x27;set&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="元组推导式（生成器表达式）"><a href="#元组推导式（生成器表达式）" class="headerlink" title="元组推导式（生成器表达式）"></a>元组推导式（生成器表达式）</h2><p>元组推导式和列表推导式的用法也完全相同，但元组推导式返回的结果是一个生成器对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x7faf6ee20a50</span>&gt;  <span class="comment"># 返回的是生成器对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">tuple</span>(a)       <span class="comment"># 使用 tuple() 函数，可以直接将生成器对象转换成元组</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure>

<h1 id="3、运算符"><a href="#3、运算符" class="headerlink" title="3、运算符"></a>3、运算符</h1><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><ul>
<li><p><code>:=</code>   海象运算符，在表达式内部为变量赋值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (n := <span class="built_in">len</span>(a)) &gt; <span class="number">10</span>  <span class="comment">#可以避免调用两次len函数</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="python逻辑运算符"><a href="#python逻辑运算符" class="headerlink" title="python逻辑运算符"></a>python逻辑运算符</h2><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">表达式</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">and</td>
<td align="center">x and y</td>
<td align="center">x为<strong>假</strong>则返回x，x为<strong>真</strong>则返回y</td>
</tr>
<tr>
<td align="center">or</td>
<td align="center">a or y</td>
<td align="center">x为<strong>真</strong>则返回x，x为<strong>假</strong>则返回y</td>
</tr>
<tr>
<td align="center">not</td>
<td align="center">not x</td>
<td align="center">x为真返回假，为假返回真</td>
</tr>
</tbody></table>
<h2 id="python成员运算符"><a href="#python成员运算符" class="headerlink" title="python成员运算符"></a>python成员运算符</h2><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">表达式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">in</td>
<td align="center">x in list</td>
</tr>
<tr>
<td align="center">not in</td>
<td align="center">x not in list</td>
</tr>
</tbody></table>
<h2 id="python身份运算符"><a href="#python身份运算符" class="headerlink" title="python身份运算符"></a>python身份运算符</h2><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">表达式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">is</td>
<td align="center">a is b</td>
</tr>
<tr>
<td align="center">is not</td>
<td align="center">a is not b</td>
</tr>
</tbody></table>
<h1 id="4、其他"><a href="#4、其他" class="headerlink" title="4、其他"></a>4、其他</h1><ul>
<li><p>end关键字，用于将结果输出到同一行，同时将end&#x3D;的内容添加在每次输出的末尾</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> b&lt;<span class="number">10</span>：</span><br><span class="line">	<span class="built_in">print</span>(b,end=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">	b+=<span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>python学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C++变量和基本类型</title>
    <url>/2022/09/09/C++-2/</url>
    <content><![CDATA[<h1 id="第二章——变量和基本类型"><a href="#第二章——变量和基本类型" class="headerlink" title="第二章——变量和基本类型"></a>第二章——变量和基本类型</h1><h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>C++这个板块是我在学习了C之后才学的，因此我只会记录一些重要的或者在C中没有的东西</p>
<p><em>C++板块是基于C++primer的方案学习的</em></p>
<h2 id="1、基本内置类型"><a href="#1、基本内置类型" class="headerlink" title="1、基本内置类型"></a>1、基本内置类型</h2><ul>
<li><p>bool类型取值只为真（1）和假（0）</p>
</li>
<li><p>当一个算术表达式中既有无符号数（unsigned）又有int型时，int型的值会转换成无符号数。且值大于0时会正常显示，小于零时会异常显示（当int为4字节时，值为2^32 + 计算结果（负数））也就是4294967295加上</p>
<p>(-n)。</p>
</li>
</ul>
<h3 id="指定字面值类型："><a href="#指定字面值类型：" class="headerlink" title="指定字面值类型："></a>指定字面值类型：</h3><ul>
<li>字符和字符串字面值</li>
</ul>
<table>
<thead>
<tr>
<th align="center">前缀</th>
<th align="center">含义</th>
<th align="center">代表类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u</td>
<td align="center">Unicode16字符</td>
<td align="center">char16_t</td>
</tr>
<tr>
<td align="center">U</td>
<td align="center">Unicode32字符</td>
<td align="center">char32_t</td>
</tr>
<tr>
<td align="center">L</td>
<td align="center">宽字符（2字节）</td>
<td align="center">wchar_t</td>
</tr>
<tr>
<td align="center">u8</td>
<td align="center">Unicode8字符</td>
<td align="center">char</td>
</tr>
</tbody></table>
<ul>
<li>整型字面值</li>
</ul>
<table>
<thead>
<tr>
<th align="center">后缀</th>
<th align="center">最小匹配类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u or U</td>
<td align="center">unsigned</td>
</tr>
<tr>
<td align="center">l or L</td>
<td align="center">long</td>
</tr>
<tr>
<td align="center">ll or LL</td>
<td align="center">long long</td>
</tr>
</tbody></table>
<ul>
<li>浮点型</li>
</ul>
<table>
<thead>
<tr>
<th align="center">后缀</th>
<th align="center">代表的类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">f or F</td>
<td align="center">float</td>
</tr>
<tr>
<td align="center">l or L</td>
<td align="center">long double</td>
</tr>
</tbody></table>
<h2 id="2、变量"><a href="#2、变量" class="headerlink" title="2、变量"></a>2、变量</h2><ul>
<li><p>一种初始化字符串的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">a</span><span class="params">(<span class="string">&quot;test&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>字符串变量名a，内容为test</p>
</li>
</ul>
<h2 id="3、对象"><a href="#3、对象" class="headerlink" title="3、对象"></a>3、对象</h2><p>通常情况下，对象是指<strong>一块能存储数据并具有某种类型的内存空间</strong></p>
<h3 id="关于初始化的问题"><a href="#关于初始化的问题" class="headerlink" title="关于初始化的问题"></a>关于初始化的问题</h3><p>在学C的时候我自己也是一直把初始化理解成赋值，但是也一直感觉怪怪的，特别是对于指针变量的初始化，感觉明显是不符合“赋值”这一操作的，今天在阅读书籍时书中也指出了初始化≠赋值，但是具体的区别目前我也不能讲的很明白，学到后面如果搞懂了再说吧。</p>
<ul>
<li>定义在函数体内部的变量将不被初始化。</li>
</ul>
<h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3><p>用花括号来初始化变量，在C++中以下四种初始化都是正确的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a =<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> a =&#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> a&#123;<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4、标识符"><a href="#4、标识符" class="headerlink" title="4、标识符"></a>4、标识符</h2><p>虽然感觉很怪异，但是<code>int _=1;</code>是合法的。</p>
<h2 id="5、复合类型变量"><a href="#5、复合类型变量" class="headerlink" title="5、复合类型变量"></a>5、复合类型变量</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>为对象起另外一个名字，<strong>同时引用必须被初始化。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> &amp;b=a;</span><br><span class="line">b=<span class="number">2</span>;<span class="comment">//等同于 a=2;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>引用并非对象，可以只是理解为一个已存在变量的别名。</li>
<li>一旦使用引用，引用对象将和引用的初始化变量绑定，无法更改，因此引用必须初始化。</li>
<li><strong>引用只能绑定在对象上，而不能与某个字面值或某个计算结果绑定</strong>。</li>
</ul>
<p><strong>指向指针的引用：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> *&amp;r=p; <span class="comment">//注意这里是*&amp;r</span></span><br><span class="line">r=&amp;i;</span><br><span class="line">*r=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>规则与C基本一样，不再赘述。</p>
<h2 id="6、const-限定符"><a href="#6、const-限定符" class="headerlink" title="6、const 限定符"></a>6、const 限定符</h2><ul>
<li><p>作用：定义一个变量后，它的值不能再被改变</p>
<p>因此，const的对象必须初始化。</p>
</li>
<li><p>当多个文件出现了同名的const变量时，视作分别定义了独立的变量，也就是说默认情况下const对象只在本文件内有效。（当然也可以使用extern关键字，具体可见<a href="https://dhkkk.gitee.io/2022/08/03/C-%E5%85%B3%E9%94%AE%E5%AD%97/">一些关键字 | 小董的BLOG (gitee.io)</a>）</p>
<p><strong>对于使用extern，如果要在多个文件之间共享const对象，则在定义该对象时也必须添加extern</strong></p>
</li>
</ul>
<h3 id="对const对象的引用"><a href="#对const对象的引用" class="headerlink" title="对const对象的引用"></a>对const对象的引用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b1=a;<span class="comment">//对</span></span><br><span class="line"><span class="type">int</span> &amp;b2=a;<span class="comment">//错，引用的类型必须与引用对象类型一致</span></span><br></pre></td></tr></table></figure>

<p>假设第三行操作合法，则可以通过b2改变a的值，这显然是不正确的</p>
<ul>
<li><p>若初始化引用的对象为表达式，<strong>只要该表达式的结果能转化成引用的类型即可</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b=a;</span><br><span class="line"><span class="comment">//允许将const int型引用绑定到普通的int对象上（其他普通变量也可以视情况转化）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因此，可以有以下操作</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b1=a;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b2=a;</span><br><span class="line"><span class="comment">//可以通过b1改变a的值，但不允许通过b2改变a的值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="指向const对象的指针和const指针"><a href="#指向const对象的指针和const指针" class="headerlink" title="指向const对象的指针和const指针"></a>指向const对象的指针和const指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指向const对象的指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> *p=&amp;a;</span><br><span class="line">*p=b; <span class="comment">//错误，不可修改p指向的对象的值</span></span><br><span class="line">p=&amp;b; <span class="comment">//合法，并没有更改a的值，只是更改了一般指针p的值</span></span><br></pre></td></tr></table></figure>

<p>说明一下，上述中的<code>int *p=&amp;a;</code>也可以改为<code>const int *p=&amp;a;</code><strong>且二者完全一致</strong>，原因与后文中的顶&#x2F;底层const有关</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//const指针</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p=&amp;a;</span><br><span class="line">p=&amp;b; <span class="comment">//错误，const指针一旦初始化便会一直指向初始化时的对象</span></span><br><span class="line">*p=b; <span class="comment">//正确，因为指针指向的值为普通int型，可以改变</span></span><br></pre></td></tr></table></figure>

<p>将指针本身定义为const型（不太好用语言描述感觉），即一旦初始化完成，该指针便无法再指向其他对象。</p>
<p>下面还是一个const指针的说明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//const指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p=&amp;a;</span><br><span class="line"><span class="comment">//此时p和*p都是无法改变的</span></span><br></pre></td></tr></table></figure>

<p>当使用const指针指向的值也是const类型时，const指针本身必须再次使用一次const，因为要保持类型的一致</p>
<h3 id="顶-x2F-底层const"><a href="#顶-x2F-底层const" class="headerlink" title="顶&#x2F;底层const"></a>顶&#x2F;底层const</h3><p>对于指针，指针本身是一个对象，而它也指向了另一个对象，<strong>因此用顶层const表示指针本身是个const类型，用底层const表示指针所指的对象时一个const型</strong>。一般来说，顶层const可以表示任意对象。</p>
<ul>
<li><p>当const + 类型 时，意为使这个类型的值为常量，如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p;</span><br></pre></td></tr></table></figure>

<p>定义一个指针变量，该变量所指的值为int型，因此该值（*p）不可被修改，但是p可以被修改。</p>
</li>
<li><p>当const + 变量 时，意为使该变量为常量，如：</p>
</li>
<li><p>&#96;&#96;&#96;c++<br>int* const p;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  指针变量p为常量，因此其指向的地址无法被改变，但是地址中的值(*p)可以被改变。</span><br><span class="line"></span><br><span class="line">## 7、constexpr类型</span><br><span class="line"></span><br><span class="line">* 常量表达式：指值不会改变**并且在编译过程就能得到结果的表达式**；字面值、用常量表达式初始化的const对象也是常量表达式。</span><br><span class="line"></span><br><span class="line">  ```c</span><br><span class="line">  const int i = 10;			//字面值是常量表达式</span><br><span class="line">  const int j = i+1;			//j是常量表达式</span><br><span class="line">  int k = i;					//k不是const对象，所以k不是是常量表达式</span><br><span class="line">  const int m = get_val(); 	//m的值直到运行时才能获得，所以m不是常量表达是</span><br></pre></td></tr></table></figure>

<p>从上面我们可以看出，使用const进行声明时，我们需要<strong>人为的验证</strong>赋给const对象的初始值是不是常量表达是，在复杂系统中，有时候很难分辨，而使用constexpr进行声明时，可以由<strong>编译器来验证</strong>变量是不是常量表达式</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="number">10</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> m=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">constexpr</span> <span class="type">int</span> i = <span class="built_in">func1</span>(<span class="number">10</span>);<span class="comment">//正确，i是一个常量表达式</span></span><br><span class="line">	<span class="keyword">constexpr</span> <span class="type">int</span> j = <span class="built_in">func1</span>(n);<span class="comment">//错误,n为变量，不是字面值</span></span><br><span class="line">	<span class="keyword">constexpr</span> <span class="type">int</span> k = <span class="built_in">func1</span>(m+<span class="number">1</span>);<span class="comment">//正确，k是一个常量表达式</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="const和constexpr的区别"><a href="#const和constexpr的区别" class="headerlink" title="const和constexpr的区别"></a>const和constexpr的区别</h3><ul>
<li>对于修饰对象来说，const并未区分出编译期常量和运行期常量，constexpr限定在了编译期常量</li>
<li>在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。</li>
<li>constexpr将它所定义的对象置为顶层const</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>*p1=<span class="literal">nullptr</span>;  			<span class="comment">//p1是一个指向常量的指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span>*p2=<span class="literal">nullptr</span>;		<span class="comment">//p2是一个指向整数的常量指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span>*p3=<span class="literal">nullptr</span>; </span><br><span class="line"><span class="comment">//p3是一个指向常量的常量指针，由于constexpr只对指针有效，需要再加一个底层const才可以限制指针指向的对象</span></span><br></pre></td></tr></table></figure>

<h2 id="8、处理类型"><a href="#8、处理类型" class="headerlink" title="8、处理类型"></a>8、处理类型</h2><h3 id="（1）类型别名"><a href="#（1）类型别名" class="headerlink" title="（1）类型别名"></a>（1）类型别名</h3><p>类型别名是一个<strong>名字</strong>，<strong>是某种类型的同义词</strong>。有两种办法可用于定义类型别名：</p>
<ul>
<li><p>使用关键字typedef，详见<u>一些关键字 | 小董的BLOG</u> </p>
</li>
<li><p>使用别名声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> INT =<span class="type">int</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="类型别名与指针、常量"><a href="#类型别名与指针、常量" class="headerlink" title="类型别名与指针、常量"></a>类型别名与指针、常量</h4><p>有以下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> abc=<span class="type">char</span>*;</span><br><span class="line"><span class="type">char</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> abc p=&amp;a;<span class="comment">//此处等同于char *const p=&amp;a;而不是 const char *p=&amp;a;</span></span><br><span class="line"><span class="comment">//也就是说此处是常量指针，而不是指向常量的指针，因此：</span></span><br><span class="line">*p=<span class="number">20</span>;<span class="comment">//合法</span></span><br></pre></td></tr></table></figure>

<p>感觉可以直接理解为这里的const为顶层const型</p>
<h3 id="（2）auto类型说明符"><a href="#（2）auto类型说明符" class="headerlink" title="（2）auto类型说明符"></a>（2）auto类型说明符</h3><p>这里auto和C中用法有所出入，在C++11新标准中，auto用于让编译器通过初始值来推算变量的类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">auto</span> c=a+b;</span><br></pre></td></tr></table></figure>

<p>此时c的类型就为int</p>
<ul>
<li>auto定义的变量必须有初始值</li>
<li>参与初始化的各对象类型必须相同，否则会报错</li>
</ul>
<h4 id="在复合类型与常量参与的情况下："><a href="#在复合类型与常量参与的情况下：" class="headerlink" title="在复合类型与常量参与的情况下："></a>在复合类型与常量参与的情况下：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a=<span class="number">1</span>; &amp;a1=a;</span><br><span class="line"><span class="keyword">auto</span> b=a; <span class="comment">//b为int型</span></span><br><span class="line"><span class="keyword">auto</span> c=a1;<span class="comment">//c为int型</span></span><br><span class="line"><span class="keyword">auto</span> d=&amp;a;<span class="comment">//d为指向常量的指针</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> e=a; <span class="comment">//顶层const需专门声明</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>auto一般会忽略顶层const</p>
</li>
<li><p>对一个常量对象取地址是一种底层const</p>
</li>
</ul>
<h3 id="（3）decltype类型指示符"><a href="#（3）decltype类型指示符" class="headerlink" title="（3）decltype类型指示符"></a>（3）decltype类型指示符</h3><p>当我们定义一个变量时希望用一个表达式返回的类型定义该变量，但是又不想用该表达式的结果的值初始化变量，为满足这一要求，C++11新标准引入了decltype，它的作用是选择并返回操作数的数据类型，在此过程中，编译器分析表达式的类型，却不实际计算它的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>decltype()内的参数可以为变量、函数、甚至引用</p>
<h4 id="decltype和引用："><a href="#decltype和引用：" class="headerlink" title="decltype和引用："></a>decltype和引用：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">1</span>,&amp;a1=a,*p=&amp;a;</span><br><span class="line"><span class="type">int</span> b=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a1) c=b;<span class="comment">//c为int&amp;，也就是引用类型</span></span><br><span class="line"><span class="keyword">decltype</span>(a1+<span class="number">0</span>) d=<span class="number">1</span>; <span class="comment">//d为int型，原因是a1+0的结果为int型</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) e=b; <span class="comment">//*p的值按道理来说是1，书上讲这里讲为int&amp;型，也就是与c一样</span></span><br></pre></td></tr></table></figure>

<p>当decltype传入的参数添加上一对以上的括号后，例如decltype((a))，<strong>结果永远为引用</strong></p>
]]></content>
      <tags>
        <tag>C++学习</tag>
      </tags>
  </entry>
  <entry>
    <title>初识c++</title>
    <url>/2022/09/07/C++-1/</url>
    <content><![CDATA[<h1 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h1><ul>
<li><p><strong>iostream库</strong></p>
<p>在C++中没有专门定义的输入输出（IO）语句，而是使用了一个全面的<strong>标准库</strong>来提供IO机制等功能，也就是iostream库。而在iostream库中包含了两个基础<strong>类型</strong>：</p>
<ul>
<li>istream(in stream)：输入流</li>
<li>ostream(out stream)：输出流</li>
</ul>
</li>
<li><p>流的</p>
</li>
<li><p><strong>IO对象</strong></p>
<p>在标准库中定义了4个IO对象，分别为1个istream型，3个ostream型：</p>
<ul>
<li>instream型：<ul>
<li>cin(发音see in)：标准输入对象</li>
</ul>
</li>
<li>ostream型：<ul>
<li>cout：标准输出对象</li>
<li>cerr：输出警告和错误信息</li>
<li>clog：输出程序运行时的一般性消息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="输入输出例程："><a href="#输入输出例程：" class="headerlink" title="输入输出例程："></a>输入输出例程：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b;</span><br><span class="line">	std::cin&gt;&gt;a&gt;&gt;b;<span class="comment">//输入</span></span><br><span class="line">	std::cout&lt;&lt;a+b&lt;&lt;std::endl;<span class="comment">//输出</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面针对这个例程讲解：</p>
<ul>
<li><p>前缀std::</p>
<p>这个前缀指出cin、cout、endl都是定义在名为std的命名空间中的。使用命名空间可以避免与用户定义的名字冲突。且标准库的所有名字都是定义在std中的。</p>
</li>
<li><h3 id="从输入流读取数据："><a href="#从输入流读取数据：" class="headerlink" title="从输入流读取数据："></a>从输入流<strong>读取</strong>数据：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">std::cin&gt;&gt;a&gt;&gt;b;<span class="comment">//输入</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>输入运算符（&gt;&gt;)</strong></p>
<p>该运算符接收两个运算对象：</p>
<ul>
<li><p>左侧：必须为一个ostream型的对象</p>
</li>
<li><p>右侧：存放输入的值的变量</p>
</li>
</ul>
<p>返回值（计算结果）： ostream型的对象（左侧运算对象）</p>
<p>也就是说下面几种写法是一个意思：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">/****************************/</span><br><span class="line">(std::cin&gt;&gt;a)&gt;&gt;b;</span><br><span class="line">/****************************/</span><br><span class="line">std:cin&gt;&gt;a;</span><br><span class="line">std:cin&gt;&gt;b;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h3 id="向输出流写入数据："><a href="#向输出流写入数据：" class="headerlink" title="向输出流写入数据："></a>向输出流<strong>写入</strong>数据：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout&lt;&lt;a+b&lt;&lt;std::endl;<span class="comment">//输出</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>输出运算符（&lt;&lt;)</strong></p>
<p>该运算符接收两个运算对象：</p>
<ul>
<li>左侧：必须为一个istream型的对象</li>
<li>右侧：要打印的值</li>
</ul>
<p>返回值（计算结果）： 写入给定值的ostream型的对象</p>
<p>也就是说下面几种写法是一个意思：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout&lt;&lt;a+b&lt;&lt;std::endl;</span><br><span class="line"><span class="comment">/****************************/</span></span><br><span class="line">(std::cout&lt;&lt;a+b)&lt;&lt;std::endl;</span><br><span class="line"><span class="comment">/****************************/</span></span><br><span class="line">std::cout&lt;&lt;a+b;</span><br><span class="line">std::cout&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>endl操纵符</strong> <em>(小写L,不是1)</em></p>
<p>endl也是被定义在std中的一个特殊值，写入endl的效果是结束当前行（类似c中的\n)，并将与设备相关联的缓冲区中的内容刷到设备中。</p>
<p>缓冲刷新操作可以保证目前为止程序中所产生的所有输出都真正的写入到了输出流中，而不仅停留在内存中等待写入流。</p>
</li>
<li><p><strong>关于数据缓冲区</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b=<span class="number">1</span>,c;</span><br><span class="line">	<span class="keyword">while</span>(std::cin&gt;&gt;a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//while (getchar()!= &#x27;\n&#x27;);</span></span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;times:&quot;</span>&lt;&lt;b++&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用一个istream对象为<strong>条件</strong>时，其效果就是检测输入流当前的状态，如果流是有效的，此时istream对象使条件为真，当遇到以下情况时为假：</p>
<ul>
<li>无效输入：例如上方输入不为int型（与a类型不符合）</li>
<li>当输入流遇到文件结束符，对于window系统，<strong>输入文件结束符的方法是ctrl+z+\n</strong></li>
</ul>
<p>在上方程序中（当注释掉第七行时），当输入4 ‘\0’ 5时，time也会对应输出2次，即1 ‘\n’ 2 。这是因为当输入一次性输入两个数时，第一个数存进a，第二个数会被存在数据缓冲区中等待下一次读取输入流的操作；若想清除缓冲区（或者说是清零），只需添加第7行即可。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>C++学习</tag>
      </tags>
  </entry>
  <entry>
    <title>FreeRTOS任务间的交互方法</title>
    <url>/2022/08/30/freertos%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
    <content><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><p>本来是打算在<a href="https://www.dhksblog.top/2022/08/25/FreeRTOS-3/">FreeRTOS在CubeMX中的使用</a>就把这些内容给讲了的，但是学习的过程中发现网络上很多教程都存在着一些差异，所以为了更系统地学习，同时也方便日后查阅，就单独开一篇文章总结一下相关内容</p>
<p><strong>注：本文所有例程均经过测试且可以正常运行</strong></p>
<h1 id="1、队列"><a href="#1、队列" class="headerlink" title="1、队列"></a>1、队列</h1><p>FreeRTOS中的队列<strong>是一种用于实现【任务与任务】，【任务与中断】以及【中断与任务】之间的通信机制。</strong>此外，任务从队列读数据或者写入数据到队列时，都可能被阻塞。这个特性使得任务可以被设计成基于事件驱动的运行模式，大大提高了CPU的执行效率。队列是实现FreeRTOS中其他特性的基础组件，像软件定时器，信号量，互斥锁都是基于队列而实现的。</p>
<p>在操作系统里面，直接使用全局变量传输数据十分危险，看似正常运行，但不知道啥时候就会因为寄存器或者内存等等原因引起崩溃，所以引入消息，队列的概念。</p>
<h2 id="队列的基本特性"><a href="#队列的基本特性" class="headerlink" title="队列的基本特性"></a>队列的基本特性</h2><p>队列是一种FIFO操作的数据结构，入队操作就是把一个新的元素放进队尾(tail)，出队操作就是从队头(front)取出一个元素。FreeRTOS中也支持把一个元素放到队头的操作，这个操作会<strong>覆盖</strong>之前队头的元素。</p>
<h2 id="入队策略"><a href="#入队策略" class="headerlink" title="入队策略"></a>入队策略</h2><p>队列在设计的时候，主要有两种元素入队存储策略：Queue by copy 和 Queue by reference。FreeRTOS的队列使用的是Queue by copy存储策略，考虑到这种策略实现起来更加简单，灵活，且安全。</p>
<ul>
<li>Queue by copy：数据入队的时候，队列中存储的是此数据的一份拷贝</li>
<li>Queue by reference：数据队列的时候，队列中存储的是数据的指针，而非数据本身</li>
</ul>
<h2 id="入队堵塞"><a href="#入队堵塞" class="headerlink" title="入队堵塞"></a>入队堵塞</h2><p>一个任务在尝试写入数据到队列时，可以指定一个阻塞时间，即任务在<strong>等待队列有空余空间（非满）可写前最长等待阻塞时间</strong>。当队列中有空间可写入时，任务会自动从阻塞态转换为就绪态。如果在等待时间内队列一直是满的，则等待时间到期后，任务也会自动从阻塞态转换为就绪态，但是它会返回一个写入失败的结果。</p>
<p>队列可能有多个writerTask，所以在等待队列有空闲空间时，可能会有多个任务阻塞。<strong>当队列有空闲空间可写时，调度器会从所有阻塞的任务中选取优先级最高的那个任务让其进入到就绪态</strong>。<strong>如果最高优先级的不止一个，则让等待最久的那个进入到就绪态。</strong></p>
<h2 id="出队堵塞"><a href="#出队堵塞" class="headerlink" title="出队堵塞"></a><strong>出队堵塞</strong></h2><p>一个任务在尝试从队列中读取数据时，可以指定一个阻塞时间，即任务在等待队列有元素可读前最长等待阻塞时间。当队列中有元素可读时，任务会自动从阻塞态转换为就绪态。<strong>如果在等待时间内队列一直没有数据可读，则等待时间到期后，任务也会自动从阻塞态转换为就绪态，但是它会返回一个读取失败的结果</strong>。</p>
<p>队列可能有多个reader Task，所以在等待队列有数据可读时，可能会有多个任务阻塞。<strong>当队列有数据可读时，调度器会从所有阻塞的任务中选取优先级最高的那个任务让其进入到就绪态。如果最高优先级的不止一个，则让等待最久的那个进入到就绪态。</strong></p>
<h2 id="相关API函数"><a href="#相关API函数" class="headerlink" title="相关API函数"></a>相关API函数</h2><ul>
<li><p>队列创建（若使用cubemx则只用点点点，不用再用函数创建，所有创建类函数同理）</p>
<p>使用xQueueCreate()内核函数来创建一个队列。队列的1存储空间从FreeRTOS heap中分配。在使用xQueueCreate()创建队列时，如果FreeRTOS heap中没有足够的存储空间分配给当前队列，则函数返回NULL。如果创建成功，则返回队列的句柄(QueueHandle_t类型)</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize );</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center"><strong>uxQueueLength</strong>：指定队列的长度，即最多可以存放的元素个数<br><strong>uxItemSize</strong>：队列中存储的元素的大小（占用的字节数）</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">返回NULL代表创建失败，没有足够的堆空间来创建当前队列；创建成功则返回队列的句柄</td>
</tr>
</tbody></table>
<ul>
<li><p>元素入队</p>
<p>使用xQueueSendToBack()函数来向队尾存放一个元素，使用xQueueSend()函数来向队首存放一个元素，两个函数用法一样</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">BaseType_t xQueueSendToBack( QueueHandle_t xQueue,<br>                                                                        const void * pvItemToQueue,<br>                                                       TickType_t xTicksToWait );</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center"><strong>xQueue</strong>：目标队列的句柄<br><strong>pvItemToQueue</strong>：入队元素的指针。队列将存储此指针指向的数据的备份<br><strong>xTicksToWait</strong>：指定等待队列有空间可以容纳新元素入队的最长等待（阻塞）时间</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">当元素成功入队时返回pdPASS，因为队列满而无法入队时返回errQUEUE_FULL（超时后）</td>
</tr>
</tbody></table>
<ul>
<li><p>查询队列元素个数</p>
<p>使用内核函数uxQueueMessagesWaiting()来获取队列中有多少个元素</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">UBaseType_t uxQueueMessagesWaiting( QueueHandle_t xQueue );</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center"><strong>xQueue</strong>：队列的句柄</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">队列中的元素个数，返回0代表队列为空</td>
</tr>
</tbody></table>
<p>按键例程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span> <span class="comment">//低优先级任务</span></span><br><span class="line">&#123;</span><br><span class="line">  BaseType_t result; </span><br><span class="line">  <span class="type">uint8_t</span> dat[]=<span class="string">&quot;666\r\n&quot;</span>;</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">	<span class="keyword">if</span>(HAL_GPIO_ReadPin(key_1_GPIO_Port,key_1_Pin == GPIO_PIN_SET)) <span class="comment">//检测按键</span></span><br><span class="line">	&#123;</span><br><span class="line">		result= xQueueSendToBack(myQueue01Handle,dat,portMAX_DELAY); <span class="comment">//将元素dat放至队尾</span></span><br><span class="line">		<span class="keyword">if</span>(result==pdPASS) <span class="comment">//放置成功返回pdPASS</span></span><br><span class="line">		&#123;</span><br><span class="line">			HAL_GPIO_WritePin(led_g_GPIO_Port,led_g_Pin,GPIO_PIN_RESET);<span class="comment">//点亮绿灯</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">   	osDelay(<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span> <span class="comment">//高优先级任务</span></span><br><span class="line">&#123;</span><br><span class="line">  BaseType_t result;</span><br><span class="line">  <span class="type">uint8_t</span> datbuf[<span class="number">10</span>]; <span class="comment">//随便定义个缓冲区就可以，用于存放取出的元素</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">	result=xQueueReceive(myQueue01Handle,datbuf,portMAX_DELAY);<span class="comment">//取出元素放入datbuf中</span></span><br><span class="line">	<span class="keyword">if</span>(result==pdPASS)<span class="comment">//读取成功返回pdPASS</span></span><br><span class="line">	&#123;</span><br><span class="line">		HAL_GPIO_WritePin(led_r_GPIO_Port,led_r_Pin,GPIO_PIN_RESET);<span class="comment">//点亮红灯</span></span><br><span class="line">	&#125;</span><br><span class="line">	osDelay(<span class="number">10</span>);</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2、任务通知"><a href="#2、任务通知" class="headerlink" title="2、任务通知"></a>2、任务通知</h1><p><em>在网上找了很多博客对于任务通知介绍的函数都不一样，我自己也实验了很多，就把我试验过的可行的函数都总结一遍，可以根据具体的需要选择相关函数（其实函数功能基本差不多，但是原理不一样）</em></p>
<p>每个RTOS任务都有一个32位的通知值，任务创建时，这个值被初始化为0。RTOS任务通知相当于直接向任务发送一个事件，接收到通知的任务可以解除阻塞状态，<strong>前提是这个阻塞事件是因等待通知而引起的</strong>。发送通知的同时，也可以可选的改变接收任务的通知值。</p>
<p>相对于用前必须分别创建队列、二进制信号量、计数信号量或事件组的情况，使用任务通知显然更灵活。更好的是，相比于使用信号量解除任务阻塞，使用任务通知可以快45%、使用更少的RAM。</p>
<p><strong>下面介绍的函数大类都可以实现任务通知的功能，可以根据需要选择</strong></p>
<h2 id="一、xTask函数"><a href="#一、xTask函数" class="headerlink" title="一、xTask函数"></a>一、xTask函数</h2><h3 id="发送函数（1）"><a href="#发送函数（1）" class="headerlink" title="发送函数（1）"></a>发送函数（1）</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">BaseType_t xTaskNotify( TaskHandle_txTaskToNotify,<br>                          uint32_t ulValue,<br>                           eNotifyAction eAction);</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center">xTaskToNotify：被通知的任务句柄<br>ulValue： 通知更新值<br> eAction:枚举类型，指明更新通知值的方法</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">成功则返回pdPASS</td>
</tr>
</tbody></table>
<p>eAction具体说明：</p>
<table>
<thead>
<tr>
<th align="center">枚举成员</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">eNoAction</td>
<td align="center">发送通知但不更新通知值，意味着ulValue未使用</td>
</tr>
<tr>
<td align="center">eSetBits</td>
<td align="center">被通知任务值赋值按位或赋值ulValue</td>
</tr>
<tr>
<td align="center">elncrement</td>
<td align="center">被通知任务的通知值++</td>
</tr>
<tr>
<td align="center">eSetValueWithOverwrite</td>
<td align="center">被通知任务值赋值为ulValue</td>
</tr>
<tr>
<td align="center">eSetValueWithoutOverwrite</td>
<td align="center">如果被通知的任务还没取走上一个通知的情况下，又向被通知任务发送一个新的通知，则新通知值被丢弃，且xTaskNotify()会返回pdFALSE</td>
</tr>
</tbody></table>
<img src="/images/loading.png" data-original="/2022/08/30/freertos%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F/eaction.jpg" class title="This is an image"> 

<h3 id="发送函数（2）"><a href="#发送函数（2）" class="headerlink" title="发送函数（2）"></a>发送函数（2）</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">BaseType_t xTaskNotifyGive(TaskHandle_t xTaskToNotify );</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center">xTaskToNotify：被通知的任务句柄</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">成功则返回pdPASS</td>
</tr>
</tbody></table>
<p>其实这是一个宏，本质上相当于xTaskNotify( ( xTaskToNotify ), ( 0 ), <strong>eIncrement</strong> )在这种情况下，应该使用API函数ulTaskNotifyTake()来等待通知，而不应该使用API函数xTaskNotifyWait()</p>
<p>此函数不可以在中断服务例程中调用，中断保护等价函数为vTaskNotifyGiveFromISR()</p>
<h3 id="接收函数（1）"><a href="#接收函数（1）" class="headerlink" title="接收函数（1）"></a>接收函数（1）</h3><p><u><strong>注意，此处讲到的接收函数应与上面讲到的发送函数配对，例如：使用发送函数（1），接收通知也要使用接收函数（1）</strong></u></p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">BaseType_t xTaskNotifyWait( uint32_tulBits  ToClearOnEntry,<br>                                                      uint32_tulBits  ToClearOnExit,<br>                                                          uint32_t*  pulNotificationValue,<br>                                    TickType_t  xTicksToWait );</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center">见下方</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">成功则返回pdPASS</td>
</tr>
</tbody></table>
<p>关于参数：</p>
<ul>
<li>ulBitsToClearOnEntry：在使用通知之前，先将任务的通知值与参数ulBitsToClearOnEntry的按位取反值按位与操作。设置参数ulBitsToClearOnEntry为0xFFFFFFFF(ULONG_MAX)，表示清零任务通知值。<ul>
<li><strong>但是在实际调试过程中感觉给0x00和0xFFFFFFFF在使用上没有区别，所以就给0xFFFFFFFF就可以</strong></li>
</ul>
</li>
</ul>
<img src="/images/loading.png" data-original="/2022/08/30/freertos%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F/qufan1.jpg" class title="This is an image"> 

<ul>
<li>*ulBitsToClearOnExit：在函数xTaskNotifyWait()退出前，将任务的通知值与参数ulBitsToClearOnExit的按位取反值按位与操作。设置参数ulBitsToClearOnExit为0xFFFFFFFF(ULONG_MAX)，表示清零任务通知值。<ul>
<li><strong>使用同上，默认0xFFFFFFFF就可以</strong></li>
</ul>
</li>
</ul>
<img src="/images/loading.png" data-original="/2022/08/30/freertos%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F/qufan2.jpg" class title="This is an image"> 

<ul>
<li>pulNotificationValue：用于向外回传任务的通知值。这个通知值在参数ulBitsToClearOnExit起作用前将通知值拷贝到*pulNotificationValue中（<strong>需额外定义一个缓冲区</strong>）。如果不需要返回任务的通知值，这里设置成NULL。</li>
<li>xTicksToWait：因等待通知而进入阻塞状态的最大时间。时间单位为系统节拍周期。宏pdMS_TO_TICKS用于将指定的毫秒时间转化为相应的系统节拍数。</li>
</ul>
<h3 id="接收函数（2）"><a href="#接收函数（2）" class="headerlink" title="接收函数（2）"></a>接收函数（2）</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">uint32_t ulTaskNotifyTake( BaseType_t  xClearCountOnExit,<br>                                TickType_t   xTicksToWait );</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center">xClearCountOnExit：如果该参数为pdFALSE，则API函数xTaskNotifyTake()退出前，将任务的通知值减1；如果该参数设置为pdTRUE，则API函数xTaskNotifyTake()退出前，将任务通知值清零。<br>xTicksToWait：因等待通知而进入阻塞状态的最大时间</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">成功则返回pdPASS</td>
</tr>
</tbody></table>
<h3 id="上例程！老规矩按键-led"><a href="#上例程！老规矩按键-led" class="headerlink" title="上例程！老规矩按键+led"></a>上例程！老规矩按键+led</h3><p>发送函数（1）+接收函数（1）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> event1 0x0001&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> event2 0x0001&lt;&lt;2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span> <span class="comment">//低优先级</span></span><br><span class="line">&#123;</span><br><span class="line">	BaseType_t result;</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">		<span class="keyword">if</span>(HAL_GPIO_ReadPin(key_1_GPIO_Port,key_1_Pin) == GPIO_PIN_SET)<span class="comment">//按键检测</span></span><br><span class="line">		&#123;</span><br><span class="line">			result=  xTaskNotify(task2Handle,event1,<span class="number">4</span>);<span class="comment">//直接数字代替枚举成员</span></span><br><span class="line">			<span class="keyword">if</span>(result==pdPASS)</span><br><span class="line">			&#123;</span><br><span class="line">				HAL_GPIO_WritePin(led_g_GPIO_Port,led_g_Pin,GPIO_PIN_RESET);<span class="comment">//绿灯</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(HAL_GPIO_ReadPin(key_2_GPIO_Port,key_2_Pin) == GPIO_PIN_SET)<span class="comment">//按键检测</span></span><br><span class="line">		&#123;</span><br><span class="line">			result=  xTaskNotify(task2Handle,event2,<span class="number">4</span>);<span class="comment">//直接数字代替枚举成员</span></span><br><span class="line">			<span class="keyword">if</span>(result==pdPASS)</span><br><span class="line">			&#123;</span><br><span class="line">				HAL_GPIO_WritePin(led_b_GPIO_Port,led_b_Pin,GPIO_PIN_RESET);<span class="comment">//蓝灯</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		osDelay(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span><span class="comment">//高优先级</span></span><br><span class="line">&#123;</span><br><span class="line">	BaseType_t result;</span><br><span class="line">	<span class="type">uint32_t</span> ulNotifiedValue; <span class="comment">//存放任务通知值的缓冲区</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">		result=xTaskNotifyWait(<span class="number">0xFFFFFFFF</span>, <span class="number">0xFFFFFFFF</span>,&amp;ulNotifiedValue, portMAX_DELAY);</span><br><span class="line">		<span class="keyword">if</span>(result==pdPASS)</span><br><span class="line">		&#123;</span><br><span class="line">			HAL_GPIO_WritePin(led_r_GPIO_Port,led_r_Pin,GPIO_PIN_RESET);<span class="comment">//红灯</span></span><br><span class="line">		&#125;</span><br><span class="line">      	<span class="keyword">if</span>(ulNotifiedValue&amp;event1)</span><br><span class="line">		&#123;</span><br><span class="line">			HAL_GPIO_WritePin(led_r_GPIO_Port,led_r_Pin,GPIO_PIN_SET);</span><br><span class="line">			HAL_GPIO_WritePin(led_b_GPIO_Port,led_b_Pin,GPIO_PIN_SET);</span><br><span class="line">			HAL_GPIO_WritePin(led_g_GPIO_Port,led_g_Pin,GPIO_PIN_SET);<span class="comment">//全灭</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">if</span>(ulNotifiedValue&amp;event2)</span><br><span class="line">		&#123;</span><br><span class="line">			HAL_GPIO_WritePin(led_r_GPIO_Port,led_r_Pin,GPIO_PIN_RESET);</span><br><span class="line">			HAL_GPIO_WritePin(led_b_GPIO_Port,led_b_Pin,GPIO_PIN_RESET);</span><br><span class="line">			HAL_GPIO_WritePin(led_g_GPIO_Port,led_g_Pin,GPIO_PIN_RESET);<span class="comment">//全亮</span></span><br><span class="line">		&#125;</span><br><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment"> 整体逻辑：</span></span><br><span class="line"><span class="comment"> 按键1按下-&gt;绿灯亮-&gt;红灯亮-&gt;全灭</span></span><br><span class="line"><span class="comment"> 按键2按下-&gt;蓝灯亮-&gt;红灯亮-&gt;全灭</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 这里对于通知值的判断可以让用户知道是哪个任务通知函数触发了这次任务接收，感觉非常好用！！！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">		osDelay(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>发送函数（2）+接收函数（2）就不单独写了，基本同理，只是接收函数（2）无法对通知值进行判断，但是整体更方便快捷</p>
<h2 id="二、os函数"><a href="#二、os函数" class="headerlink" title="二、os函数"></a>二、os函数</h2><h3 id="向指定任务发送任务通知"><a href="#向指定任务发送任务通知" class="headerlink" title="向指定任务发送任务通知"></a>向指定任务发送任务通知</h3><table>
<thead>
<tr>
<th align="center"><strong>函数</strong></th>
<th align="center"><strong>int32_t osSignalSet (osThreadId thread_id, int32_t signal)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center"><strong>thread_id：</strong> 接收通知的任务ID<br><strong>signal：</strong>任务通知值（按位操作数字）</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">错误码</td>
</tr>
</tbody></table>
<h3 id="等待任务通知"><a href="#等待任务通知" class="headerlink" title="等待任务通知"></a>等待任务通知</h3><table>
<thead>
<tr>
<th align="center"><strong>函数</strong></th>
<th align="center"><strong>osEvent osSignalWait (int32_t signals, uint32_t millisec)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center">signals： 接收完成后等待被清零的数据位(0x0001|0x0002&#x3D;0x003)<br><strong>millisec：</strong> 等待超时时间，单位为系统节拍周期</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">错误码</td>
</tr>
</tbody></table>
<h3 id="例程，按键-led"><a href="#例程，按键-led" class="headerlink" title="例程，按键+led"></a>例程，按键+led</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> event1 0x0001</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span> <span class="comment">//低优先级任务</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN led_G */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">		<span class="keyword">if</span>(HAL_GPIO_ReadPin(key_1_GPIO_Port,key_1_Pin == GPIO_PIN_SET))</span><br><span class="line">		&#123;</span><br><span class="line">			osSignalSet(task2Handle,event1);</span><br><span class="line">		&#125;	</span><br><span class="line">		osDelay(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END led_G */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span> <span class="comment">//高优先级任务</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN led_B */</span></span><br><span class="line">	osEvent event;	</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">	event = osSignalWait(event1,osWaitForever);  </span><br><span class="line">	<span class="keyword">if</span>(event.status == osEventSignal)  </span><br><span class="line">	&#123;</span><br><span class="line">		HAL_GPIO_WritePin(led_g_GPIO_Port,led_g_Pin,GPIO_PIN_RESET);</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里task2可以不用额外在循环中添加堵塞，因为wait函数本身自带堵塞，<strong>其堵塞的解除是在osSignalSet函数的作用之后的瞬间，也就是说在执行完osSignalSet(task2Handle,event1)后task2会直接抢占task1</strong></p>
<p><strong>而xTask函数不同于os函数，xTask函数是在task1执行完后才会进入task2，这点请务必记住，二者通知原理不同，所以根据使用情况选择使用xTask函数还是os函数</strong></p>
<h1 id="3、信号量"><a href="#3、信号量" class="headerlink" title="3、信号量"></a>3、信号量</h1><p>信号量同样是一种任务之间交互的函数，但是就我按照网上教程使用过后感觉。。。不如队列和任务通知，可能是我目前的一些工程量还没到使用到信号量的程度？而且在使用过程中也遇到了一些迷惑的地方，所以目前不准备深究，等到实在要用的时候再说吧😋，感兴趣的同学可以去<a href="https://freertos.blog.csdn.net/article/details/50835613">(19条消息) FreeRTOS系列第19篇—FreeRTOS信号量_研究是为了理解的博客-CSDN博客_freertos 信号</a>看看，讲的很详细了可以说，我大部分内容也是跟着这个学的。</p>
]]></content>
      <tags>
        <tag>嵌入式学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言二级查漏补缺（自用）</title>
    <url>/2022/08/28/C%E8%AF%AD%E8%A8%80%E4%BA%8C%E7%BA%A7%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<ul>
<li>一个Ｃ语言的源程序（扩展名为．ｃ）在经过编译器编译后，首先生成一个汇编语言程序，然后由编译程序再将汇编语言程序翻译成机器指令程序，即目标程序（扩展名为．ｏｂｊ）。目标程序不可以直接运行，它要和库函数或其他目标程序连接成可执行文件（扩展名为．ｅｘｅ）后方可运行</li>
</ul>
<p>.obj文件不可直接运行</p>
<ul>
<li><p>算法的５个特性为：</p>
<ul>
<li>有穷性</li>
<li>确定性</li>
<li>可行性</li>
<li>有零个或多个输入（可以无输入）</li>
<li>有１个或多个输出（必须有输出）</li>
</ul>
</li>
<li><p>逗号运算符</p>
<p>在C语言中逗号“,”也是一种运算符，称为逗号运算符。 其功能是把两个表达式连接起来组成一个表达式， 称为逗号表达式。其一般形式为：<br>  表达式1, 表达式2<br>其求值过程是分别求两个表达式的值，并以表达式**2(即最右边的一个表达式)**的值作为整个逗号表达式的值。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(x++,<span class="number">2</span>*x)); <span class="number">6</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,x); <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>​		<strong>逗号仅计算结果，并不具有赋值作用</strong>（但是x++有赋值作用）</p>
<ul>
<li><p>算术运算符优先级</p>
<p>优先级的次序如下（由高到低）：（）、++、–、＊、／、％、＋、－</p>
<p>以上所列的运算符，<strong>只有单目运算符正“＋”和负“－”的结合性是从右到左，其余运算符的结合性都是从左到右</strong></p>
<ul>
<li>%对象必须为整型</li>
</ul>
</li>
<li><p>运算库函数</p>
<ul>
<li>abs：绝对值</li>
<li>fabs：双字节型绝对值</li>
<li>pow：x的y次方</li>
<li>exp：求10的x次方</li>
<li>sqrt：x的平方根</li>
</ul>
</li>
</ul>
<p>BCCAA <strong>A</strong>DBB<strong>D</strong> DAC</p>
<ul>
<li>数字的默认类型为整型</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>,<span class="number">1</span>/<span class="number">2</span>); <span class="comment">//0.000000</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>c的基本数据类型：单精度型、双精度型、字符型、整型、枚举型</p>
</li>
<li><p>c负整数补码：所得反码还要+1</p>
</li>
</ul>
<h1 id="三、顺序结构"><a href="#三、顺序结构" class="headerlink" title="三、顺序结构"></a>三、顺序结构</h1><ul>
<li><p>格式字符：</p>
<ul>
<li>%i同%d</li>
<li>%o 八进制</li>
<li>%g&#x2F;G 系统决定采用什么格式（f或e）使输出宽度最小</li>
<li>%p 输出变量地址</li>
</ul>
<p>%m.ns，输出占ｍ列，但只取字符串中左边ｎ个字符。这ｎ个字符输出在ｍ列的右边，<strong>左边补空格</strong></p>
<p>%-m.ns，ｎ个字符<strong>输出在ｍ列范围的左边，右边补空格</strong>。若ｎ＞ｍ，则ｍ自动取ｎ值，即保证ｎ个字符正常输出。</p>
</li>
</ul>
<p>B<strong>BA</strong>BD DACD<strong>D</strong> <strong>C</strong>C<strong>A</strong></p>
<p>BDCBD DACDB DCB    34页</p>
<ul>
<li><p>八进制格式输出开头不带0</p>
</li>
<li><p>逗号优先级低于赋值</p>
</li>
</ul>
<h1 id="四、选择结构"><a href="#四、选择结构" class="headerlink" title="四、选择结构"></a>四、选择结构</h1><ul>
<li><p>逻辑或运算的短路性</p>
<p>如果||前的表达式为真，则不会进行||后的表达式运算(&amp;&amp;以此类推)</p>
</li>
</ul>
<p>DBADD <strong>A</strong>A<strong>A</strong>A<strong>A</strong> AC</p>
<p>DBADD DACAB AC    54页</p>
<h1 id="五、循环结构"><a href="#五、循环结构" class="headerlink" title="五、循环结构"></a>五、循环结构</h1><ul>
<li>while((ch&#x3D;getchar())!&#x3D;’\n’);符合语法</li>
</ul>
<p>AA<strong>AD</strong>C DBBC<strong>C</strong> B<strong>CA</strong></p>
<p>AACBC DBBCB BBC    75页</p>
<h1 id="六、字符型数据"><a href="#六、字符型数据" class="headerlink" title="六、字符型数据"></a>六、字符型数据</h1><ul>
<li><p>转义字符</p>
<p>\f:换页</p>
<p>\ddd: 1~3位八进制数对应字符例如’\123’</p>
<p>\xhh: 1~2位16进制数对应字符例如’\x12’</p>
</li>
</ul>
<p>BA*<u>A</u>*DD DBCB</p>
<p>BA<u><em>C</em></u>DD D<strong>C</strong>CB    85页</p>
<p>3忽略</p>
<ul>
<li>default后无break也会执行（？）</li>
</ul>
<h1 id="七、函数"><a href="#七、函数" class="headerlink" title="七、函数"></a>七、函数</h1><p><strong>C</strong>DD<strong>CB</strong> D<strong>D</strong>D<strong>A</strong>D C</p>
<p>BDDDC DADCD C    102页</p>
<ul>
<li>简单变量作实参时与形参数据的传输方式为单向值传递</li>
<li>return语句中带有++时，返回之后并且作用之后才会++</li>
</ul>
<h1 id="八、指针"><a href="#八、指针" class="headerlink" title="八、指针"></a>八、指针</h1><ul>
<li><p>有<code>int a,*p1=&amp;a;</code>由于&amp;和*运算优先级相同，&amp; *p1则从右至左运算，则&amp; *p1等同于&amp;a</p>
<p>*&amp;a则是等同于 *p1等同于a</p>
</li>
<li><p><strong><code>*</code>的优先级高于+、-,因此<code> *p1</code>&#x3D;<code> *p1</code>+1是将a+1的值存进p内存储的地址所指向的内容中，也就是相当于a&#x3D;a+1；但是a的地址是不变的。</strong></p>
</li>
</ul>
<p>具体对指针的一些理解已添加在<a href="https://dhkkk.gitee.io/2022/07/31/C-%E6%8C%87%E9%92%88/">指针相关复习 | 小董的BLOG (gitee.io)</a>中</p>
<p>DADBB A<u><em>D</em></u>BDB BCC</p>
<p>DADDB A<u><em><strong>C</strong></em></u>BDB BCC  116页</p>
<p>7忽略（第一次全对捏）</p>
<h1 id="九、数组"><a href="#九、数组" class="headerlink" title="九、数组"></a>九、数组</h1><p>CDDBC CBBCD ACA<strong>B</strong></p>
<p>CDDBC CBBCD ACAC   146页</p>
<h1 id="十、字符串"><a href="#十、字符串" class="headerlink" title="十、字符串"></a>十、字符串</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span> *x, <span class="type">char</span> *y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(*x==<span class="string">&#x27;*&#x27;</span>) x++;</span><br><span class="line">	<span class="keyword">while</span>(*y=*x) <span class="comment">//将x所指向的字符赋值给y，直到遇到&#x27;/0&#x27;为止，这样写是正确的</span></span><br><span class="line">	&#123;</span><br><span class="line">		x++;y++;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> s[<span class="number">30</span>]=<span class="string">&quot;******a*b***&quot;</span>,t[<span class="number">30</span>];</span><br><span class="line">	swap(s,t);</span><br><span class="line">	<span class="built_in">puts</span>(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AADCC <strong>DA</strong>BB<strong>D</strong> C<strong>A</strong></p>
<p>AADCC CBBBA CB              173页  6、10、12</p>
<p><strong>strcpy会覆盖原来的整个字符串，而strncpy只会覆盖n个字节原来的字符串，剩下的保留</strong></p>
<h1 id="十一、对函数的进一步讨论"><a href="#十一、对函数的进一步讨论" class="headerlink" title="十一、对函数的进一步讨论"></a>十一、对函数的进一步讨论</h1><ul>
<li><p>传入main的参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">main(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span><br></pre></td></tr></table></figure></li>
</ul>
<p>当我们对一个名为test的c文件进行编译时，在终端输入： test  ok  good后：</p>
<ul>
<li><p>argc值为3，即存入argv的字符串个数</p>
</li>
<li><p>argv[0]存放</p>
</li>
<li><p>对指向函数的指针变量进行加减法无意义</p>
</li>
</ul>
<p>CDCD<strong>D</strong> BBCB</p>
<p>CDCDC BBCB 184页</p>
<h1 id="十二、用户标识符的作用域和存储类"><a href="#十二、用户标识符的作用域和存储类" class="headerlink" title="十二、用户标识符的作用域和存储类"></a>十二、用户标识符的作用域和存储类</h1><p>ACDB<strong>A</strong> A<strong>C</strong>CC**<u>D</u>** <strong>C</strong></p>
<p>ACDBB ADCCA D  195页</p>
<ul>
<li>若全局变量和某一函数中局部变量同名，则在函数内全局变量被屏蔽</li>
</ul>
<h1 id="十三、编译预处理和动态存储分配"><a href="#十三、编译预处理和动态存储分配" class="headerlink" title="十三、编译预处理和动态存储分配"></a>十三、编译预处理和动态存储分配</h1><p>详见<a href="https://dhkkk.gitee.io/2022/08/03/C-%E5%85%B3%E9%94%AE%E5%AD%97/">一些关键字 | 小董的BLOG (gitee.io)</a></p>
<p><strong>AACD</strong>C A<strong>D</strong>AA</p>
<p>DBBBC ACAA</p>
<p>define只作替换！！！！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> D1(a) (2*a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> D2(a) (2*(a))</span></span><br><span class="line"><span class="comment">//计算结果最好也用括号括起来,小型计算不括问题应该不大</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="type">int</span> b = D1(<span class="number">3</span>+<span class="number">4</span>);</span><br><span class="line">     <span class="type">int</span> c = D2(<span class="number">3</span>+<span class="number">4</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, b);  <span class="comment">//输出等价于2*3+4=10 ※※※※※※※※※※※※※</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, c);  <span class="comment">//2*(3+4)=14</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="十四、结构体、共用体和用户自定义型"><a href="#十四、结构体、共用体和用户自定义型" class="headerlink" title="十四、结构体、共用体和用户自定义型"></a>十四、结构体、共用体和用户自定义型</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="type">int</span> a;<span class="type">int</span> b;&#125;a;<span class="comment">//合法</span></span><br></pre></td></tr></table></figure>

<p>关于动态链表详见<a href="https://dhkkk.gitee.io/2022/08/01/C-%E7%BB%93%E6%9E%84%E4%BD%93/">结构体复习 | 小董的BLOG (gitee.io)</a></p>
<p>AABB×	<strong>C</strong>CBDD	BC</p>
<p>ADBBA	DCBCD	BD    6题看题不仔细捏</p>
<h1 id="十五、位运算"><a href="#十五、位运算" class="headerlink" title="十五、位运算"></a>十五、位运算</h1><p>长度不同的数据进行位运算时先将最低位对齐，然后将短的一方扩充</p>
<p>D<strong>C</strong>DAA	BCD</p>
<p>DADAA	BCD</p>
<p>看清楚输出的格式声明</p>
<p>240</p>
]]></content>
      <tags>
        <tag>C语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>FreeRTOS在CubeMX中的使用</title>
    <url>/2022/08/25/FreeRTOS-3/</url>
    <content><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><p><strong>此篇所有有关函数均为CubeMX 提供的os函数（特殊地方会专门说明），freertos相关用户调用函数也分类似标准库和hal库的区别！但大体用法也与</strong><a href="https://dhkkk.gitee.io/2022/08/23/FreeRTOS-2/">FreeRTOS的任务相关 | 小董的BLOG (gitee.io)</a><strong>中介绍的相似，可以参考</strong></p>
<p><strong>2022.8.26： 阅读了os函数内容并验证后，发现os函数与vtask函数兼容，（其实os函数也是调用的vtask函数）所以理论来说两边的函数可以混用，但是为了可读性等方面尽量还是不要混用</strong></p>
<p><strong>2022.8.28：在自己用了很多功能后，越发觉得库函数比os函数好用，大家自己取舍吧，反正二者是可以混用的，先用cubemx配置，再用库函数编写具体内容也是完全🆗的。</strong></p>
<h1 id="1、配置界面"><a href="#1、配置界面" class="headerlink" title="1、配置界面"></a>1、配置界面</h1><table>
<thead>
<tr>
<th align="center">配置项</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Tasks and Queues</strong></td>
<td align="center">任务与队列，用于配置任务体以及消息队列</td>
</tr>
<tr>
<td align="center"><strong>Timers and Semaphores</strong></td>
<td align="center">软件定时器与信号量，用于配置内核对象 （软件定时器和信号量）</td>
</tr>
<tr>
<td align="center"><strong>Mutexes</strong></td>
<td align="center">互斥量，用于配置内核对象（互斥量）</td>
</tr>
<tr>
<td align="center"><strong>Events</strong></td>
<td align="center">事件，配置内核对象（事件）</td>
</tr>
<tr>
<td align="center"><strong>FreeRTOS Heap Usage</strong></td>
<td align="center">查看用户任务和系统任务的堆占用</td>
</tr>
<tr>
<td align="center"><strong>Config Parameters</strong></td>
<td align="center">系统的参数配置</td>
</tr>
<tr>
<td align="center"><strong>Include Parameters</strong></td>
<td align="center">系统的功能裁剪</td>
</tr>
<tr>
<td align="center"><strong>Advanced Settings</strong></td>
<td align="center">CubeMX 生成代码预配置项</td>
</tr>
<tr>
<td align="center"><strong>User Constants</strong></td>
<td align="center">用户常量定义</td>
</tr>
</tbody></table>
<h2 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h2><img src="/images/loading.png" data-original="/2022/08/25/FreeRTOS-3/%E7%89%88%E6%9C%AC.jpg" class title="This is an image"> 

<p>CMSIS是一种接口标准，目的是屏蔽软硬件差异以提高软件的兼容性。RTOS v1使得软件能够在不同的实时操作系统下运行（屏蔽不同RTOS提供的API的差别），而RTOS v2则是拓展了RTOS v1，兼容更多的CPU架构和实时操作系统。因此我们在使用时可以根据实际情况选择，如果学习过程中使用STM32F1、F4等单片机时没必要选择RTOS v2，更高的兼容性背后时更加冗余的代码，理解起来比较困难。</p>
<h1 id="2、各配置详细设置"><a href="#2、各配置详细设置" class="headerlink" title="2、各配置详细设置"></a>2、各配置详细设置</h1><h2 id="一、Config-Parameters——系统的参数配置"><a href="#一、Config-Parameters——系统的参数配置" class="headerlink" title="一、Config Parameters——系统的参数配置"></a><strong>一、Config Parameters——系统的参数配置</strong></h2><h3 id="1-Kernel-Setting——FreeRTOS-调度内核设置"><a href="#1-Kernel-Setting——FreeRTOS-调度内核设置" class="headerlink" title="1.Kernel Setting——FreeRTOS 调度内核设置"></a>1.Kernel Setting——FreeRTOS 调度内核设置</h3><p>由于一些重要配置已在<a href="https://dhkkk.gitee.io/2022/08/18/FreeRTOS-1/">FreeRTOS_基本框架 | 小董的BLOG (gitee.io)</a>中讲到，因此本文只会记录一些容易搞混的地方</p>
<ul>
<li><p><strong>USE_PREEMPTION</strong></p>
<p>USE_PREEMPTION 是 RTOS 的调度方式选择，为 1 时使用抢占式调度器，为 0 时使用协程。</p>
<p>当使用协程的话会在如下地方进行任务切换：</p>
<ol>
<li>一个任务调用了函数 taskYIELD()。</li>
<li>一个任务调用了可以使任务进入阻塞态的 API 函数。</li>
<li>应用程序明确定义了在中断中执行上下文切换。</li>
</ol>
</li>
</ul>
<ul>
<li><p><strong>USE_MUTEXES、USE_RECURSIVE_MUTEXES、USE_COUNTING_SEMAPHORES</strong></p>
<p>为 1 则开启系统构建过程中的互斥量、递归互斥量和信号量,默认开启就可。</p>
</li>
<li><p><strong>QUEUE_REGISTRY_SIZE</strong></p>
<p>队列注册表的大小，可以用于管理队列名称和队列实体，方便运行中进行查看与管理，默认为8</p>
</li>
<li><p><strong>ENABLE_BACKWARD_COMPATIBILITY</strong></p>
<p>一个兼容性使能，使能后， FreeRTOS 8.0.0 之后的版本可以通过宏定义使用 8.0.0 版本之前的函数接口，默认使能</p>
</li>
<li><p><strong>USE_TASK_NOTIFICATIONS</strong></p>
<p>任务通知使能，每个RTOS任务都有一个32位的通知值，RTOS任务通知是一个直接发送给任务的事件，它可以解除接收任务的阻塞，并可选地更新接收任务的通知值，为1开启，为0关闭，关闭可以为每个任务节省8个字节的内存空间</p>
</li>
<li><p><strong>RECORD_STACK_HIGH_ADDRESS</strong></p>
<p>记录任务的堆栈入口地址到TCB，为1使能，为0关闭</p>
</li>
</ul>
<h3 id="2-Memory-management-setting——内存管理设置"><a href="#2-Memory-management-setting——内存管理设置" class="headerlink" title="2.Memory management setting——内存管理设置"></a><strong>2.Memory management setting</strong>——内存管理设置</h3><p>视情况调整即可，内存分配方式默认heap_4，方便完善。</p>
<h3 id="3-Hook-function-relateed-difinitions——钩子函数配置"><a href="#3-Hook-function-relateed-difinitions——钩子函数配置" class="headerlink" title="3.Hook function relateed difinitions——钩子函数配置"></a>3.Hook function relateed difinitions——钩子函数配置</h3><p><strong>钩子函数是一种回调函数，用于在任务执行一次之后或者某些事件发生后执行的函数</strong>，该配置项里面有五个选项，控制5种不同功能的钩子函数开启，当然用户也可以在代码中自己定义</p>
<ul>
<li><p><strong>USE_IDLE_HOOK</strong></p>
<p>每当空闲任务执行一次，钩子函数都会被执行一次</p>
</li>
</ul>
<ul>
<li><p><strong>USE_TICK_HOOK</strong></p>
<p>每个TICK周期，钩子函数都会执行一次</p>
</li>
<li><p><strong>USE_MALLOC_FAILED_HOOK</strong></p>
<p>当申请动态内存失败时，钩子函数会执行一次(需要额外配置申请动态内存失败的相关事项)</p>
</li>
</ul>
<ul>
<li><p><strong>USE_DAEMON_TASK_STARTUP_HOOK</strong></p>
<p>任务刚启动时，钩子函数会执行一次</p>
</li>
<li><p><strong>CHECK_FOR_STACK_OVERFLOW</strong></p>
<p>任务栈溢出时，钩子函数会执行一次，传入任务 TCB 和任务名称（也需要额外配置）</p>
</li>
</ul>
<h3 id="4-Run-time-and-task-stats…-——任务运行追踪配置"><a href="#4-Run-time-and-task-stats…-——任务运行追踪配置" class="headerlink" title="4.Run time and task stats… ——任务运行追踪配置"></a>4.Run time and task stats… ——任务运行追踪配置</h3><ul>
<li><p><strong>GENERATE_RUN_TIME_STATS</strong></p>
<p>开启时间统计功能，在调用 vTaskGetRunTimeStats() 函数时，<strong>将任务运行时间信息保存到可读列表中</strong></p>
</li>
<li><p><strong>USE_TRACE_FACILITY</strong></p>
<p>使能后会包含额外的结构成员和函数以帮助执行可视化和跟踪，<strong>默认开启，方便 MDK 软件工具调试使用</strong></p>
</li>
<li><p><strong>USE_STATS_FORMATTING_FUNCTIONS</strong></p>
<p>使能后会<strong>生成 vTaskList() 和 vTaskGetRunTimeStats() 函数用于获取任务运行状态</strong></p>
</li>
</ul>
<h3 id="5-Co-routine-ralated-definitions——协程配置"><a href="#5-Co-routine-ralated-definitions——协程配置" class="headerlink" title="5.Co-routine ralated definitions——协程配置"></a>5.Co-routine ralated definitions——协程配置</h3><p>默认不开启，协程现在几乎很少使用且FreeRTOS不再更新和维护协程。</p>
<h3 id="6-Software-timer-definitions——软件定时器配置"><a href="#6-Software-timer-definitions——软件定时器配置" class="headerlink" title="6.Software timer definitions——软件定时器配置"></a>6.Software timer definitions——软件定时器配置</h3><p>默认即可。</p>
<h3 id="7-Interrupt-nesting-behavior-configuration——优先级配置"><a href="#7-Interrupt-nesting-behavior-configuration——优先级配置" class="headerlink" title="7.Interrupt nesting behavior configuration——优先级配置"></a>7.Interrupt nesting behavior configuration——优先级配置</h3><p>具体参数在<a href="https://dhkkk.gitee.io/2022/08/18/FreeRTOS-1/">FreeRTOS_基本框架 | 小董的BLOG (gitee.io)</a>已有详细描述，不再赘述。</p>
<h2 id="二、Include-Parameters——系统的功能裁剪"><a href="#二、Include-Parameters——系统的功能裁剪" class="headerlink" title="二、Include Parameters——系统的功能裁剪"></a><strong>二、Include Parameters</strong>——系统的功能裁剪</h2><p>Include Parameters 下的选项应用于内核裁剪，裁剪不必要的功能，精简系统功能，减少资源占用</p>
<table>
<thead>
<tr>
<th align="center"><strong>选项</strong></th>
<th align="center"><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">vTaskPrioritySet</td>
<td align="center">改变某个任务的任务优先级</td>
</tr>
<tr>
<td align="center">uxTaskPriorityGet</td>
<td align="center">查询某个任务的优先级</td>
</tr>
<tr>
<td align="center">vTaskDelete</td>
<td align="center">删除任务</td>
</tr>
<tr>
<td align="center">vTaskCleanUpResources</td>
<td align="center">回收任务删除后的资源如RAM等等</td>
</tr>
<tr>
<td align="center">vTaskSuspend</td>
<td align="center">挂起任务</td>
</tr>
<tr>
<td align="center">vTaskDelayUntil</td>
<td align="center">阻塞延时一段绝对时间</td>
</tr>
<tr>
<td align="center">vTaskDelay</td>
<td align="center">阻塞延时一段相对时间</td>
</tr>
<tr>
<td align="center">xTaskGetSchedulerState</td>
<td align="center">获取任务调度器的状态，开启或未开启</td>
</tr>
<tr>
<td align="center">xTaskResumeFromISR</td>
<td align="center">在中断服务函数中恢复一个任务的运行</td>
</tr>
<tr>
<td align="center">xQueueGetMutexHolder</td>
<td align="center">获取信号量的队列拥有者，返回拥有此信号量的队列</td>
</tr>
<tr>
<td align="center">xSemaphoreGetMutexHolder</td>
<td align="center">查询拥有互斥锁的任务，返回任务控制块</td>
</tr>
<tr>
<td align="center">pcTaskGetTaskName</td>
<td align="center">获取任务名称</td>
</tr>
<tr>
<td align="center">uxTaskGetStackHighWaterMark</td>
<td align="center">获取任务的堆栈的历史剩余最小值</td>
</tr>
<tr>
<td align="center">xTaskGetCurrentTaskHandle</td>
<td align="center">此函数用于获取当前任务的任务句柄</td>
</tr>
<tr>
<td align="center">eTaskGetState</td>
<td align="center">此函数用于查询某个任务的运行壮态</td>
</tr>
<tr>
<td align="center">xEventGroupSetBitFromISR</td>
<td align="center">在中断服务函数中将指定的事件位清零</td>
</tr>
<tr>
<td align="center">xTimerPendFunctionCall</td>
<td align="center">定时器守护任务的回调函数（定时器守护任务使用到一个命令队列，只要向队列发送信号就可以执行相应代码，可以实现“中断推迟处理”功能）</td>
</tr>
<tr>
<td align="center">xTaskAbortDelay</td>
<td align="center">中止延时函数，该函数能立即解除任务的阻塞状态，将任务插入就绪列表中</td>
</tr>
<tr>
<td align="center">xTaskGetHandle</td>
<td align="center">此函数根据任务名字获取的任务句柄</td>
</tr>
</tbody></table>
<h2 id="三、Tasks-and-Queues——创建任务与队列"><a href="#三、Tasks-and-Queues——创建任务与队列" class="headerlink" title="三、Tasks and Queues——创建任务与队列"></a><strong>三、Tasks and Queues</strong>——创建任务与队列</h2><h3 id="1-任务创建"><a href="#1-任务创建" class="headerlink" title="1.任务创建"></a>1.任务创建</h3><img src="/images/loading.png" data-original="/2022/08/25/FreeRTOS-3/freertos_taskadd.jpg" class title="This is an image"> 

<p>具体内容已在<a href="https://dhkkk.gitee.io/2022/08/23/FreeRTOS-2/">FreeRTOS的任务相关 | 小董的BLOG (gitee.io)</a>中讲到，需要注意的是：</p>
<ul>
<li><p>Task Name为任务<strong>名称</strong>，Entry Function才是任务实体，即运行的<strong>任务函数入口</strong>（函数名）</p>
</li>
<li><p>任务的优先级细分有各等级优先级，详见文章最后对于优先级问题的理解</p>
</li>
<li><p>Code Generation为代码生成模式，细分为</p>
<ul>
<li>As weak： 产生一个用 __weak 修饰的弱定义任务函数，用户可自己再进行定义</li>
<li>As external： 产生一个外部引用的任务函数，用户需要自己定义该函数</li>
<li>Default： 产生一个默认格式的任务函数，用户需要在该函数内实现自己的功能</li>
</ul>
<p>一般使用默认格式即可</p>
</li>
<li><p>Allocation为定义内存分配方式，分为静态与动态，与c语言中static用法类似</p>
</li>
</ul>
<h4 id="CubeMX-提供的一些用户调用函数"><a href="#CubeMX-提供的一些用户调用函数" class="headerlink" title="CubeMX 提供的一些用户调用函数"></a>CubeMX 提供的一些用户调用函数</h4><table>
<thead>
<tr>
<th align="center"><strong>函数</strong></th>
<th align="center"><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">osThreadNew</td>
<td align="center">创建新任务</td>
</tr>
<tr>
<td align="center">osThreadGetName</td>
<td align="center">获取任务名称</td>
</tr>
<tr>
<td align="center">osThreadGetId</td>
<td align="center">获取当前任务的控制块（TCB）</td>
</tr>
<tr>
<td align="center">osThreadGetState</td>
<td align="center">获取当前任务的运行状态</td>
</tr>
<tr>
<td align="center">osThreadGetStackSize</td>
<td align="center">获取任务的堆栈大小</td>
</tr>
<tr>
<td align="center">osThreadGetStackSpace</td>
<td align="center">获取任务剩余的堆栈大小</td>
</tr>
<tr>
<td align="center">osThreadSetPriority</td>
<td align="center">设定任务优先级</td>
</tr>
<tr>
<td align="center">osThreadGetPriority</td>
<td align="center">获取任务优先级</td>
</tr>
<tr>
<td align="center">osThreadYield</td>
<td align="center">切换控制权给下一个任务</td>
</tr>
<tr>
<td align="center">osThreadSuspend</td>
<td align="center">挂起任务</td>
</tr>
<tr>
<td align="center">osThreadResume</td>
<td align="center">恢复任务（挂起多少次恢复多少次）</td>
</tr>
<tr>
<td align="center">osThreadDetach</td>
<td align="center">分离任务，方便任务结束进行回收</td>
</tr>
<tr>
<td align="center">osThreadJoin</td>
<td align="center">等待指定的任务停止</td>
</tr>
<tr>
<td align="center">osThreadExit</td>
<td align="center">停止当前任务</td>
</tr>
<tr>
<td align="center">osThreadTerminate</td>
<td align="center">停止指定任务</td>
</tr>
<tr>
<td align="center">osThreadGetCount</td>
<td align="center">获取激活的任务数量</td>
</tr>
<tr>
<td align="center">osThreadEnumerate</td>
<td align="center">列举激活的任务</td>
</tr>
</tbody></table>
<h3 id="2-队列创建"><a href="#2-队列创建" class="headerlink" title="2.队列创建"></a>2.队列创建</h3><p>FreeRTOS中的队列是一种用于实现【任务与任务】，【任务与中断】以及【中断与任务】之间的通信机制。此外，任务从队列读数据或者写入数据到队列时，都可能被阻塞。这个特性使得任务可以被设计成基于事件驱动的运行模式，大大提高了CPU的执行效率。队列是实现FreeRTOS中其他特性的基础组件，像软件定时器，信号量，互斥锁都是基于队列而实现的。</p>
<p>在操作系统里面，直接使用全局变量传输数据十分危险，看似正常运行，但不知道啥时候就会因为寄存器或者内存等等原因引起崩溃，所以引入消息，队列的概念。</p>
<h4 id="队列的基本特性"><a href="#队列的基本特性" class="headerlink" title="队列的基本特性"></a>队列的基本特性</h4><p>队列是一种FIFO操作的数据结构，入队操作就是把一个新的元素放进队尾(tail)，出队操作就是从队头(front)取出一个元素。FreeRTOS中也支持把一个元素放到队头的操作，这个操作会<strong>覆盖</strong>之前队头的元素。</p>
<h4 id="入队策略"><a href="#入队策略" class="headerlink" title="入队策略"></a>入队策略</h4><p>队列在设计的时候，主要有两种元素入队存储策略：Queue by copy 和 Queue by reference。FreeRTOS的队列使用的是Queue by copy存储策略，考虑到这种策略实现起来更加简单，灵活，且安全。</p>
<ul>
<li>Queue by copy：数据入队的时候，队列中存储的是此数据的一份拷贝</li>
<li>Queue by reference：数据队列的时候，队列中存储的是数据的指针，而非数据本身</li>
</ul>
<h4 id="入队堵塞"><a href="#入队堵塞" class="headerlink" title="入队堵塞"></a>入队堵塞</h4><p>一个任务在尝试写入数据到队列时，可以指定一个阻塞时间，即任务在<strong>等待队列有空余空间（非满）可写前最长等待阻塞时间</strong>。当队列中有空间可写入时，任务会自动从阻塞态转换为就绪态。如果在等待时间内队列一直是满的，则等待时间到期后，任务也会自动从阻塞态转换为就绪态，但是它会返回一个写入失败的结果。</p>
<p>队列可能有多个writerTask，所以在等待队列有空闲空间时，可能会有多个任务阻塞。<strong>当队列有空闲空间可写时，调度器会从所有阻塞的任务中选取优先级最高的那个任务让其进入到就绪态</strong>。<strong>如果最高优先级的不止一个，则让等待最久的那个进入到就绪态。</strong></p>
<h4 id="出队堵塞"><a href="#出队堵塞" class="headerlink" title="出队堵塞"></a><strong>出队堵塞</strong></h4><p>一个任务在尝试从队列中读取数据时，可以指定一个阻塞时间，即任务在等待队列有元素可读前最长等待阻塞时间。当队列中有元素可读时，任务会自动从阻塞态转换为就绪态。如果在等待时间内队列一直没有数据可读，则等待时间到期后，任务也会自动从阻塞态转换为就绪态，但是它会返回一个读取失败的结果。</p>
<p>队列可能有多个reader Task，所以在等待队列有数据可读时，可能会有多个任务阻塞。<strong>当队列有数据可读时，调度器会从所有阻塞的任务中选取优先级最高的那个任务让其进入到就绪态。如果最高优先级的不止一个，则让等待最久的那个进入到就绪态。</strong></p>
<h4 id="相关API函数（非os函数，原博客中提供的os函数不适用于v1版本）（已测试，可用）"><a href="#相关API函数（非os函数，原博客中提供的os函数不适用于v1版本）（已测试，可用）" class="headerlink" title="相关API函数（非os函数，原博客中提供的os函数不适用于v1版本）（已测试，可用）"></a>相关API函数（非os函数，原博客中提供的os函数不适用于v1版本）（已测试，可用）</h4><ul>
<li><p>队列创建</p>
<p>使用xQueueCreate()内核函数来创建一个队列。队列的1存储空间从FreeRTOS heap中分配。在使用xQueueCreate()创建队列时，如果FreeRTOS heap中没有足够的存储空间分配给当前队列，则函数返回NULL。如果创建成功，则返回队列的句柄(QueueHandle_t类型)</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize );</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center"><strong>uxQueueLength</strong>：指定队列的长度，即最多可以存放的元素个数<br><strong>uxItemSize</strong>：队列中存储的元素的大小（占用的字节数）</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">返回NULL代表创建失败，没有足够的堆空间来创建当前队列；创建成功则返回队列的句柄</td>
</tr>
</tbody></table>
<ul>
<li><p>元素入队</p>
<p>使用xQueueSendToBack()函数来向队尾存放一个元素，使用xQueueSend()函数来向队首存放一个元素，两个函数用法一样</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">BaseType_t xQueueSendToBack( QueueHandle_t xQueue,<br>                                                                        const void * pvItemToQueue,<br>                                                       TickType_t xTicksToWait );</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center"><strong>xQueue</strong>：目标队列的句柄<br><strong>pvItemToQueue</strong>：入队元素的指针。队列将存储此指针指向的数据的备份<br><strong>xTicksToWait</strong>：指定等待队列有空间可以容纳新元素入队的最长等待（阻塞）时间</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">当元素成功入队时返回pdPASS，因为队列满而无法入队时返回errQUEUE_FULL（超时后）</td>
</tr>
</tbody></table>
<ul>
<li><p>元素出队</p>
<p>使用xQueueReceive()内核函数来从队列中读取队头元素，<strong>读取成功后队列将删除这个元素</strong>，实现元素出队操作。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">BaseType_t xQueueReceive( QueueHandle_t xQueue,<br>                                                  void * const pvBuffer,<br>                                              TickType_t xTicksToWait );</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center"><strong>xQueue</strong>：目标队列的句柄<br><strong>pvBuffer</strong>：用于存放读取到的队列元素的缓冲区，队列将把出队的元素拷贝到此缓冲区中<br><strong>xTicksToWait</strong>：指定等待队列有数据可读的最长等待（阻塞）时间</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">当成功从队列读取到元素时返回pdPASS，因为队列空而无法出队时返回errQUEUE_EMPTY</td>
</tr>
</tbody></table>
<ul>
<li><p>查询队列元素个数</p>
<p>使用内核函数uxQueueMessagesWaiting()来获取队列中有多少个元素</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">UBaseType_t uxQueueMessagesWaiting( QueueHandle_t xQueue );</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center"><strong>xQueue</strong>：队列的句柄</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">队列中的元素个数，返回0代表队列为空</td>
</tr>
</tbody></table>
<p>老规矩，来个按键例程（可以正常运行）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span> <span class="comment">//低优先级任务</span></span><br><span class="line">&#123;</span><br><span class="line">  BaseType_t result; </span><br><span class="line">  <span class="type">uint8_t</span> dat[]=<span class="string">&quot;666\r\n&quot;</span>;</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">	<span class="keyword">if</span>(HAL_GPIO_ReadPin(key_1_GPIO_Port,key_1_Pin == GPIO_PIN_SET))</span><br><span class="line">	&#123;</span><br><span class="line">		result= xQueueSendToBack(myQueue01Handle,dat,portMAX_DELAY);</span><br><span class="line">		<span class="keyword">if</span>(result==pdPASS)</span><br><span class="line">		&#123;</span><br><span class="line">			HAL_GPIO_WritePin(led_g_GPIO_Port,led_g_Pin,GPIO_PIN_RESET);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">   	osDelay(<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span> <span class="comment">//高优先级任务</span></span><br><span class="line">&#123;</span><br><span class="line">  BaseType_t result;</span><br><span class="line">  <span class="type">uint8_t</span> datbuf[<span class="number">10</span>]; <span class="comment">//随便定义个缓冲区就可以</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">	result=xQueueReceive(myQueue01Handle,datbuf,portMAX_DELAY);</span><br><span class="line">	<span class="keyword">if</span>(result==pdPASS)</span><br><span class="line">	&#123;</span><br><span class="line">		HAL_GPIO_WritePin(led_r_GPIO_Port,led_r_Pin,GPIO_PIN_RESET);</span><br><span class="line">	&#125;</span><br><span class="line">	osDelay(<span class="number">10</span>);</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>懒得去找os函数了，库函数挺好用的是吧😋</p>
<h2 id="四、事件-组"><a href="#四、事件-组" class="headerlink" title="四、事件(组)"></a>四、事件(组)</h2><h3 id="写在前面2022-8-27"><a href="#写在前面2022-8-27" class="headerlink" title="写在前面2022.8.27"></a>写在前面2022.8.27</h3><p><strong>目前网上对于os函数的使用教程很少，而且大部分都有问题，本小节讲到的os函数使用方法感觉BUG是真的多，搞了整整两天也无法完全实现想要的功能，而且总是一些莫名其妙的问题，感觉是与任务调度有关，但是始终没找到真正原因，人都麻了QAQ。所以本小节（事件）仅提供思路，无法保证能正常运行。（新手建议直接跳过，高手可以找找原因）</strong></p>
<p><strong>在尝试两天发现效果极差后，果断换任务通知的方法，使用起来可以说很丝滑了，第一次用就可以正常实现功能（从未如此美妙的开局！！）也基本能代替事件通知的功能，建议直接使用任务通知（见下文）</strong></p>
<p><strong>没有试过库函数，因为发现任务通知够用了，感兴趣的同学可以试一下</strong></p>
<p><em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>分割线</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>***********************</p>
<ul>
<li>先列出cubemx提供的事件组函数：</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>函数</strong></th>
<th align="center"><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">osEventFlagsNew</td>
<td align="center">创建事件标志组</td>
</tr>
<tr>
<td align="center">*osEventFlagsGetName</td>
<td align="center">获取事件标志组名称</td>
</tr>
<tr>
<td align="center">osEventFlagsSet</td>
<td align="center">设置事件标志组</td>
</tr>
<tr>
<td align="center">osEventFlagsClear</td>
<td align="center">清除事件标志组</td>
</tr>
<tr>
<td align="center">osEventFlagsGet</td>
<td align="center">获取当前事件组标志信息</td>
</tr>
<tr>
<td align="center">osEventFlagsWait</td>
<td align="center">等待事件标志组触发</td>
</tr>
<tr>
<td align="center">osEventFlagsDelete</td>
<td align="center">删除事件标志组</td>
</tr>
</tbody></table>
<h3 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h3><p><em>对于网络上的解释感觉有点晦涩难懂，自己总结了容易理解的方法，仅供参考</em></p>
<p>事件的作用主要是实现任务间通信的机制，主要用于实现多任务间的同步，但是事件类型通信只能是<strong>事件类型的通信</strong>，<strong>没有数据传输</strong></p>
<p>使用流程：</p>
<ul>
<li>在cubemx中配置相关事件句柄等</li>
<li>在程序中定义触发事件位</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> event1 1&lt;&lt;1 	<span class="comment">//事件1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> event2 1&lt;&lt;2 	<span class="comment">//事件2</span></span></span><br></pre></td></tr></table></figure>

<p>事件标志组中的所有事件位都存储在一个无符号的 EventBits_t 类型的变量（<strong>事件组</strong>）中（例如下文中的result），当 configUSE_16_BIT_TICKS 为 1 的时候事件标志组可以存储 8 个事件位，当 configUSE_16_BIT_TICKS 为 0 的时候事件标志组存储 24个事件位，每个事件位其实就是一个0或者1数字</p>
<ul>
<li>定义事件组（在触发任务和使用到等待事件函数的任务中均需定义，定义成局部变量感觉方便点）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">osStatus_t result;<span class="comment">//也可以用 EventBits_t 不过过程会麻烦一点</span></span><br></pre></td></tr></table></figure>

<p>以下是对osStatus_t的定义，方便查阅</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  osOK                      =  <span class="number">0</span>,         <span class="comment">///&lt; Operation completed successfully.</span></span><br><span class="line">  osError                   = <span class="number">-1</span>,         <span class="comment">///&lt; Unspecified RTOS error: run-time error but no other error message fits.</span></span><br><span class="line">  osErrorTimeout            = <span class="number">-2</span>,         <span class="comment">///&lt; Operation not completed within the timeout period.</span></span><br><span class="line">  osErrorResource           = <span class="number">-3</span>,         <span class="comment">///&lt; Resource not available.</span></span><br><span class="line">  osErrorParameter          = <span class="number">-4</span>,         <span class="comment">///&lt; Parameter error.</span></span><br><span class="line">  osErrorNoMemory           = <span class="number">-5</span>,         <span class="comment">///&lt; System is out of memory: it was impossible to allocate or reserve memory for the operation.</span></span><br><span class="line">  osErrorISR                = <span class="number">-6</span>,         <span class="comment">///&lt; Not allowed in ISR context: the function cannot be called from interrupt service routines.</span></span><br><span class="line">  osStatusReserved          = <span class="number">0x7FFFFFFF</span>  <span class="comment">///&lt; Prevents enum down-size compiler optimization.</span></span><br><span class="line">&#125; osStatus_t;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>设置事件标志（触发条件）</p>
<p>以按键触发为例：（可以正常运行）</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">event</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">	osStatus_t result;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(key_1_GPIO_Port,key_1_Pin)!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result = osEventFlagsSet(key_pHandle,event1);</span><br><span class="line">            <span class="keyword">if</span>(result == osOK)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;事件1触发成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;事件1触发失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(key_2_GPIO_Port,key_2_Pin)!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result = osEventFlagsSet(key_pHandle,event2);</span><br><span class="line">            <span class="keyword">if</span>(result == osOK)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;事件2触发成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;事件2触发失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>等待事件标志</li>
</ul>
<p>等待函数参数介绍：</p>
<p><code>uint32_t osEventFlagsWait (osEventFlagsId_t ef_id, uint32_t flags, uint32_t options, uint32_t timeout);</code></p>
<table>
<thead>
<tr>
<th align="center"><strong>参数</strong></th>
<th align="center"><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">ef_id</td>
<td align="center">事件标志组控制句柄</td>
</tr>
<tr>
<td align="center">flags</td>
<td align="center">等待的事件位</td>
</tr>
<tr>
<td align="center">options</td>
<td align="center">等待事件位的操作<br>osFlagsWaitAny ：等待的事件位有任意一个等到就恢复任务<br>osFlagsWaitAll：等待的事件位全部等到才恢复任务<br>osFlagsNoClear：等待成功后不清楚所等待的标志位（默认清除）</td>
</tr>
<tr>
<td align="center">timeout</td>
<td align="center">等待事件组的等待时间（等待期间任务挂起在内核对象的挂起队列）</td>
</tr>
</tbody></table>
<p>使用例子：同时等待事件1和事件2，且等待到不清除</p>
<p><strong>（该任务由于未知原因不能正常运行，仅提供思路）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait_task</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">	osStatus_t result;</span><br><span class="line">	<span class="keyword">for</span>(;;)</span><br><span class="line">	&#123;</span><br><span class="line">		result = osEventFlagsWait(myEvent01Handle,</span><br><span class="line">								  event1|event2,</span><br><span class="line">								  osFlagsWaitAll,</span><br><span class="line">								  <span class="number">10</span>);</span><br><span class="line">		<span class="keyword">if</span>(result == osOK)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="comment">//可使用阻塞、挂起等方式进入其他任务或直接在此处进行其他操作</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">		<span class="comment">//未触发等待</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、任务通知"><a href="#五、任务通知" class="headerlink" title="五、任务通知"></a>五、任务通知</h2><h3 id="写在前面-2022-8-27"><a href="#写在前面-2022-8-27" class="headerlink" title="写在前面 2022.8.27"></a>写在前面 2022.8.27</h3><p><strong>本文最开始参考的是<a href="https://blog.csdn.net/qq_45396672/article/details/120877303?ops_request_misc=%7B%22request_id%22:%22166155998716782395375007%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166155998716782395375007&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-120877303-null-null.142%5Ev42%5Econtrol,185%5Ev2%5Etag_show&utm_term=freertos"> CubeMX使用FreeRTOS编程指南_Top嵌入式的博客-CSDN博客_cubemx freertos</a>但是在实际使用的过程中可以说有很多漏洞甚至错误，本小节在参考博客中所提供的flag函数好像根本不是任务通知的函数（？）并且其所说的使用方法中连函数的入口参数都写错了，（不晓得他自己跑过自己写的程序没有😅）所以关于flag相关函数在这里仅提供函数内容，用法就不探索了，后面会讲到我实际跑过并可以使用的任务通知函数。</strong></p>
<h3 id="flag相关函数介绍"><a href="#flag相关函数介绍" class="headerlink" title="flag相关函数介绍"></a>flag相关函数介绍</h3><p>FreeRTOS 的每个任务都有一个 32 位的通知值，任务控制块中的成员变量 ulNotifiedValue 就是这个通知值。任务通知是一个事件，假如某个任务通知的接收任务因为等待任务通知而阻塞的话，向这个接收任务发送任务通知以后就会解除这个任务的阻塞状态，CubeMX内没有提供相关的配置项，但在其生成的 FreeRTOS 接口里面有相关函数进行配置。</p>
<table>
<thead>
<tr>
<th align="center"><strong>函数</strong></th>
<th align="center"><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">osThreadFlagsSet</td>
<td align="center">设置任务的通知标志</td>
</tr>
<tr>
<td align="center">osThreadFlagsClear</td>
<td align="center">清除任务通知</td>
</tr>
<tr>
<td align="center">osThreadFlagsGet</td>
<td align="center">获取任务标志</td>
</tr>
<tr>
<td align="center">osThreadFlagsWait</td>
<td align="center">等待特定的任务标志</td>
</tr>
</tbody></table>
<p><strong>常用osThreadFlagsSet，osThreadFlagsWait，使用方式与事件触发相同</strong>，不再细说，仅介绍一下函数参数</p>
<p><code>uint32_t osThreadFlagsWait (uint32_t flags, uint32_t options, uint32_t timeout);</code></p>
<p>其中options的参数：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td>osFlagsWaitAny</td>
<td>等待32位通知值任意一位触发后恢复任务（默认）</td>
</tr>
<tr>
<td>osFlagsWaitAll</td>
<td>等待指定的任务通知值全部触发后再恢复任务</td>
</tr>
<tr>
<td>osFlagsNoClear</td>
<td>恢复任务后不清除任务标志（默认清除）</td>
</tr>
</tbody></table>
<p><strong>任务通知其实个任务事件标志组使用上没有多大的区别，但他们两个的实现原理不同，同时任务通知对资源的占用更少</strong></p>
<p><strong>根据 FreeRTOS 官方的统计，使用任务通知替代二值信号量的时候任务解除阻 塞的时间要快 45%，并且需要的 RAM 也更少</strong></p>
<h3 id="可以实际使用的任务通知"><a href="#可以实际使用的任务通知" class="headerlink" title="可以实际使用的任务通知"></a>可以实际使用的任务通知</h3><p>使用前记得在cubemx配置中开启<code>USE_TASK_NOTIFICATIONS</code>和在include parameters里开启<code>eTaskGetState</code></p>
<p>FreeRTOS 提供以下几种方式发送通知给任务 ：</p>
<ul>
<li>发送通知给任务， 如果有通知未读，不覆盖通知值。</li>
<li>发送通知给任务，直接覆盖通知值。</li>
<li>发送通知给任务，设置通知值的一个或者多个位 ，可以当做事件组来使用。</li>
<li>发送通知给任务，递增通知值，可以当做计数信号量使用。</li>
</ul>
<p>通过对以上任务通知方式的合理使用，可以在一定场合下替代 FreeRTOS 的信号量，队列、事件组等。</p>
<h4 id="相关api函数："><a href="#相关api函数：" class="headerlink" title="相关api函数："></a>相关api函数：</h4><ul>
<li>向指定任务发送任务通知</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>函数</strong></th>
<th align="center"><strong>int32_t osSignalSet (osThreadId thread_id, int32_t signal)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center"><strong>thread_id：</strong> 接收通知的任务ID<br><strong>signal：</strong>任务通知值（按位操作数字）</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">错误码</td>
</tr>
</tbody></table>
<ul>
<li>等待任务通知</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>函数</strong></th>
<th align="center"><strong>osEvent osSignalWait (int32_t signals, uint32_t millisec)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center">signals： 接收完成后等待被清零的数据位(0x0001|0x0002&#x3D;0x003)<br><strong>millisec：</strong> 等待超时时间，单位为系统节拍周期</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">错误码</td>
</tr>
</tbody></table>
<h4 id="实例（按键触发任务通知，已经过验证）"><a href="#实例（按键触发任务通知，已经过验证）" class="headerlink" title="实例（按键触发任务通知，已经过验证）"></a>实例（按键触发任务通知，已经过验证）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> event1 0x0001</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span> <span class="comment">//低优先级任务</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN led_G */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">		<span class="keyword">if</span>(HAL_GPIO_ReadPin(key_1_GPIO_Port,key_1_Pin == GPIO_PIN_SET))</span><br><span class="line">		&#123;</span><br><span class="line">			osSignalSet(task2Handle,event1);</span><br><span class="line">		&#125;	</span><br><span class="line">		osDelay(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END led_G */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span> <span class="comment">//高优先级任务</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN led_B */</span></span><br><span class="line">	osEvent event;	</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">	event = osSignalWait(event1,osWaitForever);  </span><br><span class="line">	<span class="keyword">if</span>(event.status == osEventSignal)  </span><br><span class="line">	&#123;</span><br><span class="line">		HAL_GPIO_WritePin(led_g_GPIO_Port,led_g_Pin,GPIO_PIN_RESET);</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里task2可以不用额外在循环中添加堵塞，因为wait函数本身自带堵塞，<strong>其堵塞的解除是在osSignalSet函数的作用之后的瞬间，也就是说在执行完osSignalSet(task2Handle,event1)后task2会直接抢占task1</strong></p>
<p><strong>而xTask函数则是在task1执行完后才会进入task2，这点请务必记住，二者通知原理不同，使用方法因此也不同</strong></p>
<h2 id="其他的内容以后再来探索吧（指还没学到）XD"><a href="#其他的内容以后再来探索吧（指还没学到）XD" class="headerlink" title="其他的内容以后再来探索吧（指还没学到）XD"></a>其他的内容以后再来探索吧（指还没学到）XD</h2><h1 id="遇见的一些问题"><a href="#遇见的一些问题" class="headerlink" title="遇见的一些问题"></a>遇见的一些问题</h1><h2 id="一、FreeRTOS的时钟源配置"><a href="#一、FreeRTOS的时钟源配置" class="headerlink" title="一、FreeRTOS的时钟源配置"></a>一、FreeRTOS的时钟源配置</h2><p>当使用了FreeRtos的时候，建议HAL库使用除了Systick以外的时钟源。也就是说当不使用FreeRtos的时候，HAL使用的是systick作为时钟源，现在使用了rtos，不建议hal库和rtos一起使用systick作为时钟源</p>
<h2 id="二、优先级问题"><a href="#二、优先级问题" class="headerlink" title="二、优先级问题"></a>二、优先级问题</h2><img src="/images/loading.png" data-original="/2022/08/25/FreeRTOS-3/2.jpg" class title="This is an image"> 

<p>这里我自己也没太搞懂，姑且谈谈自己的理解：</p>
<p>按道理来说cortex内核对于优先级数值是越小其逻辑上的优先度就越高，其在cubemx上的大部分配置也同样符合这一原则，但是在对于任务优先级的分配上cubemx采用了上图这种low、normal等的分配方式，并且在程序中的定义数值则是优先级数值越大，逻辑优先度越高；这可能是cubemx为了方便理解做出的优化(？)</p>
<h2 id="三、阻塞问题"><a href="#三、阻塞问题" class="headerlink" title="三、阻塞问题"></a>三、阻塞问题</h2><p><strong>在程序中的阻塞函数≠正常的延时函数</strong>！！！</p>
<p>当程序执行到vTaskDelay或osdelay后会将当前任务添加到延时任务列表里，并强行切换任务。<strong>也就是说，在这段阻塞期内，只要有任务处于就绪态，就会进入该任务，若多个任务就绪，则按照优先级进行抢占。当堵塞态的任务延时到期过后会重新进入就绪态等待。</strong>并且在重新进入就绪态后任务会从阻塞之后的位置开始。</p>
<ul>
<li>任务函数内可以正常调用延时函数</li>
<li>挂起规律与阻塞规律基本一致</li>
</ul>
<h2 id="四、任务抢占问题"><a href="#四、任务抢占问题" class="headerlink" title="四、任务抢占问题"></a>四、任务抢占问题</h2><p>原先一直以为抢占式工作流程为：先运行优先级最高的任务，直至其被阻塞、挂起等；这期间运行优先级第二高的任务，直到其被阻塞、挂起等；若最高优先级此时已处于就绪态，则会在第二优先级任务进入阻塞等非运行态时进入运行态，<strong>但其实这是不对的</strong></p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">(<span class="type">void</span> *argument)</span><span class="comment">//低优先级</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN led_R */</span></span><br><span class="line">	HAL_GPIO_WritePin(led_r_GPIO_Port,led_r_Pin,GPIO_PIN_SET);</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">	HAL_GPIO_TogglePin(led_b_GPIO_Port,led_b_Pin);</span><br><span class="line">	HAL_Delay(<span class="number">5000</span>);</span><br><span class="line">    osDelay(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END led_R */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">(<span class="type">void</span> *argument)</span><span class="comment">//高优先级</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN led_B */</span></span><br><span class="line">	osStatus_t result;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">		result=osEventFlagsSet(key1_pHandle,event1);</span><br><span class="line">		<span class="keyword">if</span>(result == osOK)</span><br><span class="line">		&#123;</span><br><span class="line">			HAL_GPIO_WritePin(led_r_GPIO_Port,led_r_Pin,GPIO_PIN_RESET);</span><br><span class="line">			HAL_GPIO_WritePin(led_b_GPIO_Port,led_b_Pin,GPIO_PIN_SET);</span><br><span class="line">			HAL_GPIO_WritePin(led_g_GPIO_Port,led_g_Pin,GPIO_PIN_SET);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			HAL_GPIO_WritePin(led_b_GPIO_Port,led_b_Pin,GPIO_PIN_RESET);</span><br><span class="line">			HAL_GPIO_WritePin(led_g_GPIO_Port,led_g_Pin,GPIO_PIN_RESET);</span><br><span class="line">		&#125;</span><br><span class="line">		osDelay(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照原先的思路，程序开始，task2会优先运行，若事件设定正常，此时红灯会亮起；然后task2进入阻塞态5ms，task1进入运行态，此时按道理红灯会熄灭，蓝灯亮起5秒后，task1进入阻塞态，task2重新运行，此时红灯再亮，蓝灯灭。</p>
<p><strong>但是现实是：红灯亮起后，蓝灯只会极快地闪烁一下后红灯继续亮起，并且蓝灯闪烁的频率大概为5s左右。</strong></p>
<p>所以，真正的抢占流程应该是：程序开始，task2会优先运行，若事件设定正常，此时红灯会亮起；然后task2进入阻塞态5ms，<strong>task1进入运行态，当task1运行5ms后，task2的阻塞结束，进入就绪态，此时task1刚刚开始运行HAL_Delay(5000)，由于task2优先级更高且已经就绪，task2直接抢占并运行（此时蓝灯就会熄灭，因此蓝灯一次只亮了5ms），而不是等到task1运行osDelay(10)才会抢占</strong>；当task2再一次进入堵塞时，task1从上次被抢占的位置继续运行5ms然后被task2抢占，这样一直循环，直到HAL_Delay(5000)结束，蓝灯才会再次闪烁一次。</p>
<p>总结：高优先级的任务<strong>一旦就绪后会立刻抢占</strong>优先级低的任务,哪怕当前低优先级正在运行，而不是等到优先级低的任务进入非运行态时才抢占。</p>
]]></content>
      <tags>
        <tag>嵌入式学习</tag>
      </tags>
  </entry>
  <entry>
    <title>FreeRTOS的任务相关</title>
    <url>/2022/08/23/FreeRTOS-2/</url>
    <content><![CDATA[<h1 id="任务相关"><a href="#任务相关" class="headerlink" title="任务相关"></a>任务相关</h1><h2 id="1、RTOS调度器"><a href="#1、RTOS调度器" class="headerlink" title="1、RTOS调度器"></a>1、RTOS调度器</h2><p>在任何时刻，只有一个任务得到运行，RTOS调度器决定运行哪个任务。调度器会不断的启动、停止每一个任务，宏观看上去就像整个应用程序都在执行。作为任务，不需要对调度器的活动有所了解，在任务切入切出时保存上下文环境（寄存器值、堆栈内容）是调度器主要的职责。为了实现这点，每个任务都需要有自己的堆栈。当任务切出时，它的执行环境会被保存在该任务的堆栈中，这样当再次运行时，就能从堆栈中正确的恢复上次的运行环境。</p>
<h2 id="2、任务状态"><a href="#2、任务状态" class="headerlink" title="2、任务状态"></a>2、任务状态</h2><img src="/images/loading.png" data-original="/2022/08/23/FreeRTOS-2/%E4%BB%BB%E5%8A%A1.jpg" class title="This is an image"> 

<h2 id="3、任务例子（用户）"><a href="#3、任务例子（用户）" class="headerlink" title="3、任务例子（用户）"></a>3、任务例子（用户）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vATaskFunction</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*-- 应用程序代码放在这里. --*/</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 任务不可以从这个函数返回或退出。在较新的FreeRTOS移植包中，如果</span></span><br><span class="line"><span class="comment">    试图从一个任务中返回，将会调用configASSERT()（如果定义的话）。</span></span><br><span class="line"><span class="comment">    如果一个任务确实要退出函数，那么这个任务应调用vTaskDelete(NULL)</span></span><br><span class="line"><span class="comment">    函数，以便处理一些清理工作。*/</span></span><br><span class="line">    vTaskDelete( <span class="literal">NULL</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如步兵v2.6中底盘任务</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">chassis_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//空闲一段时间</span></span><br><span class="line">    vTaskDelay(CHASSIS_TASK_INIT_TIME);</span><br><span class="line">    <span class="comment">//底盘初始化</span></span><br><span class="line">    chassis_init(&amp;chassis_move);</span><br><span class="line">	<span class="comment">//判断遥控器在线状态</span></span><br><span class="line">    <span class="keyword">while</span> (toe_is_error(DBUSTOE))</span><br><span class="line">	&#123;</span><br><span class="line">      vTaskDelay(CHASSIS_CONTROL_TIME_MS);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//底盘循环代码</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">	  <span class="comment">//底盘模式设置</span></span><br><span class="line">      chassis_set_mode(&amp;chassis_move);</span><br><span class="line">      <span class="comment">//状态切换数据保存与处理</span></span><br><span class="line">      chassis_mode_change_control_transit(&amp;chassis_move);</span><br><span class="line">      <span class="comment">//底盘相关反馈数据更新</span></span><br><span class="line">      chassis_feedback_update(&amp;chassis_move);</span><br><span class="line">        。。。。。。。。</span><br><span class="line">	  <span class="comment">//系统延时</span></span><br><span class="line">	  vTaskDelay(CHASSIS_CONTROL_TIME_MS);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<ul>
<li><p>任务函数决不应该返回，因此通常任务函数都是一个死循环。</p>
</li>
<li><p>任务由xTaskCreate()函数创建，由vTaskDelete()函数删除。（后面会详细讲到）</p>
</li>
</ul>
<h2 id="4、空闲任务"><a href="#4、空闲任务" class="headerlink" title="4、空闲任务"></a>4、空闲任务</h2><p> 空闲任务是启动RTOS调度器时由内核自动创建的任务，这样可以确保至少有一个任务在运行。空闲任务具有最低任务优先级，这样如果有其它更高优先级的任务进入就绪态就可以立刻让出CPU。</p>
<h3 id="空闲任务钩子函数"><a href="#空闲任务钩子函数" class="headerlink" title="空闲任务钩子函数"></a>空闲任务钩子函数</h3><p>空闲任务钩子是一个函数，每一个空闲任务周期被调用一次。</p>
<ul>
<li><strong>因为FreeRTOS必须至少有一个任务处于就绪或运行状态，因此钩子函数不可以调用可能引起空闲任务阻塞的API函数（比如vTaskDelay()或者带有超时事件的队列或信号量函数）。</strong></li>
</ul>
<p>创建一个空闲钩子步骤如下：</p>
<ul>
<li><p>在FreeRTOSConfig.h头文件中设置configUSE_IDLE_HOOK为1；</p>
</li>
<li><p>定义一个函数，名字和参数原型如下所示：</p>
</li>
</ul>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vApplicationIdleHook</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure>

<p>  通常，<strong>使用这个空闲钩子函数设置CPU进入低功耗模式</strong>。</p>
<h2 id="5、任务的创建"><a href="#5、任务的创建" class="headerlink" title="5、任务的创建"></a>5、任务的创建</h2><p>任务创建和删除API函数位于文件task.c中，需要包含task.h头文件</p>
<p>具体函数定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BaseType_t xTaskCreate(</span><br><span class="line">           TaskFunction_t pvTaskCode,</span><br><span class="line">           const char * const pcName,</span><br><span class="line">           unsigned short usStackDepth,</span><br><span class="line">           void *pvParameters,</span><br><span class="line">           UBaseType_t uxPriority,</span><br><span class="line">           TaskHandle_t * pvCreatedTask</span><br><span class="line">            );</span><br><span class="line">  例：          </span><br><span class="line">    xTaskCreate( (TaskFunction_t)chassis_task,//底盘任务</span><br><span class="line">                 (const char *)&quot;chassis_task&quot;,</span><br><span class="line">                 (uint16_t)CHASSIS_STK_SIZE,</span><br><span class="line">                 (void *)NULL,</span><br><span class="line">                 (UBaseType_t)CHASSIS_TASK_PRIO,</span><br><span class="line">                 (TaskHandle_t *)&amp;CHASSISTask_Handler</span><br><span class="line">               );</span><br></pre></td></tr></table></figure>

<h3 id="参数描述"><a href="#参数描述" class="headerlink" title="参数描述"></a>参数描述</h3><ul>
<li><p>pvTaskCode：指针，指向任务函数的入口。</p>
<p>追溯到TaskFunction_t的定义可以找到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*TaskFunction_t)</span><span class="params">( <span class="type">void</span> * )</span>;</span><br></pre></td></tr></table></figure>

<p>此处涉及C语言中typedef的一个使用方法</p>
<p>​	void (<em>TaskFunction_t)( void * )意为定义了一个名为TaskFunction_t，入口参数类型为void</em>型，返回值为void型的函数指针变量；而在使用typedef后再进行TaskFunction_t  pvTaskCode的操作，则意为TaskFunction_t在这里作为类的别名，而 pvTaskCode作为类的变量。也就是说，在使用typedef后，可以将此处的TaskFunction_t理解为一个类似于int，void之类的类型</p>
<p>做个总结：此处</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*TaskFunction_t)</span><span class="params">( <span class="type">void</span> * )</span>;</span><br><span class="line">TaskFunction_t pvTaskCode;</span><br></pre></td></tr></table></figure>

<p>等同于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void (*pvTaskCode)( void * );</span><br></pre></td></tr></table></figure>

<p><strong>也就是说，pvTaskCode其实就是一个函数指针</strong></p>
<p>（此用法同步收录于“C语言学习-一些关键字-typedef-指针”一栏）</p>
</li>
<li><p>pcName：任务描述，名字。字符串的最大长度由宏configMAX_TASK_NAME_LEN指定</p>
</li>
<li><p>usStackDepth：指定任务堆栈大小，能够支持的堆栈变量数量，而<strong>不是字节数</strong>。</p>
</li>
</ul>
<ul>
<li>pvParameters：指针，当任务创建时，作为一个参数传递给任务。</li>
</ul>
<ul>
<li><p>uxPriority：任务的优先级。</p>
</li>
<li><p>pvCreatedTask：用于回传一个句柄（ID），创建任务后可以使用这个句柄引用任务</p>
</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p> 如果任务成功创建并加入就绪列表函数返回pdPASS，否则函数返回错误码，具体参见projdefs.h。</p>
<h3 id="用法（个人）"><a href="#用法（个人）" class="headerlink" title="用法（个人）"></a>用法（个人）</h3><ul>
<li>创建任务具体内容，例如上面的chassis_task</li>
<li>创建针对freertos的任务（xTaskCreate）</li>
<li>使用freertos调度任务</li>
</ul>
<h2 id="6-任务的删除"><a href="#6-任务的删除" class="headerlink" title="6.任务的删除"></a>6.任务的删除</h2><p>函数定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">( TaskHandle_t xTask )</span>;</span><br></pre></td></tr></table></figure>

<p>从RTOS内核管理器中删除一个任务。任务删除后将会从就绪、阻塞、暂停和事件列表中移除。在配置头文件中，必须定义宏INCLUDE_vTaskDelete 为1，本函数才有效。被删除的任务，其在任务创建时由内核分配的存储空间，会由空闲任务释放。如果有应用程序调用xTaskDelete()，必须保证空闲任务获取一定的微控制器处理时间。任务代码自己分配的内存是不会自动释放的，因此删除任务前，应该将这些内存释放。</p>
<h1 id="任务控制"><a href="#任务控制" class="headerlink" title="任务控制"></a>任务控制</h1><h2 id="延时（阻塞）"><a href="#延时（阻塞）" class="headerlink" title="延时（阻塞）"></a>延时（阻塞）</h2><h3 id="1-相对延时"><a href="#1-相对延时" class="headerlink" title="1.相对延时"></a>1.相对延时</h3><ul>
<li><p>void vTaskDelay( portTickType xTicksToDelay )；</p>
<p>参数描述：xTicksToDelay：延时时间总数，单位是系统时钟节拍周期</p>
</li>
</ul>
<p>vTaskDelay()指定的延时时间是从调用vTaskDelay()后开始计算的相对时间。比如vTaskDelay(100)，那么从调用vTaskDelay()后，任务进入阻塞状态，经过100个系统时钟节拍周期，任务解除阻塞。因此，vTaskDelay()并不适用与周期性执行任务的场合。因为调用vTaskDelay()到任务解除阻塞的时间不总是固定的并且该任务下一次调用vTaskDelay()函数的时间也不总是固定的（两次执行同一任务的时间间隔本身就不固定，中断或高优先级任务抢占也可能会改变每一次执行时间）。</p>
<p>在文件FreeRTOSConfig.h中，宏INCLUDE_vTaskDelay 必须设置成1，此函数才能有效。</p>
<h3 id="2-绝对延时"><a href="#2-绝对延时" class="headerlink" title="2.绝对延时"></a>2.绝对延时</h3><ul>
<li>void vTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_tx TimeIncrement );</li>
</ul>
<p>  参数描述：</p>
<ul>
<li>pxPreviousWakeTime：指针，指向一个变量，该变量保存任务最后一次解除阻塞的时间。第一次使用前，<strong>该变量必须初始化为当前时间</strong>。之后这个变量会在vTaskDelayUntil()函数内<strong>自动更新</strong>。</li>
<li>xTimeIncrement：周期循环时间。当<strong>当前时间</strong>等于pxPreviousWakeTime+xTimeIncrement时任务会解除阻塞。</li>
</ul>
<p>应当指出的是，如果指定的唤醒时间已经达到，vTaskDelayUntil()立刻返回（不会有阻塞）。因此，使用vTaskDelayUntil()周期性执行的任务，无论任何原因（比如，任务临时进入挂起状态）停止了周期性执行，使得任务少运行了一个或多个执行周期，<strong>那么需要重新计算所需要的唤醒时间</strong>。（例如任务挂起态结束后，当前的绝对时间已经超过指定的唤醒时间，vTaskDelayUntil()会立刻返回，且此时需要重新获得当前时间）这可以通过传递给函数的指针参数pxPreviousWake指向的值与当前系统时钟计数值比较来检测。<br>例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每10次系统节拍执行一次</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">vTaskFunction</span><span class="params">( <span class="type">void</span> * pvParameters )</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">static</span> portTickType xLastWakeTime;</span><br><span class="line">     <span class="type">const</span> portTickType xFrequency = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 使用当前时间初始化变量xLastWakeTime</span></span><br><span class="line">     xLastWakeTime = xTaskGetTickCount();</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">     	<span class="comment">// 需要周期性执行代码放在这里</span></span><br><span class="line">     	.........</span><br><span class="line">     	<span class="comment">//等待下一个周期</span></span><br><span class="line">         vTaskDelayUntil( &amp;xLastWakeTime,xFrequency ); </span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在文件FreeRTOSConfig.h中，宏INCLUDE_vTaskDelayUntil 必须设置成1，此函数才有效。</p>
<h2 id="获取优先级"><a href="#获取优先级" class="headerlink" title="获取优先级"></a>获取优先级</h2><ul>
<li><p>UBaseType_t uxTaskPriorityGet(TaskHandle_t xTask )；</p>
<p>参数描述：</p>
<ul>
<li>xTask：任务句柄。NULL表示获取当前任务的优先级。</li>
</ul>
</li>
</ul>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vAFunction</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line"> &#123;</span><br><span class="line">    xTaskHandle xHandle;</span><br><span class="line">    <span class="comment">// 创建另一个任务，并保存任务句柄</span></span><br><span class="line">    xTaskCreate( vTaskCode, <span class="string">&quot;NAME&quot;</span>,STACK_SIZE, <span class="literal">NULL</span>, tskIDLE_PRIORITY, &amp;xHandle );</span><br><span class="line">    <span class="comment">// 当前任务优先级比新创建的任务优先级高？</span></span><br><span class="line">    <span class="keyword">if</span>( uxTaskPriorityGet( xHandle ) &lt;uxTaskPriorityGet( <span class="literal">NULL</span> ) )</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">// 当前优先级较高</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在文件FreeRTOSConfig.h中，宏INCLUDE_vTaskPrioritySet 必须设置成1，此函数才有效。</p>
<h2 id="任务挂起"><a href="#任务挂起" class="headerlink" title="任务挂起"></a>任务挂起</h2><ul>
<li><p>void vTaskSuspend( TaskHandle_txTaskToSuspend );</p>
<p><strong>被挂起的任务绝不会得到处理器时间，不管该任务具有什么优先级。</strong></p>
<p>参数描述：</p>
<ul>
<li>xTask：任务句柄。NULL表示表示挂起当前任务。</li>
</ul>
</li>
</ul>
<p>在文件FreeRTOSConfig.h中，宏INCLUDE_vTaskSuspend必须设置成1，此函数才有效。</p>
<h2 id="解除任务挂起状态"><a href="#解除任务挂起状态" class="headerlink" title="解除任务挂起状态"></a>解除任务挂起状态</h2><ul>
<li>void vTaskResume( TaskHandle_txTaskToResume );</li>
</ul>
<p>宏INCLUDE_vTaskSuspend必须置1，此函数才有效。</p>
<h2 id="解除任务挂起状态（用于中断服务函数）"><a href="#解除任务挂起状态（用于中断服务函数）" class="headerlink" title="解除任务挂起状态（用于中断服务函数）"></a>解除任务挂起状态（用于中断服务函数）</h2><p>还在学习中，暂不记录。</p>
<h1 id="任务辅助调试类函数"><a href="#任务辅助调试类函数" class="headerlink" title="任务辅助调试类函数"></a>任务辅助调试类函数</h1><p>这类函数主要用于调试信息输出、获取任务句柄、获取任务状态、操作任务标签值等等，种类繁多，不再单独总结，具体可跳至<a href="https://freertos.blog.csdn.net/article/details/50498173">FreeRTOS任务应用函数_研究是为了理解的博客-CSDN博客</a>中讲解的很详细。</p>
]]></content>
      <tags>
        <tag>嵌入式学习</tag>
      </tags>
  </entry>
  <entry>
    <title>FreeRTOS_基本框架</title>
    <url>/2022/08/18/FreeRTOS-1/</url>
    <content><![CDATA[<h1 id="1、基础内容"><a href="#1、基础内容" class="headerlink" title="1、基础内容"></a>1、基础内容</h1><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><ul>
<li>运行态:任务正在运行的状态。如果使用的是核处理器的话那么不管在任何时刻永远都只有一个任务处于运行态。</li>
<li>就绪态：处于就绪态的任务是那些已经准备就绪（这些任务没有被阻塞或者挂起 可以运行的任务，但是处于就绪态的任务还没有运行，因为有一个同优先级或者更高优先级的任务正在运行）</li>
<li>阻塞态：如果一个任务当前正在等待某个外部事件的话就说它处于阻塞态,比如说如果某个任务调用了函数 vTaskDelay()的话就会进入阻塞态， 直到延时周期完成。（任务在等待队列、信号量、事件组、通知或互斥信号量的时候也会进入阻塞态 。<strong>任务进入阻塞态会有一个超时时间，当超过这个超时时间任务就会退出阻塞态，即使所等待的事件还没有来临</strong>）</li>
<li>挂起态：任务进入挂起态以后也不能被调度器调用进入运行态，但是进入挂起态的任务没有超时时间。</li>
</ul>
<p>需要注意的是，当任务从阻塞&#x2F;挂起态退出时是进入的就绪态而非直接进入运行态。</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><ul>
<li><p>优先级数字越<strong>低</strong>表示任务优先级越<strong>低 （除使用Cortex内核的情况！！！！！！！！！）</strong></p>
<p>例如当一个任务A正在运行，另外一个任务B(优先级高于A)阻塞时间到或者事件触发处于就绪态，那么B会从A那抢占处理器，B开始运行，A停止运行</p>
<p><strong>※※※※※当使用cortex内核时相反（例如STM32)※※※※※</strong></p>
</li>
<li><p>时间片轮转</p>
<p>当宏<code>configUSE_TIME_SLICING</code>定义为1 的时候多个任务可以共用一个优先级，数量不限。此时处于就绪态的优先级相同的任务就会使用时间片轮转调度器获取运行时间</p>
</li>
</ul>
<h2 id="任务堆栈"><a href="#任务堆栈" class="headerlink" title="任务堆栈"></a>任务堆栈</h2><p>FreeRTOS之所以能正确的恢复一个任务的运行就是因为有任务堆栈在保驾护航，任务调度器在进行任务切换的时候会将当前任务的现场 (CPU寄存器值等 )保存在此任务的任务堆栈中，等到此任务下次运行的时候就会先用堆栈中保存的值来恢复现场 ，恢复现场以后任务就会接着从上次中断的地方开始运行。</p>
<h1 id="2、机制"><a href="#2、机制" class="headerlink" title="2、机制"></a>2、机制</h1><h2 id="任务通知"><a href="#任务通知" class="headerlink" title="任务通知"></a>任务通知</h2><p>任务通知来代替信号量、消息队列、事件标志组等这些东西。使用任务通知的话效率会更高。</p>
<h2 id="STM32支持的低功耗模式"><a href="#STM32支持的低功耗模式" class="headerlink" title="STM32支持的低功耗模式"></a>STM32支持的低功耗模式</h2><ul>
<li><p>sleep睡眠模式</p>
<p>在 SLEEP 模式下，只有内核停止了工作，而外设仍然在运行。<br>在进入 SLEEP 模式后，所有中断（‘外部中断、串口中断、定时器中断等’）均可唤醒 MCU，从而退出 SLEEP 模式。</p>
</li>
<li><p>stop停止模式</p>
<p>在进入 STOP 模式后，此时 SYSTICK 也会被停掉，只有外部中断（EXTI）才能唤醒 MCU由于 RTC 中断挂在外部中断线上，所以 RTC 中断也能唤醒 MCU）</p>
</li>
<li><p>standby待机模式</p>
<p>在 STANDBY 模式下，内核、所有的时钟、以及后备 1.2V 电源全部停止工作。</p>
<p>从 STANDBY 模式中唤醒后，系统相当于执行了一次复位操作，程序会从头来过。</p>
</li>
</ul>
<h2 id="Tickless-模式"><a href="#Tickless-模式" class="headerlink" title="Tickless 模式"></a>Tickless 模式</h2><p>FreeRTOS系统提供的低功耗模式，当处理器进入空闲任务周期以后就关闭系统节拍中断(滴答定时器中断)，只有当其他中断发生或者其他任务需要处理的时侯处理器才会从低功耗模式中唤醒。</p>
<h1 id="3、一些内核配置"><a href="#3、一些内核配置" class="headerlink" title="3、一些内核配置"></a>3、一些内核配置</h1><ul>
<li><p><strong>configUSE_PREEMPTION</strong></p>
<p>为1时RTOS使用抢占式调度器，为0时RTOS使用协作式调度器（时间片）。（协作式操作系统是任务主动释放CPU后，切换到下一个任务。任务切换的时机完全取决于正在运行的任务）</p>
</li>
<li><p><strong>configUSE_PORT_OPTIMISED_TASK_SELECTION</strong></p>
<p>某些运行FreeRTOS的硬件有两种方法选择下一个要执行的任务：通用方法和特定于硬件（硬件计算前导零指令）的方法</p>
<ul>
<li>设置为0 通用办法，可以用于所有FreeRTOS支持的硬件</li>
<li>设置为1 硬件计算前导零指令，并非所有硬件都支持</li>
</ul>
</li>
<li><p><strong>configUSE_IDLE_HOOK</strong></p>
<p>设置为1使用空闲钩子（Idle Hook类似于回调函数），0忽略空闲钩子。</p>
<p>空闲任务钩子是一个函数，这个函数由用户来实现，RTOS规定了函数的名字和参数，这个函数在每个空闲任务周期都会被调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vApplicationIdleHook</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//这个钩子函数不可以调用会引起空闲任务阻塞的API函数（例如：vTaskDelay()、带有阻塞时间的队列和信号量函数</span></span><br></pre></td></tr></table></figure>

<p>使用空闲钩子函数设置CPU进入省电模式是很常见的。</p>
</li>
<li><p>configUSE_MALLOC_FAILED_HOOK</p>
<p>如果定义并正确配置malloc()失败钩子函数，则这个函数会在pvPortMalloc()函数返回NULL时被调用。只有FreeRTOS在响应内存分配请求时发现堆内存不足才会返回NULL</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vApplicationMallocFailedHook</span><span class="params">( <span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>configUSE_TICK_HOOK</strong></p>
<p>设置为1使用时间片钩子（Tick Hook），0忽略时间片钩子.</p>
<p>时间片中断可以周期性的调用一个被称为钩子函数（回调函数）的应用程序。时间片钩子函数可以很方便的实现一个定时器功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vApplicationTickHook</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"><span class="comment">//vApplicationTickHook()函数在中断服务程序中执行，因此这个函数必须非常短小，不能大量使用堆栈，只能调用以”FromISR&quot; 或 &quot;FROM_ISR”结尾的API函数。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一些顾名思义的配置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configCPU_CLOCK_HZ				( SystemCoreClock ) <span class="comment">//CPU频率</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTICK_RATE_HZ				( ( TickType_t ) 1000 ) <span class="comment">//时钟节拍频率，这里设置为1000，周期就是1ms</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_PRIORITIES			( 32 )  <span class="comment">//可使用的最大优先级</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMINIMAL_STACK_SIZE		( ( unsigned short ) 128 )<span class="comment">//空闲任务使用的堆栈大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTOTAL_HEAP_SIZE			( ( size_t ) ( 64 * 1024 ) )<span class="comment">//系统所有总的堆大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_TASK_NAME_LEN			( 16 )  <span class="comment">//任务名字字符串长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_16_BIT_TICKS			0   <span class="comment">//系统节拍计数器变量数据类型，</span></span></span><br><span class="line">                                            <span class="comment">//1表示为16位无符号整形，0表示为32位无符号整形</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>configIDLE_SHOULD_YIELD</strong></p>
<p>这个参数控制任务在空闲优先级中的行为。仅在满足下列条件后，才会起作用。</p>
<ul>
<li>使用抢占式内核调度（见第一点）</li>
<li>用户任务使用空闲优先级</li>
</ul>
<p>使用同一优先级的多个任务，且该优先级大于空闲优先级时，这些任务反映在时间片上会获得相同的处理器时间。单当多个任务（不止空闲任务，还包括用户任务）共享空闲优先级时，如果configIDLE_SHOULD_YIELD为1，当用户任务运行时，空闲任务立刻让出CPU，但是空闲任务仍然会占据时间片中的一段时间，<strong>就会导致空闲任务与接下来的用户任务会共享一个时间片，即该用户任务占有时间片少于正常分配的时间片</strong></p>
<p><strong>设置configIDLE_SHOULD_YIELD为0将阻止空闲任务为用户任务让出CPU，直到空闲任务的时间片结束。这确保所有处在空闲优先级的任务分配到相同多的处理器时间，但是，这是以分配给空闲任务更高比例的处理器时间为代价的。</strong></p>
</li>
<li><p><strong>configUSE_TASK_NOTIFICATIONS</strong>（很有用）</p>
<p>置1将会开启任务通知功能，每个RTOS任务具有一个32位的通知值，RTOS任务通知相当于直接向任务发送一个事件，接收到通知的任务可以解除任务的阻塞状态（因等待任务通知而进入阻塞状态）。相对于以前必须分别创建队列、二进制信号量、计数信号量或事件组的情况，使用任务通知显然更灵活。更好的是，相比于使用信号量解除任务阻塞，使用任务通知可以快45%</p>
</li>
<li><p><strong>configGENERATE_RUN_TIME_STATS</strong></p>
<p>设置宏configGENERATE_RUN_TIME_STATS为1使能运行时间统计功能。一旦设置为1，则下面两个宏必须被定义：</p>
<ul>
<li><p>portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()</p>
<p>使用一个比运行时间更精准的基准定时器使统计更加精确，基准定时器中断频率要比统节拍中断快10~100倍。基准定时器中断频率越快，统计越精准，但能统计的运行时间也越短（比如，基准定时器10ms中断一次，8位无符号整形变量可以计到2.55秒，但如果是1秒中断一次，8位无符号整形变量可以统计到255秒）</p>
</li>
<li><p>portGET_RUN_TIME_COUNTER_VALUE()</p>
<p>返回基准时钟的值以供计数（在定时器中使使长整形变量ulHighFrequencyTimerTicks自增）</p>
</li>
</ul>
<p>当我们配置了一个定时器中断且要使用时间统计时，需要在config.h中添加</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> ulHighFrequencyTimerTicks;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() ( ulHighFrequencyTimerTicks = 0UL )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portGET_RUN_TIME_COUNTER_VALUE() ulHighFrequencyTimerTicks</span></span><br></pre></td></tr></table></figure>

<h3 id="C语言中的0UL和1UL"><a href="#C语言中的0UL和1UL" class="headerlink" title="C语言中的0UL和1UL"></a>C语言中的0UL和1UL</h3><ul>
<li>0UL ：无符号长整型0</li>
<li>1UL ：无符号长整型1</li>
</ul>
</li>
<li><p><strong>LIBRARY_LOWEST_INTERRUPT_PRIORITY</strong> &amp; <strong>LIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY</strong>  </p>
<p>由于在使用cortex内核的硬件设备中优先级数值为越小，逻辑优先级越高，所以这里的最小优先级即为硬件的最低逻辑优先级，表现在数值上即为最大数值；而此处的configMAX_SYSCALL_INTERRUPT_PRIORITY是用来设置可以在中断服务程序中安全调用FreeRTOS API函数的最高中断优先级。优先级小于等于这个宏所代表的优先级时，程序可以在中断服务程序中安全的调用FreeRTOS API函数；如果优先级大于这个宏所代表的优先级，表示FreeRTOS无法禁止这个中断，在这个中断服务程序中绝不可以调用任何API函数。</p>
<img src="/images/loading.png" data-original="/2022/08/18/FreeRTOS-1/freertos_1.jpg" class title="This is an image"> 

<p>运行在大于configMAX_SYSCALL_INTERRUPT_PRIORITY的优先级中断是不会被RTOS内核所屏蔽的，因此也不受RTOS内核功能影响。这主要用于非常高的实时需求中。比如执行电机转向。但是，这类中断的中断服务例程中绝不可以调用FreeRTOS的API函数。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>嵌入式学习</tag>
      </tags>
  </entry>
  <entry>
    <title>一些关键字</title>
    <url>/2022/08/03/C-%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<img src="/images/loading.png" data-original="/2022/08/03/C-%E5%85%B3%E9%94%AE%E5%AD%97/%E5%85%B3%E9%94%AE%E5%AD%97.jpg" class title="This is an image"> 

<h1 id="1-auto-和-register"><a href="#1-auto-和-register" class="headerlink" title="1. auto 和 register"></a>1. auto 和 register</h1><ul>
<li><p>auto关键字</p>
<ul>
<li>只能修饰局部变量, 局部变量如果没有其它修饰符, 默认就是auto的</li>
<li>特点: 随用随开, 用完即销</li>
</ul>
</li>
<li><p>register关键字</p>
<ul>
<li>只能修饰局部变量, 原则上将内存中变量提升到CPU寄存器中存储, 这样访问速度会更快</li>
<li>但是由于CPU寄存器数量相当有限, 通常不同平台和编译器在优化阶段会自动转换为auto</li>
</ul>
</li>
</ul>
<h1 id="2-static"><a href="#2-static" class="headerlink" title="2. static"></a>2. static</h1><ul>
<li><p>对局部变量的作用</p>
<ul>
<li>延长局部变量的生命周期,从程序启动到程序退出,但是它并没有改变变量的作用域</li>
</ul>
</li>
<li><p>定义变量的代码在整个程序运行期间仅仅会执行一次</p>
<p>  <strong>原因是静态局部变量的初值是在编译时赋予的，在程序执行期间不再赋予初值</strong></p>
</li>
<li><p>对全局变量的作用</p>
<ul>
<li>默认情况下多个同名的全局变量共享一块空间, 这样会导致全局变量污染问题</li>
<li><strong>如果想让某个全局变量只在某个文件中使用, 并且不和其他文件中同名全局变量共享同一块存储空间, 那么就可以使用static</strong></li>
</ul>
</li>
</ul>
<h1 id="3-extern"><a href="#3-extern" class="headerlink" title="3. extern"></a>3. extern</h1><ul>
<li><p>对局部变量的作用(无意义的)</p>
<ul>
<li>extern不能用于局部变量</li>
<li>extern代表声明一个变量, 而不是定义一个变量, 变量只有定义才会开辟存储空间</li>
<li>所以如果是局部变量, 虽然提前声明有某个局部变量, 但是局部变量只有执行到才会分配存储空间</li>
</ul>
</li>
<li><p>对全局变量的作用</p>
<ul>
<li>声明一个全局变量, 代表告诉编译器我在其它地方定义了这个变量, 你可以放心使用。举例来说，如果文件a.c需要引用b.c中变量int v，就可以在a.c中声明extern int v，然后就可以引用变量v。</li>
</ul>
</li>
</ul>
<ul>
<li><p>与包含头文件引用函数的区别</p>
<p>对变量而言，如果你想在本源文件(例如文件名A)中使用另一个源文件(例如文件名B)的变量，<strong>方法有2种</strong>：(1)在A文件中必须用extern声明在B文件中定义的变量(当然是全局变量)；(2)在A文件中添加B文件对应的头文件，当然这个头文件包含B文件中的变量声明，也即在这个头文件中必须用extern声明该变量，否则，该变量又被定义一次。</p>
<p>对函数而言，如果你想在本源文件(例如文件名A)中使用另一个源文件(例如文件名B)的函数，<strong>方法有2种</strong>：(1)在A文件中用extern声明在B文件中定义的函数(其实，也可省略extern，只需在A文件中出现B文件定义函数原型即可)；(2)在A文件中添加B文件对应的头文件，当然这个头文件包含B文件中的函数原型，<strong>在头文件中函数可以不用加extern。</strong></p>
</li>
<li><p>总结：</p>
<p>使用extern时，会加速程序的编译（确切的说是预处理）的过程，节省时间。但是当需要对变量&#x2F;函数名进行修改时需要把所有使用extern关键字的地方全部修改一次，而使用头文件包含只需更改一次，效率更高。</p>
</li>
</ul>
<h1 id="4-条件编译"><a href="#4-条件编译" class="headerlink" title="4. 条件编译"></a>4. 条件编译</h1><ul>
<li>是将代码编译进可执行程序, 而不是执行代码</li>
<li>条件编译后面的条件表达式中<strong>不能识别变量</strong>,它里面只能识别常量和宏定义</li>
</ul>
<h1 id="5-typedef"><a href="#5-typedef" class="headerlink" title="5. typedef"></a>5. typedef</h1><ul>
<li><p>C语言不仅提供了丰富的数据类型,而且还允许由用户自己定义类型说明符,也就是说允许由用户为数据类型取“别名”。</p>
<ul>
<li><p>基本数据类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INTEGER；</span><br><span class="line"><span class="keyword">typedef</span> INTEGER MyInteger;</span><br><span class="line">MyInteger a; <span class="comment">// 等价于 int a;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> NAME[<span class="number">20</span>]; <span class="comment">// 表示NAME是字符数组类型,数组长度为20。然后可用NAME 说明变量</span></span><br><span class="line">NAME a; <span class="comment">// 等价于 char a[20];</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">&#125; PersonType;</span><br><span class="line">PersonType person;</span><br><span class="line"><span class="comment">//有多种写法，此写法可读性强一些</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个sum函数，计算a跟b的和</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span><br><span class="line">  &#123;</span><br><span class="line">      <span class="type">int</span> c = a + b;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d&quot;</span>, a, b, c);</span><br><span class="line">      <span class="keyword">return</span> c;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*MySum)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> MySum p = sum;<span class="comment">// 定义一个指向sum函数的指针变量p</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(*p)(<span class="number">1</span>,<span class="number">2</span>)); <span class="comment">//3</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细解释可参考<a href="https://dhkkk.gitee.io/2022/08/23/FreeRTOS-2/">FreeRTOS的任务相关 | 小董的BLOG (gitee.io)</a>中有详细案例</p>
<p><strong>也就是说，在正常的定义前加上typedef，即把该定义的变量改为一个新的类型，要再次定义该类型的变量时，直接使用该类型的名字即可。</strong></p>
</li>
</ul>
</li>
</ul>
<h1 id="6-const"><a href="#6-const" class="headerlink" title="6. const"></a>6. const</h1><ul>
<li>对变量声明只读特性，保护变量值以防被修改。</li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul>
<li><p>修饰常量、数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">55</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰指针</p>
<ul>
<li>const int *A; &#x2F;&#x2F;const修饰指针,A可变,A指向的值不能被修改</li>
<li>int const *A; &#x2F;&#x2F;const修饰指向的对象,A可变,A指向的对象不可变</li>
<li>int *const A; &#x2F;&#x2F;const修饰指针A, A不可变,A指向的对象可变</li>
<li>const int *const A;&#x2F;&#x2F;指针A和A指向的对象都不可变</li>
</ul>
</li>
</ul>
<h1 id="ps-以下开始不是关键字"><a href="#ps-以下开始不是关键字" class="headerlink" title="ps.以下开始不是关键字"></a>ps.以下开始不是关键字</h1><h1 id="1、宏定义"><a href="#1、宏定义" class="headerlink" title="1、宏定义"></a>1、宏定义</h1><ul>
<li><p>对程序中用<strong>双引号扩起来的字符串内的字符</strong>，不进行宏的替换操作</p>
</li>
<li><p>宏定义与变量定义不同，宏定义仅是一种机械的字符替换，并不分配内存空间</p>
</li>
<li><p>宏名的有效范围是从定义位置到文件结束。如果需要终止宏定义的作用域，可以用#undef命令</p>
</li>
<li><p>定义一个宏时可以引用已经定义的宏名</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> R  3.0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L  2*PI*R</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S  PI*R*R</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可用宏定义表示数据类型,使书写方便</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> String char *</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     String str = <span class="string">&quot;This is a string!&quot;</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C语言允许宏带有参数。在宏定义中的参数称为形式参数,在宏调用中的参数称为实际参数。(类似函数的使用)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> average(a, b) (a+b)/2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> a = average(<span class="number">10</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;平均值：%d&quot;</span>, a); <span class="comment">//7</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>带参数的宏在展开时，只作简单的字符和参数的替换，不进行任何计算操作。所以在定义宏时，<strong>一般用一个小括号</strong>括住字符串的参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> D1(a) (2*a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> D2(a) (2*(a))</span></span><br><span class="line"><span class="comment">//计算结果最好也用括号括起来,小型计算不括问题应该不大</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="type">int</span> b = D1(<span class="number">3</span>+<span class="number">4</span>);</span><br><span class="line">     <span class="type">int</span> c = D2(<span class="number">3</span>+<span class="number">4</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, b);  <span class="comment">//输出等价于2*3+4=10</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, c);  <span class="comment">//2*(3+4)=14</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="2、动态存储分配"><a href="#2、动态存储分配" class="headerlink" title="2、动态存储分配"></a>2、动态存储分配</h1><p>此前，用于存储数据的变量和数组在定义后，C编译程序通过定义的类型来了解其所需存储空间的大小并预先为其分配适当的存储空间，这些空间一经分配，在变量或数组的生存期内是固定不变的，所以这种方式也称为“静态存储分配”</p>
<p>C中还有一种“动态存储分配”的方法，在程序执行期间需要空间来存储数据时，通过申请分配指定的内存空间；当有闲置不用的空间时可以随时将其释放。C标准库提供了相关函数来进行对应操作：</p>
<h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><h3 id="malloc函数"><a href="#malloc函数" class="headerlink" title="malloc函数"></a>malloc函数</h3><table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">malloc(unsigned int size);</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center">size:字节数</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">成功则返回一个类型为void的首地址，失败为null</td>
</tr>
<tr>
<td align="center">功能</td>
<td align="center">在内存的动态存储区中分配一块长度为size字节的连续区域</td>
</tr>
</tbody></table>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用时需要包含&quot;stdlib.h&quot;或&quot;malloc.h&quot;</span></span><br><span class="line"><span class="type">int</span> *pi=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">//malloc返回值为void*型，可以强制转化为任何类型</span></span><br></pre></td></tr></table></figure>

<ul>
<li>需要注意的是，malloc只会负责分配空间。并不能对其进行初始化，所以此时*pi的值是随机的</li>
<li>该函数常用于初始化一个指针，这样可以避免使该指针成为<strong>野指针</strong></li>
</ul>
<h3 id="calloc函数"><a href="#calloc函数" class="headerlink" title="calloc函数"></a>calloc函数</h3><table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">calloc(unsigned int num,unsigned int size)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center">num:分配数据项的个数<br>size:每个数据项的大小</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">成功则返回一个类型为void的首地址，失败为null</td>
</tr>
<tr>
<td align="center">功能</td>
<td align="center">在内存的动态存储区中分配n块长度为size字节的连续区域</td>
</tr>
</tbody></table>
<ul>
<li>不同于malloc，calloc会对分配的存储单元值自动初始化为0</li>
</ul>
<p>因此，可以用以下方法开辟一个一维数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p;</span><br><span class="line">p=(<span class="type">char</span>*)<span class="built_in">calloc</span>(<span class="number">10</span>,<span class="keyword">sizeof</span>(<span class="type">char</span>));<span class="comment">//开辟一个可以存放十个字符串的数组</span></span><br></pre></td></tr></table></figure>

<h3 id="free函数"><a href="#free函数" class="headerlink" title="free函数"></a>free函数</h3><table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">free(void *ptr);</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center">一个指针</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">功能</td>
<td align="center">释放ptr所指向的一块内存空间</td>
</tr>
</tbody></table>
<ul>
<li>需要注意的是，free释放的区域应为malloc或calloc所分配的区域</li>
<li>free函数的实际功能是告诉系统输入参数对应的内存不再使用，即不再被保护，也就是说其他变量随时会占用占用那个地址。<strong>因此，原则上不再访问已经被free的的内存</strong></li>
</ul>
]]></content>
      <tags>
        <tag>C语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>结构体复习</title>
    <url>/2022/08/01/C-%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<h1 id="1-基本内容"><a href="#1-基本内容" class="headerlink" title="1.基本内容"></a>1.基本内容</h1><h2 id="几种初始化"><a href="#几种初始化" class="headerlink" title="几种初始化"></a>几种初始化</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">char</span> *name;</span><br><span class="line">     <span class="type">int</span> age;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span> =</span> &#123;“lnj<span class="string">&quot;, 27&#125;; //定义的同时按顺序初始化</span></span><br><span class="line"><span class="string">/**************************************************************************/</span></span><br><span class="line"><span class="string">struct Student stu = &#123;.age = 35, .name = “lnj&quot;</span>&#125;;<span class="comment">//定义的同时不按顺序初始化</span></span><br><span class="line"><span class="comment">/**************************************************************************/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span>;</span></span><br><span class="line">stu.name = <span class="string">&quot;lnj&quot;</span>;</span><br><span class="line">stu.age = <span class="number">35</span>;  <span class="comment">//先定义后逐个初始化</span></span><br><span class="line"><span class="comment">/**************************************************************************/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span>;</span></span><br><span class="line">stu = (<span class="keyword">struct</span> Student)&#123;<span class="string">&quot;lnj&quot;</span>, <span class="number">35</span>&#125;;    <span class="comment">// 先定义后,再一次性初始化   </span></span><br></pre></td></tr></table></figure>

<h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Student </span><br><span class="line">&#123;</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line">struct Student stu[2]; </span><br><span class="line">stu[0] = &#123;&quot;lnj&quot;, 35&#125;;</span><br><span class="line">stu[1] = &#123;&quot;zs&quot;, 18&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     <span class="comment">// 定义一个结构体类型</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> </span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">         <span class="type">char</span> *name;</span><br><span class="line">         <span class="type">int</span> age;</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个结构体变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span> =</span> &#123;“lnj<span class="string">&quot;, 18&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 定义一个指向结构体的指针变量</span></span><br><span class="line"><span class="string">    struct Student *p;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   // 指向结构体变量stu</span></span><br><span class="line"><span class="string">   p = &amp;stu;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /*</span></span><br><span class="line"><span class="string">     这时候可以用3种方式访问结构体的成员</span></span><br><span class="line"><span class="string">     */</span></span><br><span class="line"><span class="string">    // 方式1：结构体变量名.成员名</span></span><br><span class="line"><span class="string">    printf(&quot;</span>name=%s, age = %d \n<span class="string">&quot;, stu.name, stu.age);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 方式2：(*指针变量名).成员名</span></span><br><span class="line"><span class="string">    printf(&quot;</span>name=%s, age = %d \n<span class="string">&quot;, (*p).name, (*p).age);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 方式3：指针变量名-&gt;成员名</span></span><br><span class="line"><span class="string">    printf(&quot;</span>name=%s, age = %d \n<span class="string">&quot;, p-&gt;name, p-&gt;age);</span></span><br><span class="line"><span class="string">  //-&gt;运算符只用于指针结构体</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="结构体嵌套"><a href="#结构体嵌套" class="headerlink" title="结构体嵌套"></a>结构体嵌套</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span>&#123;</span></span><br><span class="line">     <span class="type">int</span> month;</span><br><span class="line">     <span class="type">int</span> day;</span><br><span class="line">     <span class="type">int</span> year;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">stu</span>&#123;</span></span><br><span class="line">     <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Date</span> <span class="title">birthday</span>;</span></span><br><span class="line">    Float score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>成员访问</p>
<p>如果某个成员也是结构体变量，可以连续使用成员运算符”.”访问最低一级成员。</p>
</li>
</ul>
<h1 id="2-内存分析"><a href="#2-内存分析" class="headerlink" title="2.内存分析"></a>2.内存分析</h1><ul>
<li><p>结构体变量占用的内存空间永远是所有成员中占用内存最大成员的倍数(对齐问题)</p>
<p>这种强制的要求一来简化了处理器与内存之间传输系统的设计,二来可以提升读取数据的速度。比如这么一种处理器,它每次读写内存的时候都从某个8倍数的地址开始,一次读出或写入8个字节的数据,假如软件能 保证double类型的数据都从8倍数地址开始,那么读或写一个double类型数据就只需要一次内存操作。否则,我们就可能需要两次内存操作才能完成这个动作,因为数据或许恰好横跨在两个符合对齐要求的8字节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">int</span> age; <span class="comment">// 4</span></span><br><span class="line">   <span class="type">char</span> ch; <span class="comment">// 1</span></span><br><span class="line">   <span class="type">double</span> score; <span class="comment">// 8</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p</span>;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof = %i\n&quot;</span>, <span class="keyword">sizeof</span>(p)); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure>

<ul>
<li>占用内存最大属性是score, 占8个字节, 所以第一次会分配8个字节</li>
<li>将第一次分配的8个字节分配给age4个,分配给ch1个, 还剩下3个字节</li>
<li>当需要分配给score时, 发现只剩下3个字节, 所以会再次开辟8个字节存储空间</li>
<li>一共开辟了两次8个字节空间, 所以最终p占用16个字节</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> age; <span class="comment">// 4</span></span><br><span class="line">  <span class="type">double</span> score; <span class="comment">// 8</span></span><br><span class="line">  <span class="type">char</span> ch; <span class="comment">// 1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p</span>;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof = %i\n&quot;</span>, <span class="keyword">sizeof</span>(p)); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure>

<ul>
<li>占用内存最大属性是score, 占8个字节, 所以第一次会分配8个字节</li>
<li>将第一次分配的8个字节分配给age4个,还剩下4个字节</li>
<li>当需要分配给score时, 发现只剩下4个字节, 所以会再次开辟8个字节存储空间<br>将新分配的8个字节分配给score, 还剩下0个字节</li>
<li>当需要分配给ch时, 发现上一次分配的已经没有了, 所以会再次开辟8个字节存储空间<br>一共开辟了3次8个字节空间, 所以最终p占用24个字节</li>
</ul>
</li>
</ul>
<p><strong>需要注意的是，对占用内存最大的变量的判断仅限基本类型，同时不包括数组，也就是说当一个结构体同时包括</strong></p>
<p><strong><code>chara[5];int b;</code>时仍然用int的大小计算。</strong></p>
<h1 id="3-结构体之间赋值"><a href="#3-结构体之间赋值" class="headerlink" title="3.结构体之间赋值"></a>3.结构体之间赋值</h1><ul>
<li><p>结构体虽然是构造类型, <strong>但是结构体之间赋值是值拷贝, 而不是地址传递</strong>。所以结构体变量作为函数形参时也是值传递, <strong>在函数内修改形参, 不会影响外界实参</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">struct</span> Person per)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span> =</span> &#123;<span class="string">&quot;lnj&quot;</span>, <span class="number">35</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p1.name = %s\n&quot;</span>, p1.name); <span class="comment">// lnj</span></span><br><span class="line">    test(p1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p1.name = %s\n&quot;</span>, p1.name); <span class="comment">// lnj</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">struct</span> Person per)</span></span><br><span class="line">&#123;</span><br><span class="line">    per.name = <span class="string">&quot;zs&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h1><ul>
<li><p>和结构体不同的是, 结构体的每个成员都是占用一块独立的存储空间, 而共用体<strong>所有的成员都占用同一块存储空间，因此所有成员的地址都是相同的</strong></p>
</li>
<li><p>特点: 由于所有属性共享同一块内存空间, <strong>所以只要其中一个属性发生了改变, 其它的属性都会受到影响</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Test</span> <span class="title">t</span>;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(p) = %i\n&quot;</span>, <span class="keyword">sizeof</span>(t)); <span class="comment">//4</span></span><br><span class="line">  </span><br><span class="line">t.age = <span class="number">33</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;t.age = %i\n&quot;</span>, t.age); <span class="comment">// 33</span></span><br><span class="line">t.ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;t.ch = %c\n&quot;</span>, t.ch); <span class="comment">// a</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;t.age = %i\n&quot;</span>, t.age); <span class="comment">// 97</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><ul>
<li>枚举使用的注意<ul>
<li>C语言编译器会将枚举元素(spring、summer等)作为<strong>整型常量</strong>处理，称为枚举常量。</li>
<li>枚举元素的值取决于定义时各枚举元素排列的先后顺序。默认情况下，第一个枚举元素的值为0，第二个为1，依次顺序加1。</li>
<li>也可以在定义枚举类型时改变枚举元素的值</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span> &#123;</span></span><br><span class="line">    Spring = <span class="number">9</span>,</span><br><span class="line">    Summer,</span><br><span class="line">    Autumn = <span class="number">20</span>,</span><br><span class="line">    Winter</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 也就是说spring的值为9，summer的值为10，autumn的值为20，winter的值为21</span></span><br></pre></td></tr></table></figure>

<ul>
<li>关于枚举类型的内存大小：<ul>
<li>若为没有在其中赋值的操作，默认4字节</li>
<li>若有赋值，大小取决于赋值数的类型</li>
</ul>
</li>
</ul>
<h1 id="利用结构体实现动态链表"><a href="#利用结构体实现动态链表" class="headerlink" title="利用结构体实现动态链表"></a>利用结构体实现动态链表</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">30</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;test;</span><br><span class="line"></span><br><span class="line">test *<span class="title function_">creat</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	test *linkhead,*linkend,*pt;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pt=(test*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(test));<span class="comment">//分配动态内存</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %s&quot;</span>,&amp;pt-&gt;num,pt-&gt;name);</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			linkhead=pt;<span class="comment">//第一次先将当前节点赋给链头链尾</span></span><br><span class="line">			linkend=pt;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//若不是第一次，先将当前节点存入上一个节点的next中，再将linkend更新为当前节点以供下一次访问</span></span><br><span class="line">		&#123;                                                                <span class="comment">//当前节点的next</span></span><br><span class="line">			linkend-&gt;next=pt;</span><br><span class="line">			linkend=pt;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	linkend-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> linkhead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">destroy</span><span class="params">(test *linkHead)</span></span><br><span class="line">&#123;</span><br><span class="line">	test *p;</span><br><span class="line">	p=linkHead; </span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		linkHead=linkHead-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;clear\n&quot;</span>);</span><br><span class="line">		p=linkHead;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	test *LH，*Free_item;</span><br><span class="line">	LH=creat();</span><br><span class="line">   Free_item=LH;</span><br><span class="line">	<span class="keyword">while</span>(LH!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;NUM:%d   NAME:%s\n&quot;</span>,LH-&gt;num,LH-&gt;name);</span><br><span class="line">		LH=LH-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	destroy(Free_item);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>以下解释存在一定问题，我修改后的内容以及写在下一节！！！</strong></p>
<ul>
<li><p><em>注：其实这里最开始打印也应该单独写个函数，但是由于我懒得去写了，因此直接在main中操作参数，并且在操作完后我意识到好像无法再以LH为参数去使用destroy函数，按照一般地址与指针的理解，在打印完成过后应该已经改变了在creat()函数中分配的内存所对应的值，但是我抱着尝试的心理用main中的Free_item作为参数使用destroy函数竟然成功了，这一度让我以为我在指针的学习中是不是疏忽了什么重要内容！之后自己以简单的函数间的指针交互写了一些程序发现自己的理解好像也并没有什么问题，最后，在以”形参”为关键字搜索我的个人博客后终于找到如下一段话：</em></p>
<p><em>“结构体虽然是构造类型, 但是结构体之间赋值是值拷贝, 而不是地址传递。所以结构体变量作为函数形参时也是值传递, 在函数内修改形参, 不会影响外界实参。”（完全忘记了捏😋，所以要多多复习原来的内容！！）</em></p>
<p><em>因此LH也只是拷贝了creat函数所创建的linkhead的值而已，对LH的任何操作都不会影响creat函数所创建的linkhead的值，而Free_item拷贝的也是LH改变前的值，因此LH的改变也不会影响Free_item的内容。</em></p>
</li>
</ul>
<h2 id="2022-11-17改"><a href="#2022-11-17改" class="headerlink" title="2022.11.17改"></a>2022.11.17改</h2><p>因为最近又在学习FreeRTOS的相关内容，再次复习了一下链表的相关原理，顺便又读了一下上面写的内容，发现对于上一节最后这里的解释好像并不正确，因为当时是按照结构体赋值解释的，<strong>但是在这个链表程序中，传递的内容明显是地址而不是值！</strong>于是我再次查阅了结构指针的相关文献，解释如下：</p>
<p><strong>我们一步一步来捋一下</strong>：</p>
<h3 id="①creat函数"><a href="#①creat函数" class="headerlink" title="①creat函数"></a>①creat函数</h3><p>首先我们可以确定，在这个链表程序中的所有test类型变量均为指针变量，也就是说，在creat()函数中:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">test *<span class="title function_">creat</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	test *linkhead,*linkend,*pt;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pt=(test*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(test));<span class="comment">//分配动态内存</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %s&quot;</span>,&amp;pt-&gt;num,pt-&gt;name);</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			linkhead=pt;<span class="comment">//第一次先将当前节点赋给链头链尾</span></span><br><span class="line">			linkend=pt;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//若不是第一次，先将当前节点存入上一个节点的next中，再将linkend更新为当前节点以供下一次访问</span></span><br><span class="line">		&#123;                                                                <span class="comment">//当前节点的next</span></span><br><span class="line">			linkend-&gt;next=pt;</span><br><span class="line">			linkend=pt;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	linkend-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> linkhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>在<code>scanf(&quot;%d %s&quot;,&amp;pt-&gt;num,pt-&gt;name);</code>中，其实是让pt这个结构体指针指向了一个整型数字和一个字符串，按照C++的说法就是<strong>直接使指针指向了两个字符值常量。</strong></li>
<li>在三次循环中，分别开辟了三个动态内存区域。</li>
<li>creat函数返回的也是一个结构体指针</li>
</ul>
<h3 id="②main-函数"><a href="#②main-函数" class="headerlink" title="②main()函数"></a>②main()函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	test *LH，*Free_item;</span><br><span class="line">	LH=creat();</span><br><span class="line">   Free_item=LH;</span><br><span class="line">	<span class="keyword">while</span>(LH!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;NUM:%d   NAME:%s\n&quot;</span>,LH-&gt;num,LH-&gt;name);</span><br><span class="line">		LH=LH-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	destroy(Free_item);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>creat函数返回的指针<strong>赋值</strong>给结构体指针LH，并且在这里，所有的指针都不是二重指针，因此，creat的返回值linkhead的成员num和name都是直接指向的字符值常量，<strong>因此LH也通过linkhead直接指向这两个成员，而不是LH指向linkhead这个指针变量的地址</strong>，可以理解为linkhead和LH是并列的，没有先后顺序的。</li>
<li>下一步的<code>Free_item=LH;</code>也是同理，字面意义是Free_item指向了LH的地址，但是实际上Free_item也是直接指向的动态内存中的字符值常量，因为Free_item是一个一重指针，<strong>它不具有保存另一个指针变量地址的功能，所以它会通过LH直接指向动态内存</strong></li>
<li>综上，实际上Free_item和LH也是并列关系，因此循环中LH的指向的改变不会影响到Free_item的指向，即使LH已经指向null，Free_item也还是指向的链头。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实说到底，是我自己对指针理解一直存在的误区，例如如下例程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> *p1,*p2;</span><br><span class="line">	p1=&amp;a;</span><br><span class="line">	p2=p1;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,p1,&amp;p1,p2,&amp;a); <span class="comment">//6422036 6422024 6422036 6422036</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我之前一直认为一个指针指向另一个指针，该指针的便会指向另一个指针变量自己的地址，<strong>但实际上，一重指针并不具有保存另一个指针变量地址的功能，所以该指针会直接指向另一个指针指向的内容。</strong></p>
<p>就像上述例程中,p1指向整型变量a的地址，再将p1赋值给p2，但打印结果中p2指向的地址是a的地址(&amp;a)，而不是p1本身的地址（&amp;p1)。</p>
<p>这也从另一方面说明了二重指针的一些重要性吧。</p>
]]></content>
      <tags>
        <tag>C语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>指针相关复习</title>
    <url>/2022/07/31/C-%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="1-基本内容"><a href="#1-基本内容" class="headerlink" title="1.基本内容"></a>1.基本内容</h1><h2 id="什么是指针"><a href="#什么是指针" class="headerlink" title="什么是指针"></a>什么是指针</h2><ul>
<li>在计算机中所有数据都存储在内存单元中,而每个内存单元都有一个对应的地址, 只要通过这个地址就能找到对应单元中存储的数据.</li>
<li>由于通过地址能找到所需的变量单元，所以我们说该地址指向了该变量单元。将地址形象化的称为“指针”</li>
<li>内存单元的指针(地址)和内存单元的内容是两个不同的概念。</li>
</ul>
<h2 id="什么是指针变量"><a href="#什么是指针变量" class="headerlink" title="什么是指针变量"></a>什么是指针变量</h2><p>在C语言中,允许用一个变量来存放其它变量的地址, 这种专门用于存储其它变量地址的变量, 我们称之为指针变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> *p; <span class="comment">// 一个用于指向字符型变量的指针</span></span><br><span class="line">p = &amp;ch; </span><br></pre></td></tr></table></figure>

<p>*表示这是一个指针变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p =  <span class="number">250</span>; <span class="comment">// 错误写法</span></span><br><span class="line"><span class="comment">/****************************/</span></span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">*p=&amp;a; <span class="comment">//错误写法</span></span><br></pre></td></tr></table></figure>

<ul>
<li>多个指针变量可以指向同一个地址。</li>
</ul>
<h3 id="对指针变量的理解"><a href="#对指针变量的理解" class="headerlink" title="对指针变量的理解"></a>对指针变量的理解</h3><p>指针变量本身的作用是储存一个用户定义的变量的地址，但是其本身作为一个额外的变量，也有自己的地址，<strong>且这个地址不等于其储存的变量的地址；</strong></p>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> *c;</span><br><span class="line">    c=&amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;指针变量c自身的地址为：%d&quot;</span>,&amp;c);<span class="comment">//6487568 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;指针变量c存储单元内存储的内容(也就是a的地址)为：%d&quot;</span>,c);<span class="comment">//6487576</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;变量a的地址为：%d&quot;</span>,a);<span class="comment">//6487576</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  c代表c内存放的地址</span></span><br><span class="line"><span class="comment">//  &amp;c代表c自身的地址</span></span><br><span class="line"><span class="comment">//  *c代表c内存放的地址中所存储的值</span></span><br><span class="line"><span class="comment">// (c+1)代表c内存放的地址+1*类型长度</span></span><br><span class="line"><span class="comment">// *c+1代表c内存放的地址中所存储的值本身+1</span></span><br><span class="line"><span class="comment">// *(c+1)代表c内存放的地址+1*类型长度后得到的地址中存储的值</span></span><br></pre></td></tr></table></figure>

<h2 id="取地址运算符（-amp-）与解引用运算符（-）"><a href="#取地址运算符（-amp-）与解引用运算符（-）" class="headerlink" title="取地址运算符（&amp;）与解引用运算符（*）"></a>取地址运算符（&amp;）与解引用运算符（*）</h2><ul>
<li><p>取地址运算符：&amp;x，其作用为返回操作对象的地址</p>
</li>
<li><p>解引用运算符：<code>*x</code>，其作用是<strong>返回x中存储的地址内存储的值</strong></p>
<p>例： <code>int a,*p1;p1=&amp;a;</code><strong>则此时*p1代表的就是变量a的内容,而不是a的地址</strong></p>
<p>这也就是为什么使用<code>printf(&quot;%d&quot;,*p);</code>时是用*p而不是p了，因为 *p才是代表a的值，p则存储的变量a的地址</p>
<p><strong>综上：除开定义时，其余时间*p等同a，p等同&amp;a</strong></p>
<p>在定义时，<code>int *p1=&amp;a;</code>也是合法的且作用与上相同，个人理解为是一种指针格式的“声明”（？）这也解释了当某个函数参数定义为为<code>int *a</code>时实际使用时传入的也是&amp;的取地址变量了（个人理解）</p>
</li>
</ul>
<h1 id="2-一些用法"><a href="#2-一些用法" class="headerlink" title="2.一些用法"></a>2.一些用法</h1><h2 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h2><ul>
<li><p>如果一个指针变量存放的又是另一个指针变量的地址,则称这个指针变量为指向指针的指针￼变量。也称为“二级指针”。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> *cp;</span><br><span class="line">cp = &amp;c;</span><br><span class="line"><span class="type">char</span> **cp2;</span><br><span class="line">cp2 = &amp;cp;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c = %c&quot;</span>, **cp2);<span class="comment">//  c=a</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="指针访问数组元素"><a href="#指针访问数组元素" class="headerlink" title="指针访问数组元素"></a>指针访问数组元素</h2><ul>
<li><p>在指针指向数组元素时,允许以下运算:</p>
<ul>
<li>加一个整数(用+或+&#x3D;),如p+1</li>
<li>减一个整数(用-或-&#x3D;),如p-1</li>
<li>自加运算,如p++,++p</li>
<li>自减运算,如p–,–p</li>
</ul>
<p>如果指针变量p已指向数组中的一个元素,则p+1<code>指向</code>同一数组中的下一个元素,p-1<code>指向</code>同 一数组中的上一个元素。【*(p+1)】</p>
<p>(p+N)在地址上的变化为<code>p内存放的地址+数组元素类型长度*N</code></p>
<ul>
<li>其对p所有的基本运算均符合上述规律</li>
</ul>
</li>
</ul>
<h2 id="指针与字符串"><a href="#指针与字符串" class="headerlink" title="指针与字符串"></a>指针与字符串</h2><p>定义字符串除了使用字符数组存放之外，还可以通过字符串指针的方式指向字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组名保存的是数组第0个元素的地址, 指针也可以保存第0个元素的地址</span></span><br><span class="line"><span class="type">char</span> *str = <span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用注意事项</p>
<ul>
<li><p>此方法不可修改字符串内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用字符数组来保存的字符串是保存栈里的,保存栈里面东西是可读可写,所有可以修改字符串中的的字符</span></span><br><span class="line"><span class="comment">//使用字符指针来保存字符串,它保存的是字符串常量地址,常量区是只读的,所以我们不可以修改字符串中的字符</span></span><br><span class="line"><span class="type">char</span> *str = <span class="string">&quot;lnj&quot;</span>;</span><br><span class="line">*(str+<span class="number">2</span>) = <span class="string">&#x27;y&#x27;</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不能够直接接收键盘输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的原因是:str是一个野指针,他并没有指向某一块内存空间</span></span><br><span class="line"><span class="comment">// 所以不允许这样写如果给str分配内存空间是可以这样用 的</span></span><br><span class="line"><span class="type">char</span> *str;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="指向函数的指针"><a href="#指向函数的指针" class="headerlink" title="指向函数的指针"></a>指向函数的指针</h2><p>函数在内存中占据空间，因此也有起始地址。</p>
<p>格式：返回值类型  (*指针变量名)(形参);</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;     </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> (*p)(<span class="type">int</span> x,<span class="type">int</span> y);</span><br><span class="line">	p=sum;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(*p)(<span class="number">1</span>,<span class="number">2</span>)); <span class="comment">//打印3</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数指针有以下几点特点：</p>
<ul>
<li><p>当把一个<strong>函数名（注意是名字，不带输入参数）</strong>作为一个值使用时，该函数会自动转换成指针，指向该函数的内存地址，因此在对指针初始化时取地址符可选:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p=sum;</span><br><span class="line">p=&amp;sum;<span class="comment">//都正确</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当使用指针调用函数时，解引用也是可选的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(*p)(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p(<span class="number">1</span>,<span class="number">2</span>));<span class="comment">//都输出3</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>当函数指针作形参时：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tran</span><span class="params">(<span class="type">double</span> (*a)(<span class="type">double</span> a1),<span class="type">double</span> (*b)(<span class="type">double</span> b1),<span class="type">double</span> x)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">double</span> x=<span class="number">3.141592</span>;</span><br><span class="line">	tran(<span class="built_in">sin</span>,<span class="built_in">cos</span>,x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">tran</span><span class="params">(<span class="type">double</span>(*a)(<span class="type">double</span> a1),<span class="type">double</span>(*b)(<span class="type">double</span> b1),<span class="type">double</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,(*a)(x/<span class="number">2</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,(*b)(x/<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用函数时直接传入函数名即可。</p>
<p>同理的，也可以不声明参数为指针（因为会自动转变为指针）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tran</span><span class="params">(<span class="type">double</span> a(<span class="type">double</span> a1),<span class="type">double</span> b(<span class="type">double</span> b1),<span class="type">double</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,(*a)(x/<span class="number">2</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,(*b)(x/<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="通过形参影响实参"><a href="#通过形参影响实参" class="headerlink" title="通过形参影响实参"></a>通过形参影响实参</h2><p>我们都知道，形参值的改变不能改变对应实参的值，把数据从被调用函数返回到调用函数的唯一途径时通过return。<strong>但如果通过传送地址给被调用函数，再在被调用函数中改变地址中存储的值，也就使通过形参改变对应实参的值成为了可能。</strong></p>
<p>例如：交换值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c; <span class="comment">// 因为c只是用来存放地址内保存的值，所以为一般变量</span></span><br><span class="line">    c=*x;*x=*y;*y=c;  <span class="comment">//将a、b地址中保存的值互换、地址不变</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">    swap(&amp;a,&amp;b);<span class="comment">//将a、b的地址传给形参x、y，此时指针变量x、y内保存的就是a、b的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  %d&quot;</span>,a,b);<span class="comment">//此时a、b地址内保存的值已经互换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但如果swap函数定义成如下，又会怎么样呢</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *c; </span><br><span class="line">    c=x;x=y;y=c;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这样定义函数，则程序的流程为：<strong>①调用swap函数时，x内保存的为a的地址，y内保存的为b的地址；②在swap函数中，x内保存的地址改变为b的地址，y内保存的地址改变为为a的地址；③swap函数调用结束，x，y的内存被释放；④此时a、b变量自身的地址并没有任何改变，改变的只用形参x、y所保存的地址，因此无法起到交换作用</strong></p>
<h2 id="二维数组地址详解-数组指针-重要！！！！！"><a href="#二维数组地址详解-数组指针-重要！！！！！" class="headerlink" title="二维数组地址详解+数组指针(重要！！！！！)"></a>二维数组地址详解+数组指针(重要！！！！！)</h2><p>详见<a href="https://dhkkk.gitee.io/2022/07/28/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/">二维数组复习 | 小董的BLOG (gitee.io)</a></p>
<h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><p>详见<a href="https://dhkkk.gitee.io/2022/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/">数据结构_链表 | 小董的BLOG (gitee.io)</a>和<a href="https://dhkkk.gitee.io/2022/08/01/C-%E7%BB%93%E6%9E%84%E4%BD%93/">结构体复习 | 小董的BLOG (gitee.io)</a></p>
<p>2022.11.20:我是按照自己的理解写的，所以思路那些可能会有点奇怪，我感觉自己写的也不是很精练。。凑合看看吧</p>
]]></content>
      <tags>
        <tag>C语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串复习</title>
    <url>/2022/07/30/C%E8%AF%AD%E8%A8%802/</url>
    <content><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>字符串是位于双引号中的字符序列，因此在内存中以“\0”结束,所占字节比实际多一个。</p>
<p>（‘\0’是字符串结束的标志，因此数组中没有‘\0’时只是字符数组，且元素中间不能出现’\0’）</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>当数组元素个数大于存储字符内容时, 未被初始化的部分默认值是0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="type">char</span> name[] = <span class="string">&quot;c\0ool&quot;</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;name = %s\n&quot;</span>,name);</span><br><span class="line"><span class="comment">//输出结果: c</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意点:<ul>
<li>对一个字符串数组, 如果不做初始化赋值, 必须指定数组长度；</li>
<li>字符串数组最后一个字符的位置要留给字符串的结尾标示‘\0’；</li>
<li>当用scanf函数输入字符串时,字符串中不能含有空格,否则将以空格作为串的结束符。</li>
</ul>
</li>
</ul>
<h3 id="正确的赋值方法："><a href="#正确的赋值方法：" class="headerlink" title="正确的赋值方法："></a>正确的赋值方法：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>]=<span class="string">&quot;string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[]=<span class="string">&quot;string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;str);<span class="comment">//或scanf(&quot;%s&quot;,str);</span></span><br></pre></td></tr></table></figure>

<h3 id="错误的赋值方法"><a href="#错误的赋值方法" class="headerlink" title="错误的赋值方法:"></a>错误的赋值方法:</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line">str=<span class="string">&quot;string&quot;</span>; <span class="comment">//这是因为数组名是一个地址常量，是不可被赋值的</span></span><br></pre></td></tr></table></figure>

<h2 id="※常用函数※"><a href="#※常用函数※" class="headerlink" title="※常用函数※"></a>※常用函数※</h2><p>使用字符串函数应包含头文件”string.h”</p>
<h3 id="（1）输出函数"><a href="#（1）输出函数" class="headerlink" title="（1）输出函数"></a>（1）输出函数</h3><ul>
<li><p>格式: puts(字符数组名)</p>
</li>
<li><p>功能:把字符数组中的字符串输出到显示器。即在屏幕上显示该字符串。</p>
</li>
<li><p>优点:</p>
<ul>
<li>自动换行；</li>
<li>可以是数组的任意元素地址。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>不能自定义输出格式</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> ch[] = <span class="string">&quot;dhk&quot;</span>;</span><br><span class="line"><span class="built_in">puts</span>(ch); <span class="comment">//输出结果: dhk</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>当使用printf且输出格式为&amp;s时，输出项直接为数组名，而不是数组元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>]=<span class="string">&quot;dhk&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,s);<span class="comment">//正确</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,s[<span class="number">0</span>]);<span class="comment">//错误</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="（2）输入函数"><a href="#（2）输入函数" class="headerlink" title="（2）输入函数"></a>（2）输入函数</h3><ul>
<li>格式: gets (字符数组名)</li>
<li>功能:从标准输入设备键盘上输入一个字符串。</li>
</ul>
<p>当输入的字符串中含有空格时,输出仍为全部字符串。说明gets函数并不以空格作为字符串输入结束的标志,<em><strong>而只以回车作为输入结束</strong></em>。这是与scanf函数不同的。</p>
<ul>
<li>若要使用scanf一个字符串类型，则需要注意scanf会自动把空格当作分隔符</li>
</ul>
<h3 id="（3）计算长度"><a href="#（3）计算长度" class="headerlink" title="（3）计算长度"></a>（3）计算长度</h3><h4 id="1-sizeof（）"><a href="#1-sizeof（）" class="headerlink" title="1.sizeof（）"></a>1.sizeof（）</h4><p>数值包含’\0’，且当对象为字符串数组时，计算的是整个数组分配空间的长度</p>
<h4 id="2-strlen"><a href="#2-strlen" class="headerlink" title="2.strlen()"></a>2.strlen()</h4><p>测量字符串实际长度，不包含;\0’。</p>
<h3 id="（4）连接函数"><a href="#（4）连接函数" class="headerlink" title="（4）连接函数"></a>（4）连接函数</h3><ul>
<li>格式: strcat(字符数组名1,字符数组名2)  &#x2F;strncat(<del>,</del>,num);</li>
<li>功能:把字符数组2中的字符串连接到字符数组1 中字符串的后面,并删去字符串1后的串标志 “\0”。<strong>本函数返回值是字符数组1的首地址</strong>。</li>
</ul>
<h3 id="（5）比较函数"><a href="#（5）比较函数" class="headerlink" title="（5）比较函数"></a>（5）比较函数</h3><ul>
<li><p>格式: strcmp(字符数组名1,字符数组名2)  </p>
</li>
<li><p>功能:<em><strong>按照ASCII码顺序</strong></em>比较两个数组中的字符串,并由函数返回值返回比较结果。</p>
<ul>
<li>字符串1&#x3D;字符串2,返回值&#x3D;0;</li>
<li>字符串1&gt;字符串2,返回值1;</li>
<li>字符串1&lt;字符串2,返回值-1。</li>
</ul>
<p>需要注意的是，比较顺序是从左至右依次比较每一个字符的ASCII码大小，只要出现不同字符就只按照当前字符大小比较，与之后字符大小就无关了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] =<span class="string">&quot;acb&quot;</span>;     </span><br><span class="line">	<span class="type">char</span> str2[<span class="number">10</span>] =<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strcmp</span>(str1,str2));</span><br><span class="line">    <span class="comment">//输出1，由于&#x27;c&#x27;&gt;&#x27;b&#x27;,与第三个及以后的字符大小无关</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>感觉不是很好用，就拿来比较是否相同就行。</p>
</li>
</ul>
<h3 id="（6）拷贝函数"><a href="#（6）拷贝函数" class="headerlink" title="（6）拷贝函数"></a>（6）拷贝函数</h3><ul>
<li>格式： strcpy(char* dest,char* src);   &#x2F;   strncpy(char* dest,const char* src,size_t num);</li>
<li>功能：将参数src字符串拷贝至参数dest所指的地址。</li>
<li>返回值：返回参数dest的字符串起始地址。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] =<span class="string">&quot;aaaaaa&quot;</span>;     </span><br><span class="line">	<span class="type">char</span> str2[<span class="number">10</span>] = <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">	<span class="built_in">strncpy</span>(str1,str2,<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str1); <span class="comment">//结果为&quot;bbaaaa&quot; </span></span><br><span class="line">    <span class="comment">//当num长度大于srt2中字符串长度时仅会打印bbb（结果可能与编译器相关）</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>strcpy会覆盖原来的整个字符串，而strncpy只会覆盖n个字节原来的字符串，剩下的保留（当n超长时应该是默认使用strcpy）</strong></p>
<h3 id="（7）检索函数"><a href="#（7）检索函数" class="headerlink" title="（7）检索函数"></a>（7）检索函数</h3><h4 id="1-char-strstr-const-char-str-const-char-substr"><a href="#1-char-strstr-const-char-str-const-char-substr" class="headerlink" title="1. char* strstr(const char* str,const char* substr)"></a>1. char* strstr(const char* str,const char* substr)</h4><ul>
<li><p>功能：检索子串在字符串中<strong>首次出现的位置</strong>。</p>
</li>
<li><p>返回值：返回字符串str中第一次出现子串substr的地址；如果没有检索到子串，则返回NULL。</p>
<h4 id="2-char-strchr-const-char-str-char-c"><a href="#2-char-strchr-const-char-str-char-c" class="headerlink" title="2. char* strchr(const char* str,char c)"></a>2. char* strchr(const char* str,char c)</h4></li>
<li><p>功能：查找字符串中第一次出现c的位置。</p>
</li>
<li><p>返回值：规律同strstr()。</p>
<h4 id="3-char-strrchr-const-char-str-char-c"><a href="#3-char-strrchr-const-char-str-char-c" class="headerlink" title="3. char* strrchr(const char* str,char c)"></a>3. char* strrchr(const char* str,char c)</h4></li>
<li><p>功能：查找字符串中最后一次出现c的位置。</p>
</li>
<li><p>返回值：同上。</p>
</li>
</ul>
<h3 id="（8）其余函数"><a href="#（8）其余函数" class="headerlink" title="（8）其余函数"></a>（8）其余函数</h3><h4 id="字符转换"><a href="#字符转换" class="headerlink" title="字符转换"></a>字符转换</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tolower</span><span class="params">(<span class="type">int</span> c)</span>：转化字符为小写字母； </span><br><span class="line"><span class="type">int</span> <span class="title function_">toupper</span><span class="params">(<span class="type">int</span> c)</span>：转化字符为大写字母；</span><br></pre></td></tr></table></figure>

<h4 id="整型转换"><a href="#整型转换" class="headerlink" title="整型转换"></a>整型转换</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span><br></pre></td></tr></table></figure>

<p>​	返回转换后的整型数。</p>
<h4 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">strlwr(<span class="type">const</span> <span class="type">char</span>* str);<span class="comment">//转小写</span></span><br><span class="line">strupr(<span class="type">const</span> <span class="type">char</span>* str);<span class="comment">//转大写</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>关于hexo本地图片无法上传</title>
    <url>/2022/07/30/hexo-2/</url>
    <content><![CDATA[<h1 id="关于hexo本地图片无法上传"><a href="#关于hexo本地图片无法上传" class="headerlink" title="关于hexo本地图片无法上传"></a>关于hexo本地图片无法上传</h1><h2 id="1-安装插件"><a href="#1-安装插件" class="headerlink" title="1.安装插件"></a>1.安装插件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<h2 id="2-配置插件（可以先跳过看看）"><a href="#2-配置插件（可以先跳过看看）" class="headerlink" title="2.配置插件（可以先跳过看看）"></a>2.配置插件（可以先跳过看看）</h2><p>打开&#x2F;node_modules&#x2F;hexo-asset-image&#x2F;index.js，将内容更换为下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">cheerio</span> <span class="operator">=</span> require(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line">function <span class="title function_">getPosition</span><span class="params">(str, m, i)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">version</span> <span class="operator">=</span> String(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, function(data)&#123;</span><br><span class="line">  <span class="type">var</span> <span class="variable">config</span> <span class="operator">=</span> hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">    	<span class="type">var</span> <span class="variable">link</span> <span class="operator">=</span> data.permalink;</span><br><span class="line">	<span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; Number(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">	   <span class="type">var</span> <span class="variable">beginPos</span> <span class="operator">=</span> getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	   <span class="type">var</span> <span class="variable">beginPos</span> <span class="operator">=</span> getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">	<span class="type">var</span> <span class="variable">endPos</span> <span class="operator">=</span> link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="type">var</span> <span class="variable">toprocess</span> <span class="operator">=</span> [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      <span class="type">var</span> <span class="variable">key</span> <span class="operator">=</span> toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="type">var</span> <span class="variable">$</span> <span class="operator">=</span> cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">        xmlMode: <span class="literal">false</span>,</span><br><span class="line">        lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">        decodeEntities: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(function()&#123;</span><br><span class="line">		<span class="keyword">if</span> ($(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">			<span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">src</span> <span class="operator">=</span> $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">			<span class="keyword">if</span>(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp;</span><br><span class="line">			   !/^\s*\<span class="comment">//.test(src)) &#123;</span></span><br><span class="line">			  <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">			  <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">			  <span class="type">var</span> <span class="variable">linkArray</span> <span class="operator">=</span> link.split(<span class="string">&#x27;/&#x27;</span>).filter(function(elem)&#123;</span><br><span class="line">				<span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">			  &#125;);</span><br><span class="line">			  <span class="type">var</span> <span class="variable">srcArray</span> <span class="operator">=</span> src.split(<span class="string">&#x27;/&#x27;</span>).filter(function(elem)&#123;</span><br><span class="line">				<span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">			  &#125;);</span><br><span class="line">			  <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">				srcArray.shift();</span><br><span class="line">			  src = srcArray.join(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">			  $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class="line">			  console.info&amp;&amp;console.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			console.info&amp;&amp;console.info(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">			console.info&amp;&amp;console.info($(<span class="built_in">this</span>));</span><br><span class="line">		&#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-修改根配置文件"><a href="#3-修改根配置文件" class="headerlink" title="3.修改根配置文件"></a>3.修改根配置文件</h2><p>post_asset_folder: true</p>
<h2 id="4-引入图片（可能无法使用markdown语法-“！“）"><a href="#4-引入图片（可能无法使用markdown语法-“！“）" class="headerlink" title="4.引入图片（可能无法使用markdown语法 “！“）"></a>4.引入图片（可能无法使用markdown语法 “！<a href></a>“）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img 1.jpg This is an image %&#125; </span><br></pre></td></tr></table></figure>

<p>“1.jpg”为图片名字</p>
<h1 id="注：上传至github时png格式无法使用，最好用jpg格式"><a href="#注：上传至github时png格式无法使用，最好用jpg格式" class="headerlink" title="注：上传至github时png格式无法使用，最好用jpg格式"></a>注：上传至github时png格式无法使用，最好用jpg格式</h1>]]></content>
      <tags>
        <tag>hexo的一些问题</tag>
      </tags>
  </entry>
  <entry>
    <title>guitar-1</title>
    <url>/2022/07/30/guitar-1/</url>
    <content><![CDATA[<h1 id="1-自由节奏"><a href="#1-自由节奏" class="headerlink" title="1.自由节奏"></a>1.自由节奏</h1><img src="/images/loading.png" data-original="/2022/07/30/guitar-1/1.jpg" class title="This is an image"> 

<p>Rubato标志</p>
<h1 id="2-延续"><a href="#2-延续" class="headerlink" title="2.延续"></a>2.延续</h1><img src="/images/loading.png" data-original="/2022/07/30/guitar-1/2.jpg" class title="This is an image"> 

<p>此时不要再次触碰相对弦（下弧线 ）</p>
<h1 id="三连音"><a href="#三连音" class="headerlink" title="三连音"></a>三连音</h1><img src="/images/loading.png" data-original="/2022/07/30/guitar-1/3.jpg" class title="This is an image"> 

<p>击弦+勾弦三连音，上弧线代表只弹第一个音</p>
<h1 id="装饰音"><a href="#装饰音" class="headerlink" title="装饰音"></a>装饰音</h1><img src="/images/loading.png" data-original="/2022/07/30/guitar-1/4.jpg" class title="This is an image"> 

<p>此次主要为听到后一个音</p>
<p>（若单有上斜线则会从低位到高位滑音（无头&#x2F;无尾滑音））</p>
<h1 id="左手抹弦"><a href="#左手抹弦" class="headerlink" title="左手抹弦"></a>左手抹弦</h1><img src="/images/loading.png" data-original="/2022/07/30/guitar-1/5.jpg" class title="This is an image"> 

<p>L.H.Stroke +左手拍弦</p>
<h1 id="点弦"><a href="#点弦" class="headerlink" title="点弦"></a>点弦</h1><img src="/images/loading.png" data-original="/2022/07/30/guitar-1/6.jpg" class title="This is an image"> 

<p>正上方表有L.H,此处（）为幽灵音</p>
]]></content>
      <tags>
        <tag>guitar</tag>
      </tags>
  </entry>
  <entry>
    <title>答辩问题（自用）</title>
    <url>/2022/07/28/%E7%AD%94%E8%BE%A9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="1-整体工作流程"><a href="#1-整体工作流程" class="headerlink" title="1.整体工作流程"></a>1.整体工作流程</h1><h2 id="避障问题"><a href="#避障问题" class="headerlink" title="避障问题"></a>避障问题</h2><p>本代机器人使用的超声波检测避障，但在实际运行中发现工作效果不佳，在后续迭代的过程中会考虑到使用激光雷达或者碰撞检测来完成避障。</p>
<h2 id="下位机处理视觉数据问题"><a href="#下位机处理视觉数据问题" class="headerlink" title="下位机处理视觉数据问题"></a>下位机处理视觉数据问题</h2><p>上位机以一定频率下发粪便距离铲取装置的距离，下位机将数据处理为底盘行为。</p>
<p>例：粪便偏离视野中心，底盘同时调整x，y轴的分速度。</p>
<p>​	    当粪便距离已经较近时，减慢速度，进行微调。</p>
<h2 id="舵机相关问题"><a href="#舵机相关问题" class="headerlink" title="舵机相关问题"></a>舵机相关问题</h2><p>50Hz，固定占空比，固定角度。</p>
<h2 id="运输机构"><a href="#运输机构" class="headerlink" title="运输机构"></a>运输机构</h2><p>不需要很精准的控制，直接通过延时完成。</p>
<p>推杆10s；传送带10s；进膜15s；激光切割18s。</p>
<h2 id="进膜问题"><a href="#进膜问题" class="headerlink" title="进膜问题"></a>进膜问题</h2><p>进膜机构设置有灰度传感器，只有当pvc塑料膜储备足够且正确地切割、装填后才会进入下一任务。</p>
<p>（视频中为方便调试没有安装（如果问到的话））</p>
<h2 id="激光发射问题"><a href="#激光发射问题" class="headerlink" title="激光发射问题"></a>激光发射问题</h2><p>500Hz，12V；pwm控制占空比，默认功率最大。</p>
<h2 id="底盘控制"><a href="#底盘控制" class="headerlink" title="底盘控制"></a>底盘控制</h2><p>底盘采用PID控制，当出现卡死现象时，底盘会先向反方向运动，再继续工作。</p>
<h2 id="检测装满"><a href="#检测装满" class="headerlink" title="检测装满"></a>检测装满</h2><p>同时检测储物仓中垃圾的体积和重量，当任意一方满足条件后都会触发装满任务。</p>
<h2 id="下位机主控"><a href="#下位机主控" class="headerlink" title="下位机主控"></a>下位机主控</h2><p>采用STM32F103ZET6芯片，初始化2路不同频率PWM;使用串口与上位机通信；使用IIC通讯协议与PAJ76020通讯。</p>
<h3 id="程序具体流程："><a href="#程序具体流程：" class="headerlink" title="程序具体流程："></a>程序具体流程：</h3><p>1.各项初始化</p>
<p>2.进入定时器中断以一定频率接收、处理上位机数据、检测障碍物。</p>
<p>3.当检测到相关信号后进入相关任务。（例如：避障任务，铲取粪便任务)</p>
<h1 id="2022-7-30-更新"><a href="#2022-7-30-更新" class="headerlink" title="2022.7.30 更新"></a>2022.7.30 更新</h1><p>本来紧张的一，结果最后什么问题也没问捏QAQ.</p>
]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>二维数组复习</title>
    <url>/2022/07/28/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="一、理论方面"><a href="#一、理论方面" class="headerlink" title="一、理论方面"></a>一、理论方面</h1><h2 id="1-存储"><a href="#1-存储" class="headerlink" title="1.存储"></a>1.存储</h2><ul>
<li><p>存储方式:</p>
<ul>
<li><p>内存寻址从大到小, 从高地址开辟一块连续没有被使用的内存给数组。</p>
</li>
<li><p>从分配的连续存储空间中, <em><strong>地址小的位置开始给每个元素分配空间</strong></em>。</p>
</li>
<li><p>从每个元素分配的存储空间中, <em><strong>地址最大的位置开始存储数据</strong></em>。</p>
</li>
<li><p>用数组名指向整个存储空间最小的地址。</p>
<p>（分配从小地址开始，赋值从大地址开始）</p>
</li>
</ul>
</li>
</ul>
<h3 id="二维数组地址详解-指针数组-数组指针-重要！！！"><a href="#二维数组地址详解-指针数组-数组指针-重要！！！" class="headerlink" title="二维数组地址详解+指针数组+数组指针(重要！！！)"></a>二维数组地址详解+指针数组+数组指针(重要！！！)</h3><p><em>如果还没有学习指针相关内容可以先跳过</em></p>
<h4 id="地址问题详解"><a href="#地址问题详解" class="headerlink" title="地址问题详解"></a>地址问题详解</h4><p>先看一下各种情况的输出结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> *p[<span class="number">3</span>];</span><br><span class="line">    p[<span class="number">0</span>]=&amp;a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p); <span class="comment">//6487520</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p); <span class="comment">//6487520</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p[<span class="number">0</span>]); <span class="comment">//6487520</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p); <span class="comment">//6487552</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[<span class="number">0</span>][<span class="number">0</span>]); <span class="comment">//6487552</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,**p); <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p[<span class="number">0</span>]); <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当输出为p和&amp;p时，我们可以发现输出的都是一个地址且二者输出相同，都等于p[0]的地址。这就说明数组指针与数组的相关规则相同——其数组名<strong>代表了其第一个元素的地址</strong></li>
<li>当输出为<code>*p</code>和&amp;a[0] [0]时，输出的值为地址且二者相同，&amp;a[0] [0]我们不难理解，但对于<code>*p</code>，上一点已经说到，p代表了p这个数组指针第一个元素的地址，如果我们对这个地址进行解引用（关于解引用<code>*</code>运算符在<a href="https://dhkkk.gitee.io/2022/07/31/C-%E6%8C%87%E9%92%88/">指针相关复习 | 小董的BLOG </a>中有详细讲到），<strong>返回值也就是这个首元素的地址内所存储的内容</strong>，而我们知道，指针变量本身存储的内容就是地址，<strong>所以对p进行解引用的结果，就是p的首元素的地址（6487520）所存储的“a[0] [0]的地址（6487552）“</strong></li>
<li>如果你能很好的理解解引用*运算符的用法，相信你已经能理解输出为<code>**p</code>和<code> *p[0]</code>的结果了；<code>**p</code>即再对<code> *p</code>进行一次解引用，也就是对”a[0] [0]的地址（6487552）“解引用，返回值为a[0] [0]的<strong>地址</strong>所存储的内容，即1。（<code>**p</code>和<code> *p[0]</code>等价）</li>
</ul>
<p>如果你对以上内容已经比较理解，那可以思考一下以下内容（以下内容是我个人的理解，不能保证正确！）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> *p[<span class="number">3</span>];</span><br><span class="line">    p[<span class="number">0</span>]=a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据对一维数组的学习，可以推断出二维数组名a即代表第一个元素的地址，把这个元素地址放进p内，完全没问题，全然大丈夫！但是编译器就是报错了捏😋。在网上找了很多资料之后，大概能想明白是怎么回事，但是又并不是那么明白：**二维数组名a代表的是<code>a[2][3]</code>中a[0]的地址，而在C语言中，这个a[0]又被看作a[3]&#x3D;{1,2,3};**那么这里的a是不是就可以看作是a[0] [0]的地址呢，我们接着尝试：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);<span class="comment">//6487552</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*a);<span class="comment">//6487552</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,**a);<span class="comment">//1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[<span class="number">0</span>]);<span class="comment">//6487552</span></span><br></pre></td></tr></table></figure>

<p>我超，什么意思捏，a和<code>*a</code>输出值一样？？？为了解释这个现象，我们不妨来读一下刚刚的报错：</p>
<p><code>[Error] cannot convert &#39;int [2][3]&#39; to &#39;int*&#39; in assignment</code></p>
<p>这里我的理解是：二维数组a的类型为<code>int [2][3]</code>，而a[0]的类型为<code>int[3]</code>，通俗一点，就是a代表的是第一行数组的地址，而a[0]代表的是a[0] [0]的地址，二者虽然在地址值上相同，但表达的意思是不同的，这也就是为什么a无法存入p中的原因，因为类型是冲突的。所以这里正常的赋值应为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> *p[<span class="number">3</span>];</span><br><span class="line">    p[<span class="number">0</span>]=*a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,**p); 或 <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还有一个办法是：</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> (*p)[<span class="number">3</span>];</span><br><span class="line">    p=a; <span class="comment">//此时p单纯的就是一个指针变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,**p); 或 <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说真的感觉不太好理解，所以可以记下一个规律：</p>
<p><strong>对一个代表一行元素的地址解引用，得到的是该行首元素的地址，再对这个地址解引用得到首元素</strong></p>
<p>(所以此处a[0]等同于*a）</p>
<h4 id="指针数组与数组指针"><a href="#指针数组与数组指针" class="headerlink" title="指针数组与数组指针"></a>指针数组与数组指针</h4><ul>
<li><p>指针数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>在C语言中，[]的优先级高于<code>*</code>因此此式正确理解为：<code>int *(p[3])</code>，说明p为一个数组，且该数组用于存放地址，<strong>此时p是一个数组，但其元素内存储的为某个地址</strong></p>
</li>
<li><p>数组指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>先表明了p是一个指针变量，再说明了p指向的对象是一个int[3]型的数组，且p本身保存的是指向数组的首地址，<strong>此时p是一个指针</strong></p>
<ul>
<li><p>对数组指针的调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>&#125;&#125;,(*p)[<span class="number">3</span>],i;</span><br><span class="line">	p=a;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p);<span class="comment">//6487552</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p);<span class="comment">//6487552</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p[<span class="number">0</span>]);<span class="comment">//6487552</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,**p);<span class="comment">//1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p[<span class="number">0</span>]);<span class="comment">//1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p[<span class="number">0</span>][<span class="number">0</span>]);<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于数组指针的使用有以下几点：<em>（都假设存放的是多维数组）</em></p>
<ul>
<li>指针名代表<strong>二维数组第一行元素的地址</strong></li>
<li>对指针名解引用一次<strong>代表二维数组第一行数组中的第一个元素的地址（等同于p[0]）</strong></li>
<li>当数组指针下标精准到某一个元素时，例如<code>p[0][0]</code>,此时<code>p[0][0]</code>就代表数组元素的值，<strong>而不是地址</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h2><p>​	一维：可以理解为行数，可省略。</p>
<p>​	二维：~~，不可省略（会报错）。</p>
<ul>
<li><p>分行赋值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=</span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">2</span>,,&#125;</span><br><span class="line">    &#123;,,<span class="number">1</span>,&#125;</span><br><span class="line">    &#123;,,,<span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>指定元素的初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;[<span class="number">1</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-二维数组与函数"><a href="#2-二维数组与函数" class="headerlink" title="2.二维数组与函数"></a>2.二维数组与函数</h2><p>​	形参是基本类型则不会影响实参，如果是数组类型则会影响实参。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">change_1</span><span class="params">(<span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    ch = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">change_2</span><span class="params">(<span class="type">char</span> ch[])</span></span><br><span class="line">&#123;</span><br><span class="line">    ch[<span class="number">0</span>] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">change_3</span><span class="params">(<span class="type">char</span> ch[][<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    ch[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> cs[<span class="number">2</span>][<span class="number">3</span>] = </span><br><span class="line">  &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;cs[0][0] = %c\n&quot;</span>, cs[<span class="number">0</span>][<span class="number">0</span>]); <span class="comment">// 打印a</span></span><br><span class="line">  change(cs);  <span class="built_in">printf</span>(<span class="string">&quot;cs[0][0] = %c\n&quot;</span>, cs[<span class="number">0</span>][<span class="number">0</span>]); <span class="comment">// 基本类型形参不影响实参</span></span><br><span class="line">  change_2(cs);  <span class="built_in">printf</span>(<span class="string">&quot;cs[0][0] = %c\n&quot;</span>, cs[<span class="number">0</span>][<span class="number">0</span>]); <span class="comment">// 数组类型形参影响实参  </span></span><br><span class="line">  change_3(cs);  <span class="built_in">printf</span>(<span class="string">&quot;cs[0][0] = %c\n&quot;</span>, cs[<span class="number">0</span>][<span class="number">0</span>]); <span class="comment">// 数组类型形参影响实参 </span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="二、实操"><a href="#二、实操" class="headerlink" title="二、实操"></a>二、实操</h1><p>通过键盘录入 w,s,a,d控制小人向不同方向移动,其中w代表向上移动,s代表向 下移动,a代表向左移动,d 代表向右移动,当小人移动到出口位置,玩家胜利。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> <span class="built_in">map</span>[<span class="number">6</span>][<span class="number">7</span>]=&#123;    <span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,</span><br><span class="line">	                <span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>, 								</span><br><span class="line">					<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,								   </span><br><span class="line">					<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,								   </span><br><span class="line">					<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,								   </span><br><span class="line">					<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mapdraw</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">char</span> loc[<span class="number">6</span>][<span class="number">7</span>])</span>;</span><br><span class="line"><span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> y=<span class="number">1</span>;   <span class="comment">//当前坐标</span></span><br><span class="line"><span class="type">int</span> last_x=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> last_y=<span class="number">1</span>;  <span class="comment">//前一次坐标</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	mapdraw();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	move();</span><br><span class="line">	change(<span class="built_in">map</span>);</span><br><span class="line">	mapdraw();</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">map</span>[<span class="number">1</span>][<span class="number">6</span>]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;YOU WIN!&quot;</span>);	</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mapdraw</span><span class="params">()</span>  <span class="comment">//打印二维数组</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,<span class="built_in">map</span>[<span class="number">0</span>][i]);	</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,<span class="built_in">map</span>[<span class="number">1</span>][i]);	</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,<span class="built_in">map</span>[<span class="number">2</span>][i]);	</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,<span class="built_in">map</span>[<span class="number">3</span>][i]);	</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,<span class="built_in">map</span>[<span class="number">4</span>][i]);	</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,<span class="built_in">map</span>[<span class="number">5</span>][i]);	</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,<span class="built_in">map</span>[<span class="number">6</span>][i]);	</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	last_x=x;</span><br><span class="line">	last_y=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">char</span> loc[<span class="number">6</span>][<span class="number">7</span>])</span>  </span><br><span class="line">&#123;</span><br><span class="line">	loc[last_x][last_y]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	loc[x][y]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">char</span> dir;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;dir);</span><br><span class="line">	<span class="keyword">switch</span>(dir)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:x=x<span class="number">-1</span>;<span class="keyword">if</span>(<span class="built_in">map</span>[x][y]==<span class="string">&#x27;#&#x27;</span>) x=x+<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:x=x+<span class="number">1</span>;<span class="keyword">if</span>(<span class="built_in">map</span>[x][y]==<span class="string">&#x27;#&#x27;</span>) x=x<span class="number">-1</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:y=y<span class="number">-1</span>;<span class="keyword">if</span>(<span class="built_in">map</span>[x][y]==<span class="string">&#x27;#&#x27;</span>) y=y+<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:y=y+<span class="number">1</span>;<span class="keyword">if</span>(<span class="built_in">map</span>[x][y]==<span class="string">&#x27;#&#x27;</span>) y=y<span class="number">-1</span>;<span class="keyword">break</span>;</span><br><span class="line">		defalut :<span class="keyword">break</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	fflush(<span class="built_in">stdin</span>);  <span class="comment">//清除缓冲区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="scanf-停止接受输入及scanf-“-c”-amp-c）吃掉回车或者空格字符的问题"><a href="#scanf-停止接受输入及scanf-“-c”-amp-c）吃掉回车或者空格字符的问题" class="headerlink" title="scanf()停止接受输入及scanf(“%c”,&amp;c）吃掉回车或者空格字符的问题"></a>scanf()停止接受输入及scanf(“%c”,&amp;c）吃掉回车或者空格字符的问题</h1><p>例如，当输入‘w’+‘回车’时，回车会作为’\n’进入缓冲区等待下一次使用，也就是说main中的循环会执行两次。</p>
<p><strong>解决方法</strong>：</p>
<p>函数名: fflush<br>功 能: 清除一个流<br>用 法: int fflush(FILE *stream);</p>
<p><strong>fflush(stdin); 清除缓冲区内容。</strong></p>
<h1 id="一些记录"><a href="#一些记录" class="headerlink" title="一些记录"></a>一些记录</h1><h2 id="1-整个数组指针"><a href="#1-整个数组指针" class="headerlink" title="1.整个数组指针"></a>1.整个数组指针</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">	<span class="type">int</span>* ptr = (<span class="type">int</span>*)(&amp;a + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d,%d&quot;</span>, *(a + <span class="number">1</span>), *(ptr - <span class="number">1</span>));  <span class="comment">//2   5</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&amp;a为整个数组的地址，类型为int(*)[5],需将其强制转化才可以存进prt指针。因此&amp;a+1为整个数组的指针+1。</p>
]]></content>
      <tags>
        <tag>C语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo d 无法更新</title>
    <url>/2022/07/27/test/</url>
    <content><![CDATA[<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>删除 <code>hexo/.deploy_git</code> 文件, 然后重新尝试 <code>hexo d</code> , 就可以成功更新了.</p>
<p>（注：代理最好开全局模式，不然容易卡住）</p>
<p>具体步骤：</p>
<p>1.先hexo d 一遍</p>
<p>2.hexo cl + hexo g </p>
<p>3.删除文件</p>
<p>4.hexo d</p>
]]></content>
      <tags>
        <tag>hexo的一些问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/07/27/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
