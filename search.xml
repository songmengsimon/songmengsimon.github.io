<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[PLC、电力电子和控制电路]]></title>
      <url>/2023/05/29/PLC/</url>
      <content type="html"><![CDATA[<h1 id="PLC存储区和分类"><a href="#PLC存储区和分类" class="headerlink" title="PLC存储区和分类"></a>PLC存储区和分类</h1><ul>
<li><p>输入继电器 I</p>
<p>在扫描循环开始从现场读取输入信号存入I</p>
</li>
<li><p>输出继电器 Q</p>
<p>在扫描循环期间将逻辑运输结果存入Q，在扫描结束后输出</p>
</li>
<li><p>辅助继电器 M</p>
<p>存储程序运算的临时结果</p>
</li>
<li><p>外部输入寄存器 PI</p>
<p>直接访问模拟量输入</p>
</li>
<li><p>外部输出PQ</p>
</li>
<li><p>定时器 T</p>
<p>访问该存储器可获得定时器剩余时间</p>
</li>
<li><p>计数器 C</p>
</li>
<li><p>数据块寄存器 DB</p>
</li>
<li><p>本地数据寄存器 L</p>
</li>
</ul>
<h1 id="S7-1200常用指令"><a href="#S7-1200常用指令" class="headerlink" title="S7-1200常用指令"></a>S7-1200常用指令</h1><h2 id="RS和SR触发器"><a href="#RS和SR触发器" class="headerlink" title="RS和SR触发器"></a>RS和SR触发器</h2><ul>
<li>RS 置位优先</li>
<li>SR 复位优先</li>
</ul>
<img src="/images/loading.png" data-original="/2023/05/29/PLC/1.jpg" class title="This is an image"> 

<h2 id="跳变沿检测"><a href="#跳变沿检测" class="headerlink" title="跳变沿检测"></a>跳变沿检测</h2><h3 id="RLO跳变沿检测"><a href="#RLO跳变沿检测" class="headerlink" title="RLO跳变沿检测"></a>RLO跳变沿检测</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">RLO上升沿检测</th>
<th align="center">RLO下降沿检测</th>
</tr>
</thead>
<tbody><tr>
<td align="center">输出地址</td>
<td align="center">%M1.0</td>
<td align="center">%M1.2</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">——（P）——</td>
<td align="center">——（N）——</td>
</tr>
<tr>
<td align="center">输入地址</td>
<td align="center">%M1.1</td>
<td align="center">%M1.3</td>
</tr>
</tbody></table>
<h3 id="触点信号检测沿"><a href="#触点信号检测沿" class="headerlink" title="触点信号检测沿"></a>触点信号检测沿</h3><h2 id="定时器指令"><a href="#定时器指令" class="headerlink" title="定时器指令"></a>定时器指令</h2><h3 id="脉冲定时器"><a href="#脉冲定时器" class="headerlink" title="脉冲定时器"></a>脉冲定时器</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">%DB1</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">TP<br>Time</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">IN</td>
<td align="center"></td>
<td align="center">Q</td>
</tr>
<tr>
<td align="center">PT</td>
<td align="center"></td>
<td align="center">ET</td>
</tr>
</tbody></table>
<ul>
<li>PT：预设时间</li>
<li>ET：计时时间</li>
</ul>
<p><u><strong>一旦IN出现上升沿</strong>，TP启动，ET开始计时，ET&lt;PT时，Q都会输出1，ET&gt;PT时，Q都会输出0</u></p>
<p>复位方法：</p>
<ul>
<li>外部复位——[RT]——</li>
<li>ET&gt;PT后，IN为低电平</li>
</ul>
<h3 id="接通延时定时器"><a href="#接通延时定时器" class="headerlink" title="接通延时定时器"></a>接通延时定时器</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">%DB1</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">TON<br>Time</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">IN</td>
<td align="center"></td>
<td align="center">Q</td>
</tr>
<tr>
<td align="center">PT</td>
<td align="center"></td>
<td align="center">ET</td>
</tr>
</tbody></table>
<p><strong>当IN为高时TON启动</strong>，ET开始计时，<strong>IN需一直为高直到ET&gt;PT后</strong>，Q输出高，Q输出高的时间取决于<strong>ET&gt;PT后IN的高电平时间</strong></p>
<p>复位方法：</p>
<ul>
<li>IN出现低电平</li>
<li>外部复位——[RT]——（若IN为高则ET开始重新计时）</li>
</ul>
<h3 id="关断延时定时器"><a href="#关断延时定时器" class="headerlink" title="关断延时定时器"></a>关断延时定时器</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">%DB1</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">TOF<br>Time</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">IN</td>
<td align="center"></td>
<td align="center">Q</td>
</tr>
<tr>
<td align="center">PT</td>
<td align="center"></td>
<td align="center">ET</td>
</tr>
</tbody></table>
<p><strong>IN为高时Q输出高，当IN出现下降沿时TOF启动</strong>，ET开始计时，<strong>此时Q持续输出高</strong>，<strong>IN需一直为低电平</strong>直到ET&gt;PT后，Q输出低电平，<strong>输出时间取决于IN低电平的时间</strong></p>
<p>复位方法：</p>
<ul>
<li>IN出现高电平</li>
<li>外部复位——[RT]——（若IN为低（ET已开始计时），复位后Q为低）</li>
</ul>
<h1 id="接线图与变量表实例"><a href="#接线图与变量表实例" class="headerlink" title="接线图与变量表实例"></a>接线图与变量表实例</h1><img src="/images/loading.png" data-original="/2023/05/29/PLC/2.jpg" class title="This is an image"> 



<h1 id="电力变化电路"><a href="#电力变化电路" class="headerlink" title="电力变化电路"></a>电力变化电路</h1><ul>
<li><p>可控整流电路</p>
<p>固定交流变可调直流</p>
</li>
<li><p>交流调压电路</p>
<p>固定交流变电压可调交流</p>
</li>
<li><p>逆变电路</p>
<p>直流变可调交流</p>
</li>
<li><p>变频电路</p>
<p>固定交流变频率可调交流</p>
</li>
<li><p>斩波电路</p>
<p>固定直流变可调直流</p>
</li>
</ul>
<h1 id="晶闸管"><a href="#晶闸管" class="headerlink" title="晶闸管"></a>晶闸管</h1><img src="/images/loading.png" data-original="/2023/05/29/PLC/11.jpg" class title="This is an image"> 

<ul>
<li>控制极无电压时晶闸管不会导通——正反向阻断能力</li>
<li>晶闸管样机和控制极同时正向电压时才会导通</li>
<li>晶闸管导通后控制极失去作用，只有阳极电压降到足够小或断开、反向时晶闸管才会阻断</li>
</ul>
<h1 id="门极可关断晶闸管"><a href="#门极可关断晶闸管" class="headerlink" title="门极可关断晶闸管"></a>门极可关断晶闸管</h1><img src="/images/loading.png" data-original="/2023/05/29/PLC/22.jpg" class title="This is an image"> 

<p>两边均为直流</p>
<h1 id="可控整流电路"><a href="#可控整流电路" class="headerlink" title="可控整流电路"></a>可控整流电路</h1><h2 id="单相半波可控整流电路"><a href="#单相半波可控整流电路" class="headerlink" title="单相半波可控整流电路"></a>单相半波可控整流电路</h2><img src="/images/loading.png" data-original="/2023/05/29/PLC/33.jpg" class title="This is an image"> 

<h2 id="带电感负载"><a href="#带电感负载" class="headerlink" title="带电感负载"></a>带电感负载</h2><img src="/images/loading.png" data-original="/2023/05/29/PLC/44.jpg" class title="This is an image"> 

<h2 id="带续流二极管"><a href="#带续流二极管" class="headerlink" title="带续流二极管"></a>带续流二极管</h2><p>提高大感抗负载时输出平均电压</p>
<h1 id="逆变电路（逆变器）"><a href="#逆变电路（逆变器）" class="headerlink" title="逆变电路（逆变器）"></a>逆变电路（逆变器）</h1><h2 id="单相无源逆变器"><a href="#单相无源逆变器" class="headerlink" title="单相无源逆变器"></a>单相无源逆变器</h2><img src="/images/loading.png" data-original="/2023/05/29/PLC/55.jpg" class title="This is an image"> 

<h1 id="斩波电路"><a href="#斩波电路" class="headerlink" title="斩波电路"></a>斩波电路</h1><p>PWM&#x2F;PFM改变逆变器输出电压</p>
<h1 id="直流调速系统"><a href="#直流调速系统" class="headerlink" title="直流调速系统"></a>直流调速系统</h1><h2 id="转速负反馈"><a href="#转速负反馈" class="headerlink" title="转速负反馈"></a>转速负反馈</h2><img src="/images/loading.png" data-original="/2023/05/29/PLC/66.jpg" class title="This is an image"> 

<p>调速方法：改变转子电压（改Ug）</p>
<p>放大倍数越高，准确度越高，调速范围越大；倍数过高系统不稳定</p>
<h2 id="电压负反馈"><a href="#电压负反馈" class="headerlink" title="电压负反馈"></a>电压负反馈</h2><p>通过电位器检测被控质量</p>
<p>电压负反馈，电流正反馈</p>
<h1 id="交流调速系统"><a href="#交流调速系统" class="headerlink" title="交流调速系统"></a>交流调速系统</h1><h2 id="调压调速"><a href="#调压调速" class="headerlink" title="调压调速"></a>调压调速</h2><p>转速负反馈</p>
<p>不适合长期工作在低速区的工作机械</p>
<h2 id="变频调速"><a href="#变频调速" class="headerlink" title="变频调速"></a>变频调速</h2><p>频率与磁通成反比，因此最好同时调压变频</p>
<h3 id="交-直-交变频器"><a href="#交-直-交变频器" class="headerlink" title="交-直-交变频器"></a>交-直-交变频器</h3><p>AC——整流器——DC——逆变器（斩波（直流调整）+逆变（直-交））——AC</p>
<h1 id="步进电机调速系统"><a href="#步进电机调速系统" class="headerlink" title="步进电机调速系统"></a>步进电机调速系统</h1><h2 id="脉冲分配器"><a href="#脉冲分配器" class="headerlink" title="脉冲分配器"></a>脉冲分配器</h2><p>方向电平控制转向</p>
<h2 id="功率放大器"><a href="#功率放大器" class="headerlink" title="功率放大器"></a>功率放大器</h2><h3 id="单电压驱动"><a href="#单电压驱动" class="headerlink" title="单电压驱动"></a>单电压驱动</h3><img src="/images/loading.png" data-original="/2023/05/29/PLC/77.jpg" class title="This is an image"> 

<h3 id="高低压切换型驱动"><a href="#高低压切换型驱动" class="headerlink" title="高低压切换型驱动"></a>高低压切换型驱动</h3><p>功耗小，启动力矩大，但增加了驱动电源</p>
]]></content>
      
        
        <tags>
            
            <tag> 期末考试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[lzz-第四章 传感器技术]]></title>
      <url>/2023/05/18/lzz-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<h1 id="1、传感器概述"><a href="#1、传感器概述" class="headerlink" title="1、传感器概述"></a>1、传感器概述</h1><p>输出信号多为易处理电信号（电压、电流、频率）</p>
<p>由**<u>敏感元件、传感元件及测量转换电路</u>**组成</p>
<img src="/images/loading.png" data-original="/2023/05/18/lzz-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8A%80%E6%9C%AF/1.jpg" class title="This is an image"> 

<p>例：</p>
<ul>
<li>敏感元件：对<strong>压力敏感</strong>（可变形）的弹性敏感元件</li>
<li>传感元件：弹性敏感元件上粘贴的电阻应变片，<strong>将敏感元件变形量转化为电参数</strong>（电阻值变化）</li>
<li>测量转换电路：将<strong>传感元件电阻值变化转化、放大、显示</strong></li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a><u>分类</u></h2><p>命名： 被测量+测量原理</p>
<h3 id="按被测量分"><a href="#按被测量分" class="headerlink" title="按被测量分"></a>按被测量分</h3><ul>
<li>位移</li>
<li>力、力矩</li>
<li>振动</li>
<li>加速度</li>
<li>温度</li>
</ul>
<h3 id="按测量原理"><a href="#按测量原理" class="headerlink" title="按测量原理"></a>按测量原理</h3><ul>
<li>电阻</li>
<li>电容</li>
<li>电感</li>
<li>光栅</li>
<li>热电偶</li>
<li>超声波</li>
<li>红外</li>
</ul>
<h1 id="2、位置测量传感器"><a href="#2、位置测量传感器" class="headerlink" title="2、位置测量传感器"></a>2、<u>位置测量传感器</u></h1><p>通过接近开关检测</p>
<h2 id="技术指标"><a href="#技术指标" class="headerlink" title="技术指标"></a>技术指标</h2><ul>
<li><p>检测距离</p>
</li>
<li><p>复位距离</p>
<p>最远可检测距离</p>
</li>
<li><p>差动距离</p>
<p>复位距离-检测距离</p>
</li>
<li><p>响应时间</p>
<img src="/images/loading.png" data-original="/2023/05/18/lzz-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8A%80%E6%9C%AF/2.jpg" class title="This is an image"></li>
</ul>
<h2 id="涡流式接近开关"><a href="#涡流式接近开关" class="headerlink" title="涡流式接近开关"></a><u>涡流式接近开关</u></h2><p>由LC高频振荡器和放大处理电路组成</p>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>振荡感应头产生电磁场，<strong>作用于金属物体</strong>后在其内部产生涡流，涡流产生磁场反作用于振荡电路使振荡能力衰减，进而控制接近开关的**<u>关断和导通</u>**</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>不与被测物体接触，提高了检测的可靠性与使用寿命</p>
<h2 id="电容式接近开关"><a href="#电容式接近开关" class="headerlink" title="电容式接近开关"></a><u>电容式接近开关</u></h2><p><strong>测量头与被测物形成电容，接入后级RC振荡器，当电容量增加时，振荡器开始振荡，后级电路将其转化为开关信号</strong>（不止可以检测金属）</p>
<h2 id="霍尔接近开关"><a href="#霍尔接近开关" class="headerlink" title="霍尔接近开关"></a>霍尔接近开关</h2><p>检测磁性物体的靠近，灵敏度高，能感受到很小的磁场变化</p>
<h2 id="光电式接近开关"><a href="#光电式接近开关" class="headerlink" title="光电式接近开关"></a>光电式接近开关</h2><ul>
<li>遮断式</li>
<li>反射式<ul>
<li>定区域</li>
<li>反射镜式</li>
<li>漫反射型</li>
</ul>
</li>
</ul>
<h2 id="光幕"><a href="#光幕" class="headerlink" title="光幕"></a>光幕</h2><ul>
<li>保护预警</li>
<li>截面积</li>
<li>三维尺寸</li>
</ul>
<h2 id="热释电接近开关"><a href="#热释电接近开关" class="headerlink" title="热释电接近开关"></a>热释电接近开关</h2><p>感知人或动物发射的红信号</p>
<ul>
<li>报警器：菲涅尔透镜</li>
<li>人体感应</li>
</ul>
<h1 id="3、位移测量传感器"><a href="#3、位移测量传感器" class="headerlink" title="3、位移测量传感器"></a>3、<u>位移测量传感器</u></h1><h2 id="电感式位移传感器"><a href="#电感式位移传感器" class="headerlink" title="电感式位移传感器"></a><u>电感式位移传感器</u></h2><p>基于电磁感应原理，将输入量转化为电感变化量</p>
<h3 id="按原理分类"><a href="#按原理分类" class="headerlink" title="按原理分类"></a>按原理分类</h3><ul>
<li>自感型<ul>
<li>可变磁阻型</li>
<li>涡流式</li>
</ul>
</li>
<li>互感型</li>
</ul>
<h3 id="按检测方式"><a href="#按检测方式" class="headerlink" title="按检测方式"></a>按检测方式</h3><ul>
<li>变气隙式</li>
<li>变面积式</li>
<li>螺线管式</li>
</ul>
<img src="/images/loading.png" data-original="/2023/05/18/lzz-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8A%80%E6%9C%AF/3.jpg" class title="This is an image"> 

<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>位移、厚度、振动</li>
<li>表面温度、电解质浓度、材质</li>
<li>破损</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a><u>特点</u></h3><ul>
<li>非接触测量，不易受介质影响</li>
<li>结构简单，方便，灵敏度高，分辨率高</li>
<li>频率响应范围宽，适合动态测量</li>
</ul>
<h2 id="电容式位移传感器"><a href="#电容式位移传感器" class="headerlink" title="电容式位移传感器"></a><u>电容式位移传感器</u></h2><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>变极距型</p>
<p>灵敏度高</p>
</li>
<li><p>变面积型</p>
<p>灵敏度低</p>
</li>
<li><p>变介电常数型</p>
</li>
</ul>
<h2 id="霍尔位移传感器"><a href="#霍尔位移传感器" class="headerlink" title="霍尔位移传感器"></a>霍尔位移传感器</h2><ul>
<li>纯金属不适用</li>
<li>常用半导体</li>
<li>厚度越小，灵敏度越高</li>
</ul>
<h2 id="光栅位移传感器"><a href="#光栅位移传感器" class="headerlink" title="光栅位移传感器"></a><u>光栅位移传感器</u></h2><p>利用光衍射产生干涉条纹，<strong>精度非常高，响应快，量程大</strong></p>
<ul>
<li><p>主光栅与被测物体相连</p>
</li>
<li><p>用光电器件记录莫尔条纹通过某点的数量来计算主光栅移动的距离</p>
</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>精度高</li>
<li>动态测量范围广</li>
<li>无接触测量，容易自动化和数字化</li>
</ul>
<h1 id="4、旋转变压器"><a href="#4、旋转变压器" class="headerlink" title="4、旋转变压器"></a>4、旋转变压器</h1><p>输出电压随被测角位移变化而变化，为模拟式测量</p>
<p>由定子和转子组成，分为单极和多极型</p>
<h1 id="5、感应同步器"><a href="#5、感应同步器" class="headerlink" title="5、感应同步器"></a>5、感应同步器</h1><p>分为直线型和圆型，精度高、工作可靠、抗干扰强、维护简单、寿命长、成本低</p>
<h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul>
<li>精度高</li>
<li>工作可靠，抗干扰</li>
<li>寿命长</li>
<li>测距长</li>
<li>成本低</li>
</ul>
<h1 id="6、编码器"><a href="#6、编码器" class="headerlink" title="6、编码器"></a>6、编码器</h1><h2 id="增量式"><a href="#增量式" class="headerlink" title="增量式"></a>增量式</h2><p>测量相对某个基准点的相对位置增量，不能直径检测绝对量</p>
<h3 id="AB相作用"><a href="#AB相作用" class="headerlink" title="AB相作用"></a>AB相作用</h3><ul>
<li>一定时间内的脉冲数——角位移</li>
<li>脉冲频率——转速</li>
<li>相位关系——方向</li>
</ul>
<h3 id="Z相"><a href="#Z相" class="headerlink" title="Z相"></a>Z相</h3><ul>
<li>定位</li>
<li>计圈数</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 期末考试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[lzz-第三章 伺服技术]]></title>
      <url>/2023/05/17/lzz-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E4%BC%BA%E6%9C%8D%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<h1 id="1、伺服系统"><a href="#1、伺服系统" class="headerlink" title="1、伺服系统"></a>1、伺服系统</h1><h2 id="伺服系统定义"><a href="#伺服系统定义" class="headerlink" title="伺服系统定义"></a>伺服系统定义</h2><p>以机械参数（位移、速度、加速度、力矩等）作为**<u>被控制量</u>**的一种<u><strong>自动控制系统</strong></u></p>
<h2 id="一般组成"><a href="#一般组成" class="headerlink" title="一般组成"></a>一般组成</h2><img src="/images/loading.png" data-original="/2023/05/17/lzz-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E4%BC%BA%E6%9C%8D%E6%8A%80%E6%9C%AF/1.jpg" class title="伺服系统组成"> 

<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a><u>分类</u></h2><h3 id="按控制原理分"><a href="#按控制原理分" class="headerlink" title="按控制原理分"></a>按控制原理分</h3><ul>
<li>开环</li>
<li>半闭环（不检测工作台信息）</li>
<li>全闭环</li>
</ul>
<h3 id="驱动方式"><a href="#驱动方式" class="headerlink" title="驱动方式"></a>驱动方式</h3><ul>
<li>电气伺服</li>
<li>气压伺服</li>
<li>液压伺服</li>
</ul>
<h3 id="被测控制量"><a href="#被测控制量" class="headerlink" title="被测控制量"></a>被测控制量</h3><ul>
<li>速度控制</li>
<li>位置控制</li>
<li>扭矩控制</li>
<li>同步控制</li>
</ul>
<h3 id="执行元件"><a href="#执行元件" class="headerlink" title="执行元件"></a>执行元件</h3><p><strong>开环大多用步进电机，半闭环与闭环多用直流伺服电机</strong></p>
<ul>
<li>步进伺服</li>
<li>直流伺服</li>
<li>交流伺服</li>
</ul>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ul>
<li>快速性</li>
<li>精确性</li>
<li>稳定性</li>
</ul>
<h1 id="2、执行元件"><a href="#2、执行元件" class="headerlink" title="2、执行元件"></a>2、执行元件</h1><p>将输入的各种形式的能量转化为机械能</p>
<h2 id="各执行元件特点"><a href="#各执行元件特点" class="headerlink" title="各执行元件特点"></a><u>各执行元件特点</u></h2><h3 id="电气式"><a href="#电气式" class="headerlink" title="电气式"></a>电气式</h3><p>优点：</p>
<ul>
<li>操作简单</li>
<li>可定位伺服</li>
<li>响应快，易与CPU连接</li>
<li>体积小，动力大，无污染</li>
</ul>
<p>缺点：</p>
<ul>
<li>瞬时输出功率大</li>
<li>过载能力差，易受外部影响</li>
</ul>
<h3 id="气压式"><a href="#气压式" class="headerlink" title="气压式"></a>气压式</h3><p>优点：</p>
<ul>
<li>成本低</li>
<li>无泄漏污染</li>
<li>速度快，操作较简单</li>
</ul>
<p>缺点：</p>
<ul>
<li>功率小</li>
<li>体积大</li>
<li>工作不平稳</li>
<li>噪声大</li>
<li>难以伺服</li>
</ul>
<h3 id="液压式"><a href="#液压式" class="headerlink" title="液压式"></a>液压式</h3><p>优点：</p>
<ul>
<li>输出功率大</li>
<li>速度快</li>
<li>平稳</li>
<li>可定位伺服，响应快</li>
</ul>
<p>缺点：</p>
<ul>
<li>体积大</li>
<li>液压油要求严格</li>
<li>易泄露，有污染</li>
</ul>
<h2 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h2><ul>
<li>惯量小，动力大</li>
<li>体积小，重量轻</li>
<li>便于使用</li>
<li><strong>快速性能好，加减速扭矩大，频率性能好</strong></li>
<li>可靠，寿命长</li>
</ul>
<h1 id="3、步进电机概述"><a href="#3、步进电机概述" class="headerlink" title="3、步进电机概述"></a>3、步进电机概述</h1><p>步进电机式一种将脉冲信号转化为直线位移或角位移的数字&#x2F;模拟变换器</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a><u>特点</u></h2><ul>
<li><strong>输出转角与输入脉冲严格成正比，且在<u>方向上同步</u></strong></li>
<li><strong>输出转角精度高，有步距角误差，但无累计误差</strong></li>
<li><strong>可实现平滑无级调速</strong></li>
<li>不易受干扰</li>
<li>启停时间段</li>
</ul>
<h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a><u>种类</u></h2><h3 id="运动形式"><a href="#运动形式" class="headerlink" title="运动形式"></a>运动形式</h3><ul>
<li>旋转式</li>
<li>直线式</li>
</ul>
<h3 id="励磁相数"><a href="#励磁相数" class="headerlink" title="励磁相数"></a>励磁相数</h3><p>3、4、5、6相</p>
<h3 id="转子结构"><a href="#转子结构" class="headerlink" title="转子结构"></a><u>转子结构</u></h3><ul>
<li>反应式（可变磁阻式）</li>
<li>永磁式</li>
<li>混合式</li>
</ul>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><u>工作原理</u></h2><h3 id="三相单三拍"><a href="#三相单三拍" class="headerlink" title="三相单三拍"></a>三相单三拍</h3><p>A——B——C</p>
<ul>
<li>三相：为三相绕组</li>
<li>单：每拍只有一相绕组通电</li>
<li>三拍：一个循环周期三个脉冲</li>
</ul>
<p>一拍<strong>30°</strong></p>
<h3 id="三相-单双-六拍"><a href="#三相-单双-六拍" class="headerlink" title="三相(单双)六拍"></a>三相(单双)六拍</h3><p>A——AB——B——BC——C——CA</p>
<ul>
<li>单双：每拍为一相&#x2F;两相绕组交替通电</li>
<li>六拍：一个循环周期六个脉冲</li>
</ul>
<p>一拍<strong>15°</strong></p>
<h3 id="三相双三拍"><a href="#三相双三拍" class="headerlink" title="三相双三拍"></a>三相双三拍</h3><p>AB——BC——CA</p>
<p>一拍15°</p>
<p><strong><u>三相双三拍和三相单双六拍比三相单三拍稳定</u></strong></p>
<h2 id="环形分配方式"><a href="#环形分配方式" class="headerlink" title="环形分配方式"></a><u>环形分配方式</u></h2><ul>
<li><p><strong>五相十拍电机为2-3相励磁，而不是1-2相：</strong></p>
<p><strong>AB-ABC-BC-BCD-CD…</strong></p>
</li>
<li><p><strong>六相六拍为3相励磁：</strong></p>
<p><strong>ABC-BCD-CDE-DEF-EFA-FAB</strong></p>
</li>
<li><p><strong>六相十二拍为2-3相励磁</strong></p>
</li>
</ul>
<h2 id="主要性能指标"><a href="#主要性能指标" class="headerlink" title="主要性能指标"></a><u>主要性能指标</u></h2><ul>
<li><p><strong>步距角</strong></p>
<p><strong>我国0.36°~90°，常用15、6、3.2、1.8、1.5、0.72（k&#x3D;1）</strong></p>
</li>
<li><p><strong>静态步距误差（步距角精度）</strong></p>
<p>步距角越小，分辨力越高</p>
</li>
<li><p><strong>转速</strong></p>
<p>频率越高，转速越大</p>
<p>步距角越大（1&#x2F;KPZ 越大），转速越大</p>
</li>
</ul>
<h2 id="静态特性"><a href="#静态特性" class="headerlink" title="静态特性"></a>静态特性</h2><ul>
<li><p>静态</p>
<p>通电时转子保持不动的定位状态</p>
</li>
<li><p>静转矩</p>
<p>静态下的电磁转矩</p>
</li>
<li><p>失调角</p>
<p>静态下在转子上加一负载转矩，转子转过一个角度后稳定下来，该角度为失调角</p>
</li>
<li><p>矩-角特性</p>
<p>静转矩与失调角的对应关系</p>
</li>
<li><p>最大静转矩</p>
<p>矩-角特性上的最大值</p>
</li>
</ul>
<h2 id="起动频率和连续运行频率"><a href="#起动频率和连续运行频率" class="headerlink" title="起动频率和连续运行频率"></a>起动频率和连续运行频率</h2><ul>
<li><p>起动频率</p>
<p>一定负载下能不失步地起动的最高脉冲频率</p>
</li>
<li><p>连续运行频率</p>
<p>启动后逐渐升速所能达到的不失步频率</p>
</li>
</ul>
<h2 id="动态特性"><a href="#动态特性" class="headerlink" title="动态特性"></a>动态特性</h2><ul>
<li><p>动态转矩</p>
<p>运行时的转矩</p>
</li>
<li><p>动态稳定区</p>
<p><strong>通电绕组切换时不引起丢步的区域</strong></p>
</li>
<li><p>起动转矩</p>
<p><strong>它表示步进电机所能承受的极限负载转矩（电机单相励磁时）</strong></p>
</li>
<li><p>矩-频特性</p>
<p><strong>动态转矩与脉冲频率的关系，频率越大，动态转矩越小</strong></p>
</li>
</ul>
<h1 id="4、步进电机控制"><a href="#4、步进电机控制" class="headerlink" title="4、步进电机控制"></a>4、步进电机控制</h1><h2 id="环形分配"><a href="#环形分配" class="headerlink" title="环形分配"></a><u>环形分配</u></h2><ul>
<li>小规模集成电路</li>
<li>专用器件</li>
<li>软件分配</li>
</ul>
<h2 id="功率放大器"><a href="#功率放大器" class="headerlink" title="功率放大器"></a><u>功率放大器</u></h2><p>环形分配输出的信号放大到能驱动电机运行</p>
<h3 id="要求-2"><a href="#要求-2" class="headerlink" title="要求"></a><u>要求</u></h3><ul>
<li>幅值足够，波形良好</li>
<li>功耗低，效率高</li>
</ul>
<h2 id="细分驱动"><a href="#细分驱动" class="headerlink" title="细分驱动"></a>细分驱动</h2><p>将一个步距角细分成若干步</p>
<p>优点</p>
<ul>
<li>使步距角减小</li>
<li>运行平稳</li>
<li>减小振荡</li>
</ul>
<p>缺点</p>
<ul>
<li>细分后步距角精度不高</li>
<li>功放驱动电路复杂</li>
</ul>
<h1 id="5、直流伺服电机"><a href="#5、直流伺服电机" class="headerlink" title="5、直流伺服电机"></a>5、直流伺服电机</h1><h2 id="种类-1"><a href="#种类-1" class="headerlink" title="种类"></a><u>种类</u></h2><p><strong>永磁式和它激式有线性的机械特性，有良好的起动、制动和调速性能</strong></p>
<ul>
<li>永磁式</li>
<li>它激式</li>
<li>串激式</li>
<li>并激式</li>
</ul>
<h2 id="伺服系统组成"><a href="#伺服系统组成" class="headerlink" title="伺服系统组成"></a>伺服系统组成</h2><p>直流电动机、反馈装置、直流电源、控制驱动电路</p>
<h2 id="电机组成"><a href="#电机组成" class="headerlink" title="电机组成"></a><u>电机组成</u></h2><ul>
<li><p>定子</p>
<p>为直流线圈通电激磁或用永磁体产生磁场</p>
</li>
<li><p>转子</p>
<p>转子上有多相线圈，通直流电时在定子磁场下产生转矩</p>
</li>
<li><p>换向机构</p>
<p>包括电刷和换向片，<strong>电刷与电源相连，换向片与电枢绕组相连，使转子在旋转时电磁转矩总是保持恒定方向</strong></p>
</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a><u>原理</u></h2><p>转子上均匀分配多匝绕组，绕组越密集，总电磁力越大，电磁转矩越接近恒定</p>
<h2 id="直流电机驱动调速"><a href="#直流电机驱动调速" class="headerlink" title="直流电机驱动调速"></a><u>直流电机驱动调速</u></h2><p>用于<strong>控制电枢电压的大小与极性</strong>，常用<strong>可控硅法和PWM法</strong></p>
<p>PWM法中，低电平时电枢电感储存的能量通过续流二极管继续使电机转动</p>
<h3 id="PWM与PFM"><a href="#PWM与PFM" class="headerlink" title="PWM与PFM"></a>PWM与PFM</h3><ul>
<li>PWM：脉冲频率不变，调整脉冲宽度</li>
<li>PFM：脉冲宽度不变，调整脉冲频率</li>
</ul>
<h1 id="6、交流伺服电机"><a href="#6、交流伺服电机" class="headerlink" title="6、交流伺服电机"></a>6、交流伺服电机</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>定子上装有四组空间差90°的两个绕组，控制、励磁绕组</p>
<ul>
<li><strong>控制绕组的控制电压与电源电压频率相同，相位相同或相反</strong></li>
<li><strong>励磁绕组串联电容C，适当选择电容大小使控制绕组和励磁绕组电流相位差接近90°，从而产生转子旋转方向的磁场</strong></li>
</ul>
<h2 id="变频器（交流变频调速）分类"><a href="#变频器（交流变频调速）分类" class="headerlink" title="变频器（交流变频调速）分类"></a>变频器（交流变频调速）分类</h2><h3 id="按变频方式"><a href="#按变频方式" class="headerlink" title="按变频方式"></a>按变频方式</h3><ul>
<li><p>交-直-交</p>
</li>
<li><p>交-交</p>
<p>只适用于低速</p>
</li>
</ul>
<h3 id="按能量处理方式"><a href="#按能量处理方式" class="headerlink" title="按能量处理方式"></a>按能量处理方式</h3><ul>
<li>电流型</li>
<li>电压性</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 期末考试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[lzz-第二章 机械传动部件选择]]></title>
      <url>/2023/05/16/lzz-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9C%BA%E6%A2%B0%E4%BC%A0%E5%8A%A8%E9%83%A8%E4%BB%B6%E9%80%89%E6%8B%A9/</url>
      <content type="html"><![CDATA[<h1 id="1、机械系统组成"><a href="#1、机械系统组成" class="headerlink" title="1、机械系统组成"></a><u>1、机械系统组成</u></h1><p>联系各部件并实现其构造功能</p>
<ul>
<li><p><strong>传动结构</strong></p>
<p>传递能量与运动，力、速度变换器</p>
</li>
<li><p><strong>导向机构</strong></p>
<p>支撑、限制运动</p>
</li>
<li><p><strong>支撑件</strong></p>
<p>承受载荷，保证零件相对位置的基准作用</p>
</li>
</ul>
<h1 id="2、对比"><a href="#2、对比" class="headerlink" title="2、对比"></a><u>2、对比</u></h1><h2 id="传统"><a href="#传统" class="headerlink" title="传统"></a>传统</h2><ul>
<li>动力件、传动件、执行件</li>
<li>电器、液压、机械控制</li>
</ul>
<h2 id="一体化"><a href="#一体化" class="headerlink" title="一体化"></a>一体化</h2><p>核心由计算机控制</p>
<h1 id="3、对机械系统的基本要求"><a href="#3、对机械系统的基本要求" class="headerlink" title="3、对机械系统的基本要求"></a><u>3、对机械系统的基本要求</u></h1><ul>
<li><u>低摩擦</u></li>
<li><u>无间隙</u></li>
<li><strong><u>低惯量</u></strong></li>
<li><u>高刚度</u></li>
</ul>
<h2 id="措施"><a href="#措施" class="headerlink" title="措施"></a>措施</h2><ul>
<li>使用低摩擦阻尼器件</li>
<li>减小反向死区误差</li>
<li>最佳传动比、缩短传动链</li>
<li>提高刚度</li>
</ul>
<h1 id="4、传动部件"><a href="#4、传动部件" class="headerlink" title="4、传动部件"></a>4、传动部件</h1><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a><u>主要功能</u></h2><p><u><strong>传递转矩和转速</strong></u>，使执行件与负载在转矩与转速方面得到最佳匹配</p>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ul>
<li>间隙</li>
<li>精度</li>
<li>体积</li>
<li>运动平稳</li>
<li>扭矩</li>
</ul>
<h2 id="滑动丝杠螺母"><a href="#滑动丝杠螺母" class="headerlink" title="滑动丝杠螺母"></a>滑动丝杠螺母</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>传递能量</li>
<li>传递运动</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><u>优缺点</u></h3><ul>
<li>结构简单、加工方便、成本低、自锁</li>
<li><strong>摩擦</strong>阻力大，传动**<u>效率</u>**低</li>
</ul>
<h3 id="基本传动形式"><a href="#基本传动形式" class="headerlink" title="基本传动形式"></a><u>基本传动形式</u></h3><ul>
<li>螺母固定，丝杠转动+移动</li>
<li>丝杠转动、螺母移动（需导向装置限制螺母转动）</li>
<li>螺母转动、丝杠移动  很少</li>
<li>丝杠固定，螺母转动+移动  很少</li>
</ul>
<h3 id="差动传动"><a href="#差动传动" class="headerlink" title="差动传动"></a><u>差动传动</u></h3><p>丝杠上有两段导程不同的螺纹</p>
<ul>
<li>旋向相同</li>
<li>旋向相反</li>
</ul>
<h2 id="滚珠丝杠螺母"><a href="#滚珠丝杠螺母" class="headerlink" title="滚珠丝杠螺母"></a><u>滚珠丝杠螺母</u></h2><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul>
<li>丝杠</li>
<li>螺母</li>
<li>滚珠</li>
<li><u><strong>反向器</strong></u></li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><u>优点</u></h3><ul>
<li>效率90~95</li>
<li>精度高</li>
<li>摩擦小，寿命长</li>
<li>可逆性</li>
<li>轴向刚度高</li>
<li>平稳</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><u>缺点</u></h3><ul>
<li><strong>不能自锁</strong></li>
<li>结构复杂，成本高</li>
</ul>
<h3 id="典型结构"><a href="#典型结构" class="headerlink" title="典型结构"></a><u>典型结构</u></h3><h4 id="滚道截面形状分"><a href="#滚道截面形状分" class="headerlink" title="滚道截面形状分"></a>滚道截面形状分</h4><ul>
<li>单圆弧形<ul>
<li>接触角随载荷增大而增大，效率、刚度、承载能力</li>
<li>滚道半径略大于滚珠半径</li>
</ul>
</li>
<li>双圆弧形<ul>
<li>接触角不变（一般为45°）</li>
<li>滚道半径等于滚珠半径</li>
<li>小空隙用于储油润滑</li>
</ul>
</li>
</ul>
<h4 id="按循环方式分"><a href="#按循环方式分" class="headerlink" title="按循环方式分"></a>按循环方式分</h4><ul>
<li>内循环<ul>
<li>滚珠始终与丝杠接触</li>
<li>优点：流畅、效率、尺寸小</li>
<li>缺点：反向器加工困难</li>
</ul>
</li>
<li>外循环<ul>
<li>螺旋槽式<ul>
<li>易于制造</li>
<li>刚性差、易磨损</li>
</ul>
</li>
<li>插管式<ul>
<li>易于制造</li>
<li>尺寸大，易磨损</li>
</ul>
</li>
<li>端盖式<ul>
<li>回程轨道半径为滚珠直径1.4~1.6倍</li>
<li>结构简单</li>
<li>性能差</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="尺寸参数"><a href="#尺寸参数" class="headerlink" title="尺寸参数"></a><u>尺寸参数</u></h3><ul>
<li><p><strong>公称直径</strong></p>
<p>为滚珠丝杠的特征尺寸</p>
</li>
<li><p><strong>导程</strong></p>
<p>相对转动一圈螺母的轴向位移</p>
<p>越小，精度越高，承载能力越小</p>
</li>
<li><p>行程</p>
</li>
<li><p>滚珠个数</p>
<p>一般小于150</p>
</li>
<li><p>工作圈数</p>
<p>2.5~3.5</p>
</li>
</ul>
<h3 id="消除间隙"><a href="#消除间隙" class="headerlink" title="消除间隙"></a><u>消除间隙</u></h3><h4 id="双螺母"><a href="#双螺母" class="headerlink" title="双螺母"></a>双螺母</h4><ul>
<li><p>双螺母螺纹预紧</p>
<p>一边螺母通过两圆螺母预紧，两个螺母的滚珠相向受力（向内），结构简单、刚性好，可靠，方便但不精确</p>
</li>
<li><p>双螺母齿差预紧</p>
<p><u><strong>两螺母相差1齿，由两端内齿轮固定，可定量调整，使用方便</strong></u></p>
</li>
<li><p>双螺母垫片预紧</p>
<p>在两螺母间加装垫片，结构简单，刚度高，可靠，但调整不方便</p>
</li>
<li><p>弹簧式自动调整预紧</p>
<p>一螺母固定，一螺母活动，结构复杂，刚度低，用于轻载</p>
</li>
</ul>
<h3 id="支撑方式"><a href="#支撑方式" class="headerlink" title="支撑方式"></a><u>支撑方式</u></h3><ul>
<li><p>单推-单推式</p>
<p>两端分别装止推轴承并预紧，轴向刚度高，预紧力大，<strong>寿命较低</strong></p>
</li>
<li><p>双推-双推式</p>
<p>两端分别装止**<u>推轴承和深沟球轴承的组合并预紧</u><strong>，轴向刚度最高，温度升高会使预紧力增大，</strong>使两端预紧力不对称**</p>
</li>
<li><p>双推-简支式</p>
<p>一端为组合，一端仅深沟球轴承，轴向刚度低，易受热变形影响，预紧力小，寿命高，<strong>用于中速、精度较高的系统</strong></p>
</li>
<li><p>双推-自由式</p>
<p>一端组合，一端悬空，轴向刚度、承载能力低，<strong>用于轻载、低速系统</strong></p>
</li>
</ul>
<h3 id="制动方式"><a href="#制动方式" class="headerlink" title="制动方式"></a>制动方式</h3><p>摩擦离合器</p>
<p>电机通电，线圈通电，弹簧压缩，离合放开</p>
<h3 id="密封与润滑"><a href="#密封与润滑" class="headerlink" title="密封与润滑"></a>密封与润滑</h3><p>密封圈类型：接触式、非接触式</p>
<h2 id="齿轮传动"><a href="#齿轮传动" class="headerlink" title="齿轮传动"></a>齿轮传动</h2><h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h3><ul>
<li>传动比满足驱动与负载的**<u>位移、转矩、转速的匹配要求</u>**</li>
<li>要有足够的刚度，尽量小的转动惯量</li>
<li>避免传动死区（啮合间隙）</li>
</ul>
<h2 id="谐波齿轮"><a href="#谐波齿轮" class="headerlink" title="谐波齿轮"></a><u>谐波齿轮</u></h2><h3 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h3><ul>
<li><p>波发生器</p>
<p>凸轮和薄壁轴承组成</p>
</li>
<li><p>刚轮</p>
<p>刚性内齿轮</p>
</li>
<li><p>柔轮</p>
<p>弹性外齿轮</p>
</li>
</ul>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul>
<li>波发生器为主动件</li>
<li><u><strong>刚轮齿数比柔轮齿数多</strong></u></li>
<li><u><strong>具有双波发生器的谐波齿轮Zg-Zr&#x3D;2</strong></u></li>
<li><strong><u>刚轮固定时，波发生器与柔轮方向相反</u></strong></li>
<li>柔轮固定时，~与刚轮方向相同</li>
</ul>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>传动比大</li>
<li>承载能力强</li>
<li>精度高</li>
<li>效率高</li>
<li>体积小</li>
<li>噪声低</li>
<li>结构简单</li>
</ul>
<h2 id="挠性传动"><a href="#挠性传动" class="headerlink" title="挠性传动"></a>挠性传动</h2><h3 id="同步带传动"><a href="#同步带传动" class="headerlink" title="同步带传动"></a>同步带传动</h3><p>优点</p>
<ul>
<li>传动比准确</li>
<li>效率高</li>
<li>平稳，噪声小</li>
<li>能高速传动，不需润滑</li>
</ul>
<p>缺点</p>
<ul>
<li>安装精度要求高</li>
<li>成本高</li>
</ul>
<h3 id="钢带传动"><a href="#钢带传动" class="headerlink" title="钢带传动"></a>钢带传动</h3><ul>
<li>无间隙</li>
<li>运行可靠</li>
<li>噪声低</li>
<li>无蠕变</li>
<li>摩擦阻力大</li>
</ul>
<h3 id="绳轮传动"><a href="#绳轮传动" class="headerlink" title="绳轮传动"></a>绳轮传动</h3><h1 id="5、导向机构（导轨支撑部件）"><a href="#5、导向机构（导轨支撑部件）" class="headerlink" title="5、导向机构（导轨支撑部件）"></a><u>5、导向机构（导轨支撑部件）</u></h1><p><strong>支撑和限制运动部件按照规定运动方向运动</strong></p>
<h2 id="组成-2"><a href="#组成-2" class="headerlink" title="组成"></a>组成</h2><ul>
<li>承导件</li>
<li>运动件</li>
</ul>
<h2 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h2><h3 id="按运动方式"><a href="#按运动方式" class="headerlink" title="按运动方式"></a>按运动方式</h3><ul>
<li>直线运动导轨副</li>
<li>回转运动导轨副</li>
</ul>
<h3 id="按接触面摩擦性质"><a href="#按接触面摩擦性质" class="headerlink" title="按接触面摩擦性质"></a>按接触面摩擦性质</h3><ul>
<li>滑动</li>
<li>滚道</li>
<li>气体、液体</li>
<li>弹性摩擦</li>
</ul>
<h3 id="按结构特点"><a href="#按结构特点" class="headerlink" title="按结构特点"></a>按结构特点</h3><ul>
<li>开式</li>
<li>闭式</li>
</ul>
<h2 id="要求-2"><a href="#要求-2" class="headerlink" title="要求"></a><u>要求</u></h2><ul>
<li><strong>导向精度</strong></li>
<li><strong>刚度</strong></li>
<li><strong>精度的保持性，取决于耐磨性</strong></li>
<li>运动灵活性</li>
<li>温度敏感性</li>
</ul>
<h2 id="消隙"><a href="#消隙" class="headerlink" title="消隙"></a>消隙</h2><ul>
<li>压板</li>
<li>镶条</li>
</ul>
<h2 id="滚动导轨优缺点"><a href="#滚动导轨优缺点" class="headerlink" title="滚动导轨优缺点"></a><u>滚动导轨优缺点</u></h2><p>优点</p>
<ul>
<li>摩擦小</li>
<li>启动阻力小</li>
<li>可预紧，刚度高</li>
<li>寿命长</li>
<li>精度高</li>
<li>润滑方便</li>
</ul>
<p>缺点</p>
<ul>
<li>抗振性差</li>
<li>对导轨部件尺寸精度要求高</li>
<li>结构复杂成本高</li>
<li>对脏物敏感</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 期末考试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[lzz——绪论]]></title>
      <url>/2023/05/16/%E7%BB%AA%E8%AE%BA/</url>
      <content type="html"><![CDATA[<h1 id="1、什么是机电一体化"><a href="#1、什么是机电一体化" class="headerlink" title="1、什么是机电一体化"></a>1、什么是机电一体化</h1><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>机械工程</li>
<li>电气工程</li>
<li>计算机&#x2F;控制工程</li>
</ul>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>产品和过程</p>
<h2 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h2><p>机械</p>
<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>微电子、计算机控制技术</p>
<h1 id="2、产品分类"><a href="#2、产品分类" class="headerlink" title="2、产品分类"></a>2、产品分类</h1><h2 id="按照结合程度"><a href="#按照结合程度" class="headerlink" title="按照结合程度"></a>按照结合程度</h2><h3 id="机械电子化产品"><a href="#机械电子化产品" class="headerlink" title="机械电子化产品"></a>机械电子化产品</h3><ul>
<li>机械电子化<ul>
<li>机械**<u>本身主要功能</u>**被取代	相机</li>
<li>**<u>信息处理机构</u>**被电子元件替代     电子表</li>
<li>**<u>控制机构</u>**被替代     缝纫机凸轮</li>
<li>微电子技术增加功能   数控机床</li>
</ul>
</li>
</ul>
<h3 id="机电融合产品"><a href="#机电融合产品" class="headerlink" title="机电融合产品"></a>机电融合产品</h3><p>工业机器人、复印机</p>
<h2 id="按使用领域"><a href="#按使用领域" class="headerlink" title="按使用领域"></a>按使用领域</h2><ul>
<li>生产</li>
<li>运输</li>
<li>储存</li>
<li>社会服务</li>
<li>家用</li>
<li>科研</li>
</ul>
<h1 id="3、机电一体化目的"><a href="#3、机电一体化目的" class="headerlink" title="3、机电一体化目的"></a><u>3、机电一体化目的</u></h1><p>使产品<u><strong>高附加值化</strong></u></p>
<ul>
<li>功能</li>
<li>效率</li>
<li>可靠性</li>
<li>省材料、能源</li>
<li>结构轻薄小巧</li>
</ul>
<p>以满足人们生活和生产的**<u>多样化</u>、<u>省力化</u>、<u>自动化需要</u>**</p>
<h1 id="4、机电一体化系统基本组成"><a href="#4、机电一体化系统基本组成" class="headerlink" title="4、机电一体化系统基本组成"></a><u>4、机电一体化系统基本组成</u></h1><h2 id="五大要素与对应功能"><a href="#五大要素与对应功能" class="headerlink" title="五大要素与对应功能"></a><u>五大要素与对应功能</u></h2><ul>
<li>计算机——控制  CPU</li>
<li>动力源——动力  电能</li>
<li>传感器——检测  直线光栅</li>
<li>机构——整体结构功能  机械本体、齿轮传动、导向机构</li>
<li>执行元件——操作  电机</li>
</ul>
<h3 id="机械本体"><a href="#机械本体" class="headerlink" title="机械本体"></a>机械本体</h3><p>包括机身、框架、机械连接</p>
<h3 id="动力源"><a href="#动力源" class="headerlink" title="动力源"></a>动力源</h3><h3 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h3><p>传感器及其信号检测电路，提供控制所需信息</p>
<h3 id="计算机"><a href="#计算机" class="headerlink" title="计算机"></a>计算机</h3><h3 id="执行元件"><a href="#执行元件" class="headerlink" title="执行元件"></a>执行元件</h3><p>实现机电一体化系统<u><strong>主功能</strong></u></p>
<h2 id="主功能"><a href="#主功能" class="headerlink" title="主功能"></a><u>主功能</u></h2><ul>
<li>变化（加工）</li>
<li>传递（运输）</li>
<li>存储</li>
</ul>
<p><u><strong>完成对物质、能量、信息（工业三大要素）的变换、传递、存储</strong></u></p>
<h1 id="5、技术体系"><a href="#5、技术体系" class="headerlink" title="5、技术体系"></a>5、<u>技术体系</u></h1><ul>
<li><p><strong>检测与传感技术</strong></p>
<p>物理到电，处理电信号，实现自动控制的**<u>关键环节</u>**</p>
</li>
<li><p><strong>计算机与信息处理</strong></p>
<p><u>信息处理、人工智能，是促进机电一体化发展的<strong>最活跃因素</strong></u></p>
</li>
<li><p><strong>自动控制</strong></p>
<p>基本控制理论，<u><strong>提高产品精度、效率</strong></u></p>
</li>
<li><p><strong>伺服传动</strong></p>
<p>执行元件、驱动装置，对各项性能起到**<u>决定性影响</u>**</p>
</li>
<li><p><strong>机械技术</strong></p>
<p>机械结构设计、制造</p>
</li>
</ul>
<h2 id="主要学科"><a href="#主要学科" class="headerlink" title="主要学科"></a>主要学科</h2><ul>
<li>机械学</li>
<li>控制论</li>
<li>电子学</li>
<li>计算机科学</li>
</ul>
<h1 id="6、发展趋势"><a href="#6、发展趋势" class="headerlink" title="6、发展趋势"></a>6、<u>发展趋势</u></h1><ul>
<li>绿色化</li>
<li>智能化</li>
<li>网络化</li>
<li>微型化</li>
<li>模块化</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 期末考试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常用的数据通信协议]]></title>
      <url>/2023/02/09/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[<p>最近又用到了iic，但是原理又有些忘记了，刚好就趁这个机会整理一下一些常用的通信协议，主要是针对协议层和寄存器的整理，均以32为例，32有关内容大部分来自《STM32中文参考手册V10》，方便日后查阅温习。</p>
<h1 id="串口协议"><a href="#串口协议" class="headerlink" title="串口协议"></a>串口协议</h1><p>因为也不是初学，同步异步和各种标准就不赘述了,主要讲异步</p>
<h2 id="协议层内容"><a href="#协议层内容" class="headerlink" title="协议层内容"></a>协议层内容</h2><p>串口通讯的数据包由发送设备通过自身的 TXD 接口传输到接收设备的 RXD 接口。在串口通讯 的协议层中，规定了数据包的内容，它由启始位、主体数据、校验位以及停止位组成，通讯双方的数据包格式要约定一致才能正常收发数据</p>
<p>以32为例，每一帧数据由：</p>
<ul>
<li>起始位，为1位逻辑0</li>
<li>数据内容，8或9位</li>
<li>校验位，奇偶校验，准确来说包含在数据内容里，如果需要使用校验，则其为数据内容的最后1位</li>
<li>停止位，常为1or2位逻辑1</li>
</ul>
<p>组成，通信的双方对数据帧格式约定一致才可正常收发数据</p>
<h2 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h2><p>奇偶校验位分为奇校验和偶校验两种，是一种简单的数据误码校验方法。<strong>奇校验是指每帧数据中，包括数据位和奇偶校验位的全部位中1的个数必须为奇数；偶校验是指每帧数据中，包括数据位和奇偶校验位的全部位中1的个数必须为偶数。</strong></p>
<h2 id="波特率"><a href="#波特率" class="headerlink" title="波特率"></a>波特率</h2><p>波特率指数据信号对载波的调制速率，它用单位时间内载波调制状态改变次数来表示，单位为波特。而比特率指单位时间内传输的比特数，单位 bit&#x2F;s(bps)。对于 USART 波特率与比特率相等，波特率越大，传输速率越快。</p>
<p>而STM32的USART的发送器和接收器使用相同的波特率，计算公式为：</p>
<img src="/images/loading.png" data-original="/2023/02/09/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/1.jpg" class title="image1"> 

<p>其中：</p>
<ul>
<li>fck为USART的时钟，而不同的USART挂载在不同的时钟总线上，例如USART1就是挂载在APB2总线上</li>
<li><strong>USARTDIV是一个存放在波特率寄存器（USART_BRR）中的一个无符号定点数</strong>：</li>
</ul>
<img src="/images/loading.png" data-original="/2023/02/09/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/2.jpg" class title="image2">

<p>​	其中， DIV_Mantissa[15:4] 位定义 USARTDIV 的整数部分，DIV_Fraction[3:0] 位定义 USARTDIV 的小数部分</p>
<p>​	对于小数部分，寄存器中存储的值为<strong>实际小数*16</strong>，若不为整数则取近似值；整数部分则直接取16进制</p>
<p>​	例如，假设USARTDIV值为39.0625，则：DIV_Mantissa&#x3D;39&#x3D;0x27，DIV_Fraction&#x3D;0.0625<em>16&#x3D;1&#x3D;0x01&#x3D;0x1,最终USART_BRR存储的值为：0x0271，*<em>此结果是当fck为72MHz时比特率为115200bps的配置值。</em></em></p>
<h2 id="通信的起始和停止"><a href="#通信的起始和停止" class="headerlink" title="通信的起始和停止"></a>通信的起始和停止</h2><ul>
<li>空闲帧：在双方没有发送或接收数据时，此时数据帧可以被视作1个完全由1组成的完整数据帧</li>
<li>断开帧：被视作全为0的帧</li>
</ul>
<h2 id="相关寄存器"><a href="#相关寄存器" class="headerlink" title="相关寄存器"></a>相关寄存器</h2><img src="/images/loading.png" data-original="/2023/02/09/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3.jpg" class title="image3">

<p>一些比较常用的就不写了</p>
<h3 id="功能引脚"><a href="#功能引脚" class="headerlink" title="功能引脚"></a>功能引脚</h3><ul>
<li><p>SW_RX：只用于单线和智能卡模式，属于内部引脚，没有具体外部引脚</p>
</li>
<li><p>nRTS：请求以发送 (Request To Send)，n 表示低电平有效。如果使能 RTS 流控制，<strong>当 USART 接 收器准备好接收新数据时就会将 nRTS 变成低电平</strong>；当接收寄存器已满时，nRTS 将被设置为高 电平。<strong>该引脚只适用于硬件流控制</strong></p>
</li>
<li><p>nCTS：清除以发送 (Clear To Send)，n 表示低电平有效。如果使能 CTS 流控制，发送器在发送下 一帧数据<strong>之前</strong>会检测 nCTS 引脚，<strong>如果为低电平，表示可以发送数据，如果为高电平则在发送完当前数据帧之后停止发送（也就是下一帧不会被发送）</strong>。该引脚<strong>只适用于硬件流控制</strong>。</p>
<table>
<thead>
<tr>
<th align="center">STM32F10x</th>
<th align="center">USART1</th>
<th align="center">USART2</th>
<th align="center">USART3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">nCTS</td>
<td align="center">PA11</td>
<td align="center">PA0</td>
<td align="center">PB13</td>
</tr>
<tr>
<td align="center">nRTS</td>
<td align="center">PA12</td>
<td align="center">PA1</td>
<td align="center">PB14</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="数据寄存器DR"><a href="#数据寄存器DR" class="headerlink" title="数据寄存器DR"></a>数据寄存器DR</h3><p>USART 数据寄存器 (USART_DR) 只有低 9 位有效，并且第 9 位数据是否有效要取决于 USART 控制寄存器 1(USART_CR1) 的 M 位设置，当 M 位为 0 时表示 8 位数据字长，当 M 位为 1 表示 9 位数据字长，我们一般使用 8 位数据字长。</p>
<p>USART_DR 包含了已发送的数据或者接收到的数据。<strong>USART_DR 实际是包含了两个寄存器，一 个专门用于发送的可写 TDR，一个专门用于接收的可读 RDR。</strong>当进行发送操作时，往 USART_DR 写入数据会自动存储在 TDR 内；当进行读取操作时，向 USART_DR 读取数据会自动提取 RDR 数据。</p>
<p>TDR 和 RDR 都是<strong>介于系统总线和移位寄存器之间</strong>。串行通信是一个位一个位传输的，<strong>发送时把 TDR 内容转移到发送移位寄存器，然后把移位寄存器数据每一位发送出去，接收时把接收到的每一位顺序保存在接收移位寄存器内然后才转移到 RDR</strong></p>
<h3 id="控制器CR、SR"><a href="#控制器CR、SR" class="headerlink" title="控制器CR、SR"></a>控制器CR、SR</h3><img src="/images/loading.png" data-original="/2023/02/09/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/4.jpg" class title="image4">

<h4 id="发送器"><a href="#发送器" class="headerlink" title="发送器"></a>发送器</h4><p>USART_CR1分为两部分，一部分为上面一排，用于配置串口的有唤醒单元、中断控制等等，另一部分为图中下面一排，用于控制USART的发送器</p>
<ul>
<li><strong>UE：</strong>首先，若要<strong>激活该USART</strong>，需要先将USART_CR1寄存器上的UE位置位</li>
<li><strong>M：</strong>M用于<strong>定义字长</strong>，8or9</li>
<li><strong>STOP[1:0] ：</strong>若要<strong>控制帧的停止位长度</strong>，可以通过 USART 控制寄存器 2(USART_CR2) 的 STOP[1:0] 位控制</li>
<li><strong>TE：</strong>当USART_CR1发送使能位 TE 置 1 之后<strong>（发送使能）</strong>，发送器开始会先发送一个空闲帧 (一个数据帧长度的高电平)，接下 来就可以往 USART_DR 寄存器写入要发送的数据。</li>
<li><strong>TC：</strong>在写入最后一个数据后，需要等待 USART 状态寄存器 (USART_SR) 的 TC 位为 1，<strong>表示数据传输完成</strong></li>
<li><strong>TCIE：</strong>如果 USART_CR1 寄存器的 TCIE 位置 1，<strong>TC置位后将产生中断</strong>。</li>
<li><strong>TXE：</strong>由硬件设置，置位则表明：数据已经从TDR移送到<strong>移位寄存器</strong>，且TDR已清空，数据发送已经开始，下一个数据可以被写进TDR。</li>
<li><strong>TXEIE：</strong>如果被设置，TXE的置位会产生一个中断</li>
</ul>
<p>其他的位不太常用，需要的话再下来查</p>
<h4 id="接收器"><a href="#接收器" class="headerlink" title="接收器"></a>接收器</h4><ul>
<li><strong>RE：</strong>USART接收使能，使能后开始等待接收数据帧起始位，对于起始位的侦测有一套严格的侦测方法，但是我没怎么看懂&#x2F;吹口哨，STM32中文参考手册中有详细讲，感兴趣可以去看下</li>
<li><strong>RXNE：</strong>与接收器的TXE相似，表示当前数据已被读取（包括有关的错误标志），<strong>数据已经进入RDR</strong>，随时可以被读取</li>
<li><strong>RXNEIE：</strong>RXNE对应中断</li>
</ul>
<p>有关一些错误标志我也不整理了，感觉基本比较少遇到</p>
<h4 id="校验控制"><a href="#校验控制" class="headerlink" title="校验控制"></a>校验控制</h4><p>将 USART_CR1 寄存器的 PCE 位置 1 就可以启动奇偶校验控制，奇偶校验由硬件自动完成。启 动了奇偶校验控制之后，在发送数据帧时会自动添加校验位，接收数据时自动验证校验位。接收 数据时如果出现奇偶校验位验证失败，会见 USART_SR 寄存器的 PE 位置 1，并可以产生奇偶校验中断。</p>
<p>偶校验PS位为0，奇校验为1</p>
<h4 id="中断事件"><a href="#中断事件" class="headerlink" title="中断事件"></a>中断事件</h4><table>
<thead>
<tr>
<th align="center">中断事件</th>
<th align="center">事件标志位（该位引起中断）</th>
<th align="center">中断使能控制位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">发送数据寄存器TDR为空</td>
<td align="center">TXE</td>
<td align="center">IXEIE</td>
</tr>
<tr>
<td align="center">CTS 标志</td>
<td align="center">CTS</td>
<td align="center">CTSIE</td>
</tr>
<tr>
<td align="center">发送完成</td>
<td align="center">TC</td>
<td align="center">TCIE</td>
</tr>
<tr>
<td align="center">准备好读取接收到的数据（接收移位寄存器为空）</td>
<td align="center">RXNE</td>
<td align="center">RXNEIE</td>
</tr>
<tr>
<td align="center">检测到上溢错误</td>
<td align="center">ORE</td>
<td align="center">RXNEIE</td>
</tr>
<tr>
<td align="center">测到空闲线路</td>
<td align="center">IDLE</td>
<td align="center">IDLEIE</td>
</tr>
<tr>
<td align="center">奇偶校验错误</td>
<td align="center">PE</td>
<td align="center">PEIE</td>
</tr>
<tr>
<td align="center">断路标志</td>
<td align="center">LBD</td>
<td align="center">LBDIE</td>
</tr>
<tr>
<td align="center">多缓冲通信中的噪声标志、上溢错误和帧错误</td>
<td align="center">NF&#x2F;ORE&#x2F;FE</td>
<td align="center">EIE</td>
</tr>
</tbody></table>
<h1 id="IIC协议"><a href="#IIC协议" class="headerlink" title="IIC协议"></a>IIC协议</h1><p>I2C 通讯协议 (Inter － Integrated Circuit) 是由 Phiilps 公司开发的，由于它引脚少，硬件实现简单， 可扩展性强，不需要 USART、CAN 等通讯协议的外部收发设备，现在被广泛地使用在系统内多 个集成电路 (IC) 间的通讯</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>物理层不是本篇重点，就简单讲一下。</p>
<img src="/images/loading.png" data-original="/2023/02/09/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/5.jpg" class title="image5">

<p>IIC是一个支持多设备的总线，在一个IIC通讯总线中，可以连接多个通讯设备，它们都可以是主机或从机（主机可以简单理解为发送数据的一端，从机则为接收一端）</p>
<p>一个 IIC总线只使用两条总线线路，一条双向串行数据线 (SDA) ，一条串行时钟线 (SCL)。 数据线即用来表示数据，时钟线用于数据收发同步，且每个连接到总线的设备都有一个独立的地址，主机可以利用这个地址进行不同设备之间的访问。</p>
<h2 id="协议层"><a href="#协议层" class="headerlink" title="协议层"></a>协议层</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在IIC总线空闲（初始）时，SCL和SDA都为高电平</p>
<h3 id="特殊信号"><a href="#特殊信号" class="headerlink" title="特殊信号"></a>特殊信号</h3><img src="/images/loading.png" data-original="/2023/02/09/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/6.jpg" class title="image6">

<p>I2C 总线在传送数据过程中共有三种类型信号， 它们分别是：<strong>开始信号、结束信号和应答信号</strong></p>
<ul>
<li><p>起始信号：SCL 为<strong>高电平</strong>时，SDA 由<strong>高电平向低电平跳变</strong>，开始传送数据。</p>
</li>
<li><p>停止信号：SCL 为<strong>高电平</strong>时，<strong>SDA 由低电平向高电平跳变</strong>，结束传送数据。</p>
</li>
<li><p>应答信号：接收数据的设备<strong>在接收到8位数据后</strong>，<strong>向发送数据的设备发出特定的低电平脉冲</strong>，表示已收到数据。应答信号的出现次数与数据长度有关，每接收8位数据后接收端都会向发送端发出一个应答信号</p>
<ul>
<li>有效应答位：SCL为高电平时，SDA为低电平</li>
<li>非应答位：~，SDA为高电平</li>
</ul>
<p><strong>当一个字节按数据位从高位到低位的顺序传输完后，紧接着从设备将拉低SDA线，回传给主设备一个应答位ACK， 此时才认为一个数据帧真正地被传输完成</strong></p>
</li>
</ul>
<p>为确保稳定性，每次电平转换的时间要&gt;4.7us</p>
<h3 id="数据有效性"><a href="#数据有效性" class="headerlink" title="数据有效性"></a>数据有效性</h3><img src="/images/loading.png" data-original="/2023/02/09/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/7.jpg" class title="image7">

<p>为了不将刚刚讲到的起始、停止信号误识别为数据内容，IIC协议规定了在数据传输过程中，<strong>当SCL&#x3D;1高电平时，数据线SDA必须保持稳定状态，不允许有电平跳变</strong>，而起始、停止信号则刚好是在SCL&#x3D;1高电平时在SDA上发生电平跳变，这样起始、停止信号就和数据传输很好的区分开了。并且当<strong>SCL&#x3D;1时，数据线SDA的任何电平变换会看做是总线的起始信号或者停止信号而不是数据内容。</strong>只有在时钟线上的信号为低电平期间，数据线上的高电平或低电平状态才允许变化，因为SCL为低时，SDA的数据是无效的，不读取的。</p>
<p>这样就可以理解为，当SCL&#x3D;1高电平时为读取SDA也就是数据的过程，每一次SCL的高电平读取1位SDA数据，在SCL&#x3D;0低电平时，SDA可以改变，为下一次SCL高电平的读取做准备</p>
<h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>多数IIC设备的地址为7位或10位，通常位7位。在地址最后还要加上1位的读&#x2F;写地址，<strong>所以设备地址为8位</strong></p>
<p>对于读&#x2F;写地址位：</p>
<ul>
<li>0表示主设备向从设备<strong>写数据</strong></li>
<li>1表示主设备从从设备<strong>读数据</strong></li>
</ul>
<p>例如，对于手势识别模块PAJ7620，当我们要向模块发送数据时，就要先向该模块的地址发送指定数据内容将其读&#x2F;写地址位设置为0.次数该设备才可以接收主设备写来的数据</p>
<h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><ul>
<li>主机先产生<strong>起始信号</strong></li>
<li>紧接着发送一个<strong>设备地址</strong>，该设备地址由7位从机地址+1位数据方向位组成，此时方向位为0</li>
<li>主机将地址发送到总线上的过程中，总线上的其他设备会同时将地址逐位<strong>与自己的地址相比较</strong>，当7位从机地址匹配成功后，根据第八位数据方向位将该设备确定为发送&#x2F;接收器。</li>
<li>由于地址数据也算作一帧数据，所以在设备匹配成功后，从机将会发送1个应答信号</li>
<li>对于PAJ7620，此时需要对其寄存器进行初始化，初始化成功后从机会返回1个应答信号</li>
<li>此后主机、从机之间便可正常通讯</li>
<li>若要停止该通信，需要主机发送<strong>1个停止信号</strong></li>
<li>若要改变数据传输方向，在从机初始化完成后，主机需要再重新产生1个起始信号；之后发送设备地址，此时方向位应为1；最后主机将自身SDA的IO口设置为输入模式；</li>
</ul>
<h2 id="STM32的IIC硬件"><a href="#STM32的IIC硬件" class="headerlink" title="STM32的IIC硬件"></a>STM32的IIC硬件</h2><p>STM32 的 I2C 外设可用作通讯的主机及从机，支持 100Kbit&#x2F;s 和 400Kbit&#x2F;s 的速率，支持 7 位、10 位设备地址，支持 DMA 数据传输，并具有数据校验功能</p>
<table>
<thead>
<tr>
<th align="center">STM32F10x</th>
<th align="center">IIC1</th>
<th align="center">IIC2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SCL</td>
<td align="center">PB6&#x2F;PB8（重映射）</td>
<td align="center">PB10</td>
</tr>
<tr>
<td align="center">SDA</td>
<td align="center">PB7&#x2F;PB9（重映射）</td>
<td align="center">PB11</td>
</tr>
</tbody></table>
<img src="/images/loading.png" data-original="/2023/02/09/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/8.jpg" class title="image8">

<h3 id="时钟逻辑"><a href="#时钟逻辑" class="headerlink" title="时钟逻辑"></a>时钟逻辑</h3><p>STM32 的I2C外设都挂载在APB1总线上，使用APB1的时钟源 PCLK1，具体的SCL时钟计算不细讲了</p>
<h3 id="数据控制逻辑"><a href="#数据控制逻辑" class="headerlink" title="数据控制逻辑"></a>数据控制逻辑</h3><p>I2C 的 SDA 信号主要连接到数据移位寄存器上，数据移位寄存器的数据来源及目标是数据寄存器 (DR)、地址寄存器 (OAR)、PEC 寄存器以及 SDA 数据线。</p>
<h4 id="数据寄存器DR-1"><a href="#数据寄存器DR-1" class="headerlink" title="数据寄存器DR"></a>数据寄存器DR</h4><p>当向外发送数据的时候，数据移位寄存器以DR为数据源，把数据一位一位地通过 SDA 信号线发送出去；当从外部接收数据的时候，数据移位寄存器把 SDA 信号线采样到的数据一位一位地存储到DR中。 </p>
<h4 id="帧错误校验计算PEC"><a href="#帧错误校验计算PEC" class="headerlink" title="帧错误校验计算PEC"></a>帧错误校验计算PEC</h4><p>若使能了数据校验，接收到的数据会经过 PCE 计算器运算，运算结果存储在“PEC 寄存器”中。 </p>
<h4 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h4><p>当 STM32 的 I2C 工作在<strong>从机模式</strong>的时候，接收到设备地址信号时，数据移位寄存器会把接收到 的地址与 STM32 的自身的“I2C 地址寄存器”的值作比较，以便响应主机的寻址。STM32 的自 身 I2C 地址可通过修改“自身地址寄存器”修改，<strong>支持同时使用两个 I2C 设备地址，两个地址分别存储在 OAR1 和 OAR2 中</strong></p>
<h3 id="整体控制逻辑"><a href="#整体控制逻辑" class="headerlink" title="整体控制逻辑"></a>整体控制逻辑</h3><p>整体控制逻辑负责协调整个 I2C 外设，控制逻辑的工作模式根据我们配置的“控制寄存器 (CR1&#x2F;CR2)”的参数而改变。在外设工作时，控制逻辑会根据外设的工作状态修改“状态寄存器 (SR1 和 SR2)”，我们只要读取这些寄存器相关的寄存器位，就可以了解 I2C 的工作状态。除此之外，控制逻辑还根据要求，负责控制产生 I2C 中断信号、DMA 请求及各种 I2C 的通讯信号 (起始、停止、响应信号等)。</p>
<h3 id="硬件通讯过程"><a href="#硬件通讯过程" class="headerlink" title="硬件通讯过程"></a>硬件通讯过程</h3><h4 id="发送器-1"><a href="#发送器-1" class="headerlink" title="发送器"></a>发送器</h4><img src="/images/loading.png" data-original="/2023/02/09/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/9.jpg" class title="image9">

<p>发送流程：</p>
<ul>
<li>当发生起始信号后，它产生事件“EV5”，并会对 SR1 寄存器的“SB” 位置 1，表示起始信号已经发送</li>
<li>紧接着发送设备地址并等待应答信号，若有从机应答，则产生事件“EV6”及“EV8”，这 时 SR1 寄存器的“ADDR”位及“TXE”位被置 1，<strong>ADDR 为 1 表示地址已经发送，TXE 为 1 表示数据寄存器为空</strong></li>
<li>以上步骤正常执行并对 ADDR 位清零后，我们往 I2C 的“数据寄存器 DR”写入要发送的数据，这时 TXE 位会被重置 0，表示数据寄存器非空，I2C 外设通过 SDA 信号线一位位把数据发送 出去后，又会产生“EV8”事件，即 TXE 位被置 1，重复这个过程，就可以发送多个字节数据了</li>
<li>发送数据完成后，控制 I2C 设备产生一个停止信号 (P)，这个时候会产生 EV8_2 事件，SR1 的 TXE 位及 BTF 位都被置 1，表示通讯结束</li>
</ul>
<h4 id="接收器-1"><a href="#接收器-1" class="headerlink" title="接收器"></a>接收器</h4><img src="/images/loading.png" data-original="/2023/02/09/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/10.jpg" class title="image10">

<p>可以参考发送器，应该可以推测出来</p>
<h2 id="软件IIC和硬件IIC的选择"><a href="#软件IIC和硬件IIC的选择" class="headerlink" title="软件IIC和硬件IIC的选择"></a>软件IIC和硬件IIC的选择</h2><p>由硬件处理IIC可以减轻CPU的负担，但是配置和使用起来都较为复杂；软件模拟IIC由于是由CPU控制整个通讯时序和引脚状态，CPU占用会更多，但是相对的使用起来会比较方便，且便于移植。</p>
<h1 id="SPI协议"><a href="#SPI协议" class="headerlink" title="SPI协议"></a>SPI协议</h1><p>SPI 协议是由摩托罗拉公司提出的通讯协议 (Serial Peripheral Interface)，即串行外围设备接口，是 一种高速全双工的通信总线。它被广泛地使用在 ADC、LCD 等设备与 MCU 间，要求通讯速率 较高的场合。</p>
<h2 id="物理层-1"><a href="#物理层-1" class="headerlink" title="物理层"></a>物理层</h2><img src="/images/loading.png" data-original="/2023/02/09/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/11.jpg" class title="image11">

<p>SPI使用3条总线和片选线，3 条总线分别为 SCK、MOSI、MISO；片选线（也称为 NSS、CS）用于主机片选设备：</p>
<ul>
<li><p>片选信号线：当有多个 SPI 从设备与 SPI 主机相连时，设备的其它信号线 SCK、MOSI 及 MIS O 同时并联到相同的 SPI 总线上，<strong>即无论有多少个从设备，都共同只使用这 3 条总线</strong>；而每个从设备都有独立的这一条 NSS 信号线，本信号线独占主机的一个引脚，<strong>即有多少个从设备，就 有多少条片选信号线。</strong></p>
<p>当主机要选择从设备时， 把该从设备的 NSS 信号线设置为低电平，该从设备即被选中，即片选有效，接着主机开始与被选中的从设备进行 SPI 通讯。<strong>所以 SPI 通讯以 NSS 线置低电平为开始信号，以 NSS 线被拉高作为结束信号。</strong></p>
</li>
<li><p>SCK时钟线：用于通讯数据同步。它由通讯主机产生，决定了通讯的速率</p>
</li>
<li><p>MOSI：主设备输出&#x2F;从设备输入引脚。</p>
</li>
<li><p>MISO：主设备输入&#x2F;从设备输出引脚。</p>
</li>
</ul>
<p>需要注意的是，不同于串口中，主机的TX对应从机的RX，SPI中主机和从机的MOSI和MISO是<strong>一一对应的</strong></p>
<h2 id="协议层-1"><a href="#协议层-1" class="headerlink" title="协议层"></a>协议层</h2><h3 id="时钟极性与相位"><a href="#时钟极性与相位" class="headerlink" title="时钟极性与相位"></a>时钟极性与相位</h3><p>对于STM32，SPI_CR寄存器中有CPOL和CPHA位，其中CPOL位控制时钟极性，CPHA控制时钟相位。</p>
<ul>
<li>CPOL时钟极性：<ul>
<li>置0：SCK在空闲时为低电平</li>
<li>置1：SCK在空闲时为高电平</li>
</ul>
</li>
<li>CPHA时钟相位：<ul>
<li>置0：将SCK时钟第一边沿用作数据位采样</li>
<li>置1：将SCK时钟第二边沿用作数据采样</li>
</ul>
</li>
</ul>
<p>因此，基于不同配置的CPOL和CPHA，SPI一共有四种通讯时序：</p>
<table>
<thead>
<tr>
<th align="center">CPOL \ CPHA</th>
<th align="center">0</th>
<th align="center">1</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">检测上升沿</td>
<td align="center">检测下降沿</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">检测下降沿</td>
<td align="center">检测上升沿</td>
</tr>
</tbody></table>
<img src="/images/loading.png" data-original="/2023/02/09/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/12.jpg" class title="image12">

<h3 id="起始信号和停止信号"><a href="#起始信号和停止信号" class="headerlink" title="起始信号和停止信号"></a>起始信号和停止信号</h3><p>通讯的开始与结束由片选信号线控制，当主机要选择从设备时， 把该从设备的 NSS 信号线设置为低电平，该从设备即被选中，即片选有效，接着主机开始与被选中的从设备进行 SPI 通讯。<strong>所以 SPI 通讯以 NSS 线置低电平为开始信号，以 NSS 线被拉高作为结束信号。</strong></p>
<h3 id="数据位切换"><a href="#数据位切换" class="headerlink" title="数据位切换"></a>数据位切换</h3><p>由上图可以观察出，数据位根据时钟配置不同，采样点也不同</p>
<ul>
<li>当CPHA时钟相位为0时，SCK第一个信号边沿用于采集数据，第二个信号边沿用于切换数据位，为下一次采样做准备</li>
<li>当CPHA时钟相位为1时，SCK第一个信号边沿用于数据位切换，第二个信号边沿用于采集数据</li>
</ul>
<p>同时，每个数据帧根据寄存器SPI_CR1寄存器的DFF的配置可以配置为8位或16位</p>
<h2 id="STM32的SPI硬件"><a href="#STM32的SPI硬件" class="headerlink" title="STM32的SPI硬件"></a>STM32的SPI硬件</h2><img src="/images/loading.png" data-original="/2023/02/09/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/13.jpg" class title="image13">

<p>具体的寄存器每一位的功能请参考<a href="https://blog.csdn.net/k666499436/article/details/124882583?ops_request_misc=%7B%22request_id%22:%22167673150616800182736214%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=167673150616800182736214&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-6-124882583-null-null.142%5Ev73%5Einsert_down3,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=spi%E5%8D%8F%E8%AE%AEstm32&spm=1018.2226.3001.4187">STM32SPI协议通信详解_rivencode的博客-CSDN博客_stm32spi通信</a>，讲的很详细，这里我主要讲一下主机模式下的发送流程：</p>
<img src="/images/loading.png" data-original="/2023/02/09/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/14.jpg" class title="主机发送流程">

<ul>
<li><p>NSS片选线产生信号，选择设备</p>
</li>
<li><p>第一次发送时，发送缓冲区为空，因此表示其为空的TXE标志在最开始会一直为高电平</p>
</li>
<li><p>第一次发送时，第一帧数据0xF1在时钟信号产生的同时被存入发送缓冲区中，等待被发出，此时TXE为0，表示发送缓冲区非空</p>
</li>
<li><p><strong>1个时钟周期之后</strong>，0xF1从发送缓冲区被移入移位寄存器，同时把第0位数据从移位寄存器发出，此时发送寄存器被清空，TXE硬件置1</p>
<p><strong>与此同时，</strong>从机端也发送了1位数据至接收缓冲区中</p>
</li>
<li><p>在这之后，<strong>第二帧数据（不是第二位！）</strong>在1个时钟周期后被存入发送缓冲区中等待下一次的转移。发送缓冲区非空，TXE置0</p>
</li>
<li><p>与此同时，每过1个时钟周期，主机端移位寄存器发送出1位数据，接收缓冲区存入1位数据，1帧数据在8个时钟周期后被完全发送出。同时主机也收到1帧完整数据，此时RXNE标志置位，此时第一帧数据正式发送完毕</p>
</li>
<li><p>此后数据从上述第四点开始循环</p>
</li>
</ul>
<p>假如我们使能了 TXE 或 RXNE 中断，TXE 或 RXNE 置 1 时会产生 SPI 中断信号，进入同一个中断服务函数，到 SPI 中断服务程序后，可通过检查寄存器位来了解是哪一个事件，再分别进行处理。也可以使用 DMA 方式来收发接收缓冲区中的数据。</p>
]]></content>
      
        
        <tags>
            
            <tag> 嵌入式学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++-动态内存]]></title>
      <url>/2023/02/02/Cjj9/</url>
      <content type="html"><![CDATA[<h1 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h1><p>博客截止到目前的C++部分都只使用了静态内存和栈内存。</p>
<p>静态内存用于保存局部static对象、类的static数据成员和任何定义在函数之外的变量。</p>
<p>栈内存用于保存定义在函数内的非静态变量。</p>
<p>分配在静态内存和栈内存中的对象都由编译器控制它们的创建和销毁：C++中静态对象在<strong>该对象被首次用到</strong>时分配内存（C中是在编译期间初始化）；栈内存在其定义的程序块运行时分配内存。</p>
<p>除了以上两个内存区，每个程序还拥有一个内存池，这部分被称作自由空间或<strong>堆</strong>。堆用于存储动态分配的对象，即由程序本身来控制生存期的对象。</p>
<h1 id="动态内存与智能指针"><a href="#动态内存与智能指针" class="headerlink" title="动态内存与智能指针"></a>动态内存与智能指针</h1><p>由于动态内存对象是由程序控制，因此其内存的使用很容易出问题。为了更安全、方便地使用动态内存，标准库提供了两种智能指针，该指针与常规指针的重要区别是<strong>智能指针负责自动释放所指向的对象</strong>，并且智能指针是模板。两种智能制造的区别在于管理底层指针的方式：</p>
<ul>
<li>shared_ptr类型允许多个指针指向同一个对象</li>
<li>unique_ptr则只允许存在一个指针指向一个对象</li>
</ul>
<p>它们被定义在头文件memory中</p>
<h2 id="1、shared-ptr类"><a href="#1、shared-ptr类" class="headerlink" title="1、shared_ptr类"></a>1、shared_ptr类</h2><p>智能指针也是一个模板，类似于vector等类型，对智能指针的初始化也要提供指针指向的类型这一信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; p1;</span><br><span class="line">shared_ptr&lt;vector&lt;<span class="type">int</span>&gt;&gt; p2;</span><br></pre></td></tr></table></figure>

<p>智能指针的操作基本于常规指针相同，当然其作为一个模板也有自己特有的操作：</p>
<p>shared_ptr和unique_ptr均支持的操作</p>
<table>
<thead>
<tr>
<th align="center">p</th>
<th align="center">可用作一个条件判断，若p指向了一个对象则返回true</th>
</tr>
</thead>
<tbody><tr>
<td align="center">*p</td>
<td align="center">~</td>
</tr>
<tr>
<td align="center">p.get()</td>
<td align="center">返回p中保存的指针</td>
</tr>
<tr>
<td align="center">swap(p1,p2)&#x2F;p1.swap(q)</td>
<td align="center">交换p和q中的指针</td>
</tr>
</tbody></table>
<h3 id="make-shared函数"><a href="#make-shared函数" class="headerlink" title="make_shared函数"></a>make_shared函数</h3><p>make_shared函数被定义在标准库中，该函数可以在动态内存中分配一个对象并初始化，并返回指向该对象的shared_ptr。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; sp=<span class="built_in">make_shared</span>&lt;string&gt;(<span class="string">&quot;dhk&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>因为该函数会返回一个对应指向类型的shared_prt，因此也可以直接使用auto来保存函数make_shared的结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sp=<span class="built_in">make_shared</span>&lt;string&gt;(<span class="string">&quot;dhk&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>另外，make_shared函数支持参数用作构造，其用法于顺序容器的成员emplace相似，参数顺序等需严格遵守构造函数内容，详见<a href="https://dhkkk.gitee.io/2023/01/12/C++-8/">C++-顺序容器 | 小董的BLOG (gitee.io)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sp=<span class="built_in">make_shared</span>&lt;string&gt;(<span class="number">10</span>,<span class="string">&#x27;d&#x27;</span>);<span class="comment">//使用构造</span></span><br></pre></td></tr></table></figure>

<h3 id="shared-ptr的拷贝和赋值"><a href="#shared-ptr的拷贝和赋值" class="headerlink" title="shared_ptr的拷贝和赋值"></a>shared_ptr的拷贝和赋值</h3><p>当在进行拷贝和赋值时，每个shared_ptr都会实时地记录当前有多少个shared_ptr指向相同的对象，称之为<strong>引用计数</strong>，一但一个shared_ptr的计数器变为0，则会自动释放自己所管理的对象。</p>
<p><strong>当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁这个对象。</strong>该操作通过类的一个成员函数——析构函数完成。</p>
<p>如果该shared_ptr是作为局部变量导致被自动销毁，析构函数同样会对引用计数进行递减操作</p>
<h2 id="2、直接管理内存"><a href="#2、直接管理内存" class="headerlink" title="2、直接管理内存"></a>2、直接管理内存</h2><p>C++定义了两个运算符来直接分配和释放内存：new用于分配内存，delete用于释放内存</p>
<h3 id="使用new分配动态内存"><a href="#使用new分配动态内存" class="headerlink" title="使用new分配动态内存"></a>使用new分配动态内存</h3><p>在堆中的分配的内存是无名的，因此无论是make_shared还是new都无法为分配空间的对象命名，取而代之的是返回一个指向该内存的指针。</p>
<p>几种初始化方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p= <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">auto</span> p= <span class="keyword">new</span> <span class="type">int</span>;<span class="comment">//不定义值</span></span><br><span class="line"><span class="type">int</span> *p= <span class="keyword">new</span> <span class="built_in">int</span>();<span class="comment">//进行值默认初始化</span></span><br><span class="line"><span class="type">int</span> *p= <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">auto</span> p= <span class="keyword">new</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以使用new分配const对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="type">const</span> <span class="built_in">int</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，new和delete<strong>都是运算符，而不是关键字！</strong>因此<code>const new int()</code>是不合法的</p>
<p>如果堆内存耗尽，无法再分配新的内存，则new表达式会失败，抛出一个bad_alloc，如果不想其抛出异常，可以使用<strong>定位new</strong>的方式阻止其抛出异常：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">new</span>(nothrow) <span class="type">int</span>;<span class="comment">//此时如果分配失败，则只会返回一个空指针</span></span><br></pre></td></tr></table></figure>

<p><strong>使用定位new需要包含头文件new</strong></p>
<h3 id="使用delete释放内存"><a href="#使用delete释放内存" class="headerlink" title="使用delete释放内存"></a>使用delete释放内存</h3><p>通过delete表达式可以将指定的动态内存释放，使用时需注意：</p>
<ul>
<li>delete的对象必须是一个指针</li>
<li><strong>该指针只能指向一块动态内存或为空</strong>，不能指向静态内存或栈内存</li>
<li>动态内存中的const对象可以被正常释放</li>
<li>不能多次释放同一块内存</li>
</ul>
<h3 id="内置指针的缺陷"><a href="#内置指针的缺陷" class="headerlink" title="内置指针的缺陷"></a>内置指针的缺陷</h3><p>上一节中讲到，对于shared_ptr管理的内存，是会根据引用计数自动释放内存的。而通过常规指针保存动态内存的方式无法像智能指针一样自动释放，<strong>也就是通过new表达式创建的动态内存空间必须显式地手动释放</strong></p>
<p>因此，使用者必须记得在不使用时删除这块内存，如果指向该内存的常规指针指向改变，这块内存就无法被释放了（因为已经找不到了），所以最好的办法是将该指针定义为常量指针，虽然这样也仅仅能避免地址丢失的发生</p>
<h3 id="混合使用shared-ptr和new"><a href="#混合使用shared-ptr和new" class="headerlink" title="混合使用shared_ptr和new"></a>混合使用shared_ptr和new</h3><p>可以使用一个指向动态内存的内置指针来初始化一个智能指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">100</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用时需注意：</p>
<ul>
<li><p>用于初始化智能指针的参数<strong>必须是一个指向动态内存的指针</strong></p>
</li>
<li><p><strong>必须用直接初始化的方式初始化智能指针，而不是赋值初始化，因为接受指针为参数的构造函数是explicit的</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p1= <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>);<span class="comment">//错误！必须直接初始化</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>内置指针不能实现隐式转化为智能指针，这也是不能通过赋值初始化的原因👆</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">test</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">new</span> <span class="built_in">int</span>(a));<span class="comment">//错误，不能隐式转化</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt; (<span class="keyword">new</span> <span class="built_in">int</span>(a));<span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过这个方法构造的shared_ptr默认使用delete来释放内存，而不是之前讲到的析构函数。因此如果要将该shared_ptr指向其他的动态内存，但是这样做就必须提供自己的操作来代替delete，这个操作后面会讲到。</p>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> C++学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++-顺序容器]]></title>
      <url>/2023/01/12/C++-8/</url>
      <content type="html"><![CDATA[<h1 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h1><p>容器：一些特定类型对象的集合。顺序容器提供了控制元素存储和访问顺序的能力，且该顺序与元素的内容无关，而与元素加入容器时的位置相关</p>
<h2 id="标准库中的顺序容器"><a href="#标准库中的顺序容器" class="headerlink" title="标准库中的顺序容器"></a>标准库中的顺序容器</h2><p>C++中提供了多种多种顺序容器，这些容器根据下两方面性能的选择都有不同的折中：</p>
<ul>
<li>向容器中不同位置添加、删除元素的代价</li>
<li>非顺序访问容器中的元素的代价</li>
</ul>
<table>
<thead>
<tr>
<th>vector</th>
<th>可变大小数组；支持快速任意元素随机访问；在尾部之外插入元素代价较大</th>
</tr>
</thead>
<tbody><tr>
<td>deque</td>
<td>双端队列；支持快速任意元素随机访问；<strong>在头、尾部之外</strong>插入元素代价较大</td>
</tr>
<tr>
<td>list</td>
<td>双向链表；只支持双向<strong>顺序访问</strong>，不支持随机访问；任何位置插入元素速度都快</td>
</tr>
<tr>
<td>forward_list</td>
<td>单向链表，只支持单向顺序访问，其余同双向链表</td>
</tr>
<tr>
<td>array</td>
<td>固定大小数组；支持快速任意元素随机访问；不能添加、删除元素</td>
</tr>
<tr>
<td>string</td>
<td>字符串，与vector相似，专门用于保存字符；在尾部之外插入元素代价较大</td>
</tr>
</tbody></table>
<p>array是C++新标准添加的类型，比内置的数组更加安全、更容易使用</p>
<h2 id="选择顺序容器的原则"><a href="#选择顺序容器的原则" class="headerlink" title="选择顺序容器的原则"></a>选择顺序容器的原则</h2><ul>
<li><p>通常，使用vector是最好的选择</p>
</li>
<li><p>如果需存放的元素很多、元素很小，并且空间的开销很重要，则<strong>不要选择</strong>list或forward_list</p>
</li>
<li><p>其余原则根据：</p>
<ul>
<li>程序是否要随机访问元素</li>
<li>程序是否要在中间、头部、尾部插入元素</li>
</ul>
<p>进行选择</p>
</li>
<li><p>如果程序只在读取输入时才需要在中间位置插入元素，随后只需要随机访问元素：</p>
<p>可以在输入阶段使用list，输入完成后将元素拷贝至一个vector</p>
</li>
</ul>
<p>如果目前不确定使用哪种容器，可以先选定一个容器类型，在程序中只使用vector和list的公共操作：使用迭代器，而不是使用下标。这样后续改变容器类型会很方便</p>
<h1 id="容器通用操作"><a href="#容器通用操作" class="headerlink" title="容器通用操作"></a>容器通用操作</h1><p>一般来说，每个容器都定义在对应的头文件中，且文件名与类型名相同</p>
<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>每个容器都定义了多个类型，我们可以通过这些类型的类型别名来定义一个变量以供使用，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> i=a.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure>

<p>通常我们使用auto来创建一个容器内的类型对象，因为通常这样更方便，但是同时可以通过类型别名具体地定义这些变量的类型，例如这里的i类型实际上是:<code>vector&lt;int&gt;::iterator</code>这里的iterator就是一个类型别名，所以这里还可以：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator i=a.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure>

<p>像这样的类型别名还有：</p>
<table>
<thead>
<tr>
<th align="center">iterator</th>
<th align="center">此容器的迭代器类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">const_iterator</td>
<td align="center">只读迭代器类型</td>
</tr>
<tr>
<td align="center">size_type</td>
<td align="center">无符号整数类型，用于保存容器长度，可用于索引</td>
</tr>
<tr>
<td align="center">difference_type</td>
<td align="center">带符号整数类型，用于保存两迭代器之间的距离</td>
</tr>
<tr>
<td align="center">value_type</td>
<td align="center">容器的元素类型</td>
</tr>
<tr>
<td align="center">reference</td>
<td align="center">元素的左值类型</td>
</tr>
<tr>
<td align="center">const_reference</td>
<td align="center">只读左值类型</td>
</tr>
</tbody></table>
<h2 id="容器定义和初始化"><a href="#容器定义和初始化" class="headerlink" title="容器定义和初始化"></a>容器定义和初始化</h2><p>为方便理解，我们先像这样定义<strong>容器元素</strong>的类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">person</span>() =<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">person</span>(string s) &#123;name=s;&#125;</span><br><span class="line">    <span class="built_in">person</span>(string s1, string s2)  &#123;name=s1;addr=s2;&#125;</span><br><span class="line">   </span><br><span class="line">    string name;</span><br><span class="line">    string addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，该类有三个默认构造函数，接下来对容器的定义和初始化的元素均是该类型对象。</p>
<p>容器的定义与初始化有以下方式（均已vector为例）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;person&gt; men;</span><br><span class="line"><span class="function">vector&lt;person&gt; <span class="title">men1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;person&gt; <span class="title">men2</span><span class="params">(men1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">a</span><span class="params">(<span class="string">&quot;dhk&quot;</span>)</span>,<span class="title">b</span><span class="params">(<span class="string">&quot;aca&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;person&gt; <span class="title">men3</span><span class="params">(<span class="number">10</span>,a)</span></span>;</span><br><span class="line"><span class="function">vector&lt;person&gt; <span class="title">men3</span><span class="params">(<span class="number">10</span>,a)</span></span>;</span><br><span class="line"><span class="function">vector&lt;person&gt; <span class="title">men4</span><span class="params">(<span class="number">10</span>,&#123;a,b&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">vector&lt;person&gt; men5&#123;a,b,a,b&#125;;</span><br><span class="line">vector&lt;person&gt; men6&#123;&#123;a,b&#125;,&#123;b,a&#125;&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;person&gt;::iterator i=men1.<span class="built_in">begin</span>(), e=men1.<span class="built_in">end</span>();</span><br><span class="line"><span class="function">vector&lt;person&gt; <span class="title">men7</span><span class="params">(i,e)</span></span>;</span><br></pre></td></tr></table></figure>

<p><em>写在前面：有关元素类对象的构造函数生成元素的方法后面还会讲到更好用的办法，因此不建议在初始化容器时就添加元素</em></p>
<ul>
<li><p>men为经过<strong>默认容器构造函数</strong>定义的容器对象，每个容器类型都定义了一个默认的构造函数，除了array容器之外，其他容器的默认构造函数都会创建一个<strong>指定类型的空容器</strong>。而对于array来说，用C中数组思维理解，由于在创建时长度已经给定，因此array中<strong>每个元素都会被初始化</strong>。</p>
</li>
<li><p>men1为创建一个含有10个person类元素的vector容器，这些元素都已经经过初始化，并且全部相同。</p>
</li>
<li><p>men2为创建一个vector容器，其含有的元素未men1的拷贝，这就要求men1和men2必须是相同的类型，且元素也为相同的类型。对于array容器而言，长度还必须相等。</p>
</li>
<li><p>men3为创建一个含有10个person类元素的vector容器，而这些元素<strong>通过person的第二个构造函数进行了初始化</strong>，而不是像men1一样进行默认初始化。也就是说，<strong>现在men3内有10个name为”dhk”，addr为默认初始化值的相同元素。</strong></p>
</li>
<li><p>men4为创建一个含有10个person类元素的vector容器，而这些元素经过person的第三个构造函数进行了初始化。也就是说，<strong>现在men3内有10个name为”dhk”，addr为”aca”的相同元素。</strong></p>
<p>到此可以看出，当使用小括号进行容器初始化时，且当第一个值为一个整数n时，代表初始化n个相同的元素，而第二个参数<strong>可以为元素的构造函数参数</strong>，但这个参数<strong>有且只能有1个！！！</strong>，因为这n个元素是相同的，不能在这里对其中两个元素使用不同的构造函数参数，<strong>因此，<code>vector&lt;person&gt; men3(10,a,b);</code>是错误的写法！</strong></p>
<p>而如果当元素的构造函数参数有多个时，只需要像men4一样将这些参数通过大括号括起来即可。</p>
</li>
<li><p>men5为创建一个含有<strong>4个</strong>person类元素的vector容器，这些元素通过person的第二个构造函数进行初始化，分别是name为”dhk”,”aca”,”dhk”,”aca”；addr为默认初始化值的person对象。</p>
</li>
<li><p>men6为创建一个含有<strong>2个</strong>person类元素的vector容器，而这些元素经过person的第三个构造函数进行了初始化，分别是<u>name为”dhk”，addr为”aca”</u>和<u>name为”dhk”，addr为”aca”</u>的<strong>两个元素</strong></p>
</li>
<li><p>men7为迭代器i和e指定范围内中元素的拷贝，这些元素类型也需和men7中的元素类型相同</p>
</li>
</ul>
<h3 id="array类型的初始化"><a href="#array类型的初始化" class="headerlink" title="array类型的初始化"></a>array类型的初始化</h3><p>array类型由于需指定大小，初始化方式稍微有一点不一样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array&lt;person,10&gt; men=&#123;a,b,a&#125;;</span><br></pre></td></tr></table></figure>

<p>并且初始化时不能像men6一样使用大括号实现多个构造函数参数初始化</p>
<h3 id="string容器初始化"><a href="#string容器初始化" class="headerlink" title="string容器初始化"></a>string容器初始化</h3><p><a href="https://dhkkk.gitee.io/2022/09/15/C++-3/">C++字符串、向量和数组 | 小董的BLOG (gitee.io)</a></p>
<h2 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h2><p>除了一般初始化列表拷贝（不支持array），插入函数之外，这里将介绍assign函数和swap函数</p>
<h3 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h3><p>顺序容器中定义了assign成员，该函数允许从一个不同但可以兼容的类型元素赋值（不支持array），例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; names;</span><br><span class="line">vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; oldstyle;</span><br><span class="line">names=oldstyle;<span class="comment">//错误的，不可以直接将类型不同的容器赋值</span></span><br><span class="line">names=<span class="built_in">assign</span>( oldstyle.<span class="built_in">begin</span>(),oldstyle.<span class="built_in">end</span>() );</span><br></pre></td></tr></table></figure>

<p>assign会直接替换掉旧的元素，<strong>并且assign中使用的迭代器不能指向调用assign的容器</strong></p>
<p>assign也支持输入一个整数和一个元素值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">list&lt;string&gt; <span class="title">names</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">name.<span class="built_in">assign</span>(<span class="number">10</span>,<span class="string">&quot;dhk&quot;</span>);<span class="comment">//替换为10个相同的指定元素</span></span><br></pre></td></tr></table></figure>

<h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><p>swap函数的作用是交换<strong>两个相同类型容器</strong>的元素，但是swap的速度要快于一般的值拷贝，因为其本质的操作并没有改变这些元素的地址，而是改变了两个容器的<strong>数据结构</strong>，我个人的理解是就好像<a href="https://dhkkk.gitee.io/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/">基于FreeRTOS的列表学习 | 小董的BLOG (gitee.io)</a>中列表与列表项之间的关系，swap只是改变了首尾列表项与对应列表的指针关系；也就是说容器内元素的地址未发生变化，只是用于存储它们所属容器信息的某个变量（应该只有首尾元素）发生了变化。因此，<strong>swap操作是在一个常数时间内完成的</strong>，因为它跟元素的个数无关</p>
<p>因此，在swap前使用的迭代器、引用、指针在swap后<strong>都不会失效，因为元素本身的地址是没有改变的</strong>，这点就不同于assign的值拷贝。<strong>也就是说我们在使用swap后仍可以使用之前的迭代器、引用和指针，它们依旧指向（绑定）swap前的那个元素，只是这个元素不再属于之前的容器了</strong></p>
<p>需要注意的是：</p>
<ul>
<li>对于string，调用swap会导致之前的迭代器、指针和引用失效</li>
<li>对于array，两容器长度必须相等。swap会真正地交换元素值，但元素地址还是没有改变的，也就是swap前的迭代器、指针和引用仍然可以使用，只是它指向（绑定）的元素的元素内容发生了变化</li>
</ul>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>所有容器都支持使用关系运算符，但运算对象类型必须一致，运算原则：</p>
<ul>
<li>长度相等且元素两两对应相等则两个容器相等</li>
<li>如果长度不等，但元素相等（较小容器的所有元素都等于较大容器的元素），则小容器＜大容器</li>
<li>如果长度不等且元素不等，则关系取决于第一个不不相等元素的大小关系</li>
</ul>
<p>需要注意的是，<strong>只有当容器元素的类型也定义了相应的运算符时才可以使用关系运算符比较两个容器</strong></p>
<h1 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a>顺序容器操作</h1><h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><p>以下函数皆为类成员函数</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">作用</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">push_back(t)</td>
<td align="center">在容器尾部添加一个t元素</td>
<td align="center">void</td>
</tr>
<tr>
<td align="center">push_front(t)</td>
<td align="center">在容器头部添加一个t元素</td>
<td align="center">void</td>
</tr>
<tr>
<td align="center">insert(p,t)</td>
<td align="center">在迭代器p指向的元素<strong>之前</strong>添加一个t元素</td>
<td align="center">新元素的迭代器</td>
</tr>
<tr>
<td align="center">insert(p,n,t)</td>
<td align="center">插入n个t元素</td>
<td align="center">第一个新元素的迭代器</td>
</tr>
<tr>
<td align="center">insert(p,b,e)</td>
<td align="center">在迭代器p之前添加迭代器b到e范围内的元素</td>
<td align="center">第一个新元素的迭代器</td>
</tr>
<tr>
<td align="center">insert(p,il)</td>
<td align="center">插入一个il列表，例如{1,2,3}</td>
<td align="center">第一个新元素的迭代器</td>
</tr>
</tbody></table>
<p>当容器元素需要通过构造函数创建时，可以使用以下函数直接在容器内存中构造元素：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">作用</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">emplace_back(arg1,arg2,…)</td>
<td align="center">直接添加一个由元素类构造函数构建的新元素到容器尾部</td>
<td align="center">void</td>
</tr>
<tr>
<td align="center">emplace_front(arg1,arg2,…)</td>
<td align="center">直接添加一个由元素类构造函数构建的新元素到容器头部</td>
<td align="center">void</td>
</tr>
<tr>
<td align="center">emplace(p,arg1,arg2,…)</td>
<td align="center">直接添加一个由元素类构造函数构建的元素到迭代器p前</td>
<td align="center">新元素的迭代器</td>
</tr>
</tbody></table>
<p><strong>从arg1开始的参数要严格符合元素的构造函数参数要求</strong></p>
<p>使用这些函数有几个需要注意的点：</p>
<ul>
<li>array不能使用这些操作</li>
<li>forward_list有专用函数，不能使用这些函数</li>
<li>forward_list不支持push_back和emplace_back</li>
<li>vector和string不支持push_front和emplace_front</li>
<li><strong>向一个vector、string或deque插入元素会使原来的迭代器、指针、引用失效</strong></li>
<li><strong>将元素插入到vector、deque和string中是合法的，但是消耗资源较大</strong></li>
</ul>
<h2 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h2><p>以下皆为类成员函数</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin()</td>
<td align="center">返回首元素迭代器</td>
</tr>
<tr>
<td align="center">end()</td>
<td align="center">返回尾元素之后位置的迭代器</td>
</tr>
<tr>
<td align="center">front()</td>
<td align="center">返回首元素的引用</td>
</tr>
<tr>
<td align="center">back()</td>
<td align="center">返回尾元素的引用</td>
</tr>
<tr>
<td align="center">c[n]</td>
<td align="center">返回容器c中下标n元素的引用，下标越界会导致运行出错</td>
</tr>
<tr>
<td align="center">at(n)</td>
<td align="center">同上，但如果下标越界，会抛出一个out_of_range异常</td>
</tr>
</tbody></table>
<ul>
<li>对一个空容器调用这些函数都属于越界访问</li>
<li>at和下标操作只适用于vector、string、deque和array</li>
<li>如果容器是const的，则返回元素的引用也是const的，不可改变</li>
</ul>
<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">作用</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">pop_back()</td>
<td align="center">删除尾部元素，若容器为空则函数未定义</td>
<td align="center">void</td>
</tr>
<tr>
<td align="center">pop_front()</td>
<td align="center">删除头部元素</td>
<td align="center">void</td>
</tr>
<tr>
<td align="center">erase(p)</td>
<td align="center">删除迭代器p处元素，若p为尾后迭代器，则函数未定义</td>
<td align="center">被删元素之后的元素迭代器</td>
</tr>
<tr>
<td align="center">erase(b,e)</td>
<td align="center">删除迭代器b和e范围内的元素</td>
<td align="center">最后一个被删元素之后的迭代器</td>
</tr>
<tr>
<td align="center">clear()</td>
<td align="center">删除所有元素</td>
<td align="center">void</td>
</tr>
</tbody></table>
<ul>
<li>array不能使用这些操作</li>
<li>forward_list不支持pop_back()</li>
<li>vector和string不支持pop_front()</li>
</ul>
<h2 id="forward-list的特殊操作"><a href="#forward-list的特殊操作" class="headerlink" title="forward_list的特殊操作"></a>forward_list的特殊操作</h2><p>前面讲到，forward_list为单向链表，当我们使用前面的这些函数操作某个元素时，需要找到该元素的前驱，因为无论是添加、删除元素都需要改变前驱的链接。但是单向链表无法通过简单的办法找到一个节点的上一个节点，因此单向链表的实现方式有所不同：通过要操作的元素的上一个元素的迭代器来找到待操作元素</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">作用</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">before_begin()</td>
<td align="center">返回首元素之前的迭代器，该迭代器不可解引用</td>
<td align="center">~</td>
</tr>
<tr>
<td align="center">insert_after(p,t)</td>
<td align="center">在迭代器p<strong>后</strong>插入t</td>
<td align="center">插入的元素的迭代器</td>
</tr>
<tr>
<td align="center">insert_after(p,n,t)</td>
<td align="center">在迭代器p<strong>后</strong>插入n个t</td>
<td align="center">最后一个插入的元素的迭代器</td>
</tr>
<tr>
<td align="center">insert_after(p,b,e)</td>
<td align="center">在p<strong>后</strong>插入迭代器b和e之间的元素</td>
<td align="center">最后一个插入的元素的迭代器</td>
</tr>
<tr>
<td align="center">insert_after(p,il)</td>
<td align="center">在p<strong>后</strong>插入一个花括号列表</td>
<td align="center">最后一个插入的元素的迭代器</td>
</tr>
<tr>
<td align="center">emplace_after(p,args1,args2,…)</td>
<td align="center">在p后插入一个由构造函数构造的元素</td>
<td align="center">新元素的迭代器</td>
</tr>
<tr>
<td align="center">erase_after(p)</td>
<td align="center">删除p指向的元素之后的那一个元素</td>
<td align="center">被删元素之后的迭代器</td>
</tr>
<tr>
<td align="center">erase_after(b,e)</td>
<td align="center">删除从b之后到e之间的元素，即(b,e]</td>
<td align="center">被删元素之后的迭代器</td>
</tr>
</tbody></table>
<h1 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h1><p>对应除array之外的容器，其容量都是随时可变的，可以通过添加、删除元素实时改变容器的大小，这里提供了resize函数来可视化管理容器的大小：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">resize(n)</td>
<td align="center">将容器大小调整为n</td>
</tr>
<tr>
<td align="center">resize(n,t)</td>
<td align="center">任何新添加的元素都初始化为t</td>
</tr>
</tbody></table>
<p>对于调整值n，若n小于容器本身大小，则多出的元素被丢弃；若n大于容器大小，新的元素都将进行初始化</p>
<p>改变容器大小可能会因为删除元素导致迭代器失效</p>
<h1 id="管理容器的内存"><a href="#管理容器的内存" class="headerlink" title="管理容器的内存"></a>管理容器的内存</h1><p>对于vector和string来说，为了支持快速随机访问，其元素在内存上是连续存储的。</p>
<p>因此，当容器需要扩充容量时，因为元素必须连续纯粹的关系，每次添加扩容的新元素时，容器都会重新分配内存空间以保证所有的元素在内存上都连续存储（此时原来的空间内存就会被释放），这种操作会严重影响性能。</p>
<p>为了减轻这种代价，标准库实现者在容器不得不获取新的内存空间时，<strong>会分配比新的空间需求更大的内存空间</strong>，多出的空间作为预留备用，可以一定程度避免多次重新分配内存空间。而在实际中，这种策略也确实大大提高了性能</p>
<p>为了方便用户管理这些内存，容器类型中也提供了相关的成员函数：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">shrink_to_fit()</td>
<td align="center">删除预留的空间，使用后内存空间与size()一致</td>
</tr>
<tr>
<td align="center">capacity()</td>
<td align="center">容器目前在不重新分配空间的前提下<strong>最多</strong>可以保存多少元素</td>
</tr>
<tr>
<td align="center">reserve(n)</td>
<td align="center">为容器分配一个<strong>至少</strong>能容纳n个元素的空间</td>
</tr>
</tbody></table>
<p>根据我的使用经验，当reserve的值超过目前容器实际容量一定值之后，reserve的值会等于capacity。并且，<strong>reserve与resize函数最大的区别就是：reserve仅分配内存空间，而resize会将元素进行初始化，但它们都是以元素的个数为单位，而不是字节之类的</strong></p>
<ul>
<li>capacity和reserve只适用于vector和string</li>
</ul>
<h1 id="额外的string操作"><a href="#额外的string操作" class="headerlink" title="额外的string操作"></a>额外的string操作</h1><h2 id="构造string的其他方法"><a href="#构造string的其他方法" class="headerlink" title="构造string的其他方法"></a>构造string的其他方法</h2><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">string s(cp,n)</td>
<td align="center">s是cp指向的数组前n个字符的拷贝</td>
</tr>
<tr>
<td align="center">string s(s2,pos2)</td>
<td align="center">s是string变量s2从下标pos2开始的字符的拷贝</td>
</tr>
<tr>
<td align="center">string s(s2,pos2,len2)</td>
<td align="center">同上，len的长度可以超过s2长度，此时至多拷贝size-pos2个字符</td>
</tr>
</tbody></table>
<h2 id="子字符串操作"><a href="#子字符串操作" class="headerlink" title="子字符串操作"></a>子字符串操作</h2><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">substr(pos,n)</td>
<td align="center">返回一个string，返回值同第二个构造函数</td>
</tr>
</tbody></table>
<h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><p>关联容器和顺序容器有根本的区别，简单来说，关联容器通过关键字来保存、访问元素；而顺序容器是通过元素在容器中的位置来操作元素的。</p>
<p>标准库提供了8个关联容器：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">map</td>
<td align="center">关联数组：关键字与值一一对应</td>
</tr>
<tr>
<td align="center">set</td>
<td align="center">关键字即值，只保存关键字的容器</td>
</tr>
<tr>
<td align="center">multimap</td>
<td align="center">关键字可重复出现，允许多个元素对应一个关键字的map</td>
</tr>
<tr>
<td align="center">multiset</td>
<td align="center">关键字可重复出现的set</td>
</tr>
<tr>
<td align="center"><strong>下方为无序容器</strong></td>
<td align="center">~</td>
</tr>
<tr>
<td align="center">unordered_map</td>
<td align="center">用哈希函数组织的map</td>
</tr>
<tr>
<td align="center">unordered_set</td>
<td align="center">用哈希函数组织的set</td>
</tr>
<tr>
<td align="center">unordered_multimap</td>
<td align="center">~</td>
</tr>
<tr>
<td align="center">unordered_multiset</td>
<td align="center">~</td>
</tr>
</tbody></table>
<p>使用它们需包含对应的头文件</p>
<h2 id="关联容器概述"><a href="#关联容器概述" class="headerlink" title="关联容器概述"></a>关联容器概述</h2><p>关联容器支持上面讲的容器通用操作，不支持顺序容器操作，且关联容器的迭代器都是双向的</p>
<h3 id="关联容器定义"><a href="#关联容器定义" class="headerlink" title="关联容器定义"></a>关联容器定义</h3><p>没什么需要特别讲的，基本可以看明白</p>
<ul>
<li><p>map：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; test=&#123;&#123;<span class="string">&quot;dhk&quot;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&quot;aca&quot;</span>,<span class="number">2</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>set：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; test=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="关键字类型要求"><a href="#关键字类型要求" class="headerlink" title="关键字类型要求"></a>关键字类型要求</h3><p>对于关键字的类型必须是可以比较的。</p>
<h2 id="关联容器操作"><a href="#关联容器操作" class="headerlink" title="关联容器操作"></a>关联容器操作</h2><h3 id="关联容器特有类型别名"><a href="#关联容器特有类型别名" class="headerlink" title="关联容器特有类型别名"></a>关联容器特有类型别名</h3><ul>
<li>key_type：容器的关键字类型</li>
<li>mapped_type：关键字对应值的类型，只适用于map</li>
<li>value_type：对于set，于key_type相同；对于map，为<code>pair&lt;const key_type,mapped_type&gt;</code></li>
</ul>
<p>(pair可以简单理解为一个类似小容器的类型，每个对象只允许有两个成员)</p>
<h3 id="关联容器迭代器"><a href="#关联容器迭代器" class="headerlink" title="关联容器迭代器"></a>关联容器迭代器</h3><p>对于顺序容器，迭代器的解引用为元素的值；而对于关联容器：</p>
<ul>
<li><p>set的迭代器解引用对象为key_type</p>
</li>
<li><p>map的迭代器解引用对象为一个pair类型，因此：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">map&lt;string,<span class="type">int</span>&gt; <span class="title">test</span><span class="params">(&#123;<span class="string">&quot;dhk&quot;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&quot;aca&quot;</span>,<span class="number">2</span>&#125;)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> i=test.<span class="built_in">begin</span>();</span><br><span class="line">string a=(*i).first;</span><br><span class="line"><span class="type">int</span> b=i-&gt;second;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，关联容器的关键字是const的，不可修改</p>
<p><strong>同时，对于关联容器，begin函数返回的不一定是初始化时的第一个元素，而是经过关键字比较过后最小的元素</strong></p>
</li>
</ul>
<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>对于map，以下几种方式都可以</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test.<span class="built_in">insert</span>(&#123;<span class="string">&quot;dhk&quot;</span>,<span class="number">1</span>&#125;);</span><br><span class="line">test.<span class="built_in">insert</span>(<span class="built_in">makepair</span>(<span class="string">&quot;dhk&quot;</span>,<span class="number">1</span>));<span class="comment">//makepair为现场构造一个pair</span></span><br><span class="line">test.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string,<span class="type">int</span>&gt;(<span class="string">&quot;dhk&quot;</span>,<span class="number">1</span>));</span><br><span class="line">test.<span class="built_in">insert</span>(map&lt;string,<span class="type">int</span>&gt;::<span class="built_in">value_type</span>(<span class="string">&quot;dhk&quot;</span>,<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>同时也可以使用emplace函数，同顺序容器</p>
<h3 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h3><p>使用erase函数，参数可以为关键字或迭代器</p>
<h3 id="map的下标操作"><a href="#map的下标操作" class="headerlink" title="map的下标操作"></a>map的下标操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">map&lt;string,<span class="type">int</span>&gt; <span class="title">test</span><span class="params">(&#123;<span class="string">&quot;dhk&quot;</span>,<span class="number">1</span>&#125;)</span></span>;</span><br><span class="line">map[<span class="string">&quot;dhk&quot;</span>]=<span class="number">2</span>;</span><br><span class="line">map[<span class="string">&quot;aca&quot;</span>]=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>map的下标接受一个关键字，会获取该关键字关联的值</p>
<p>如果容器中未存在该关键字，则会创建一个新的元素插入容器中，因此下标操作只能对非const容器使用</p>
<h3 id="通用访问操作"><a href="#通用访问操作" class="headerlink" title="通用访问操作"></a>通用访问操作</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">find(k)</td>
<td align="center">访问容器中第一次出现的关键字为k的元素</td>
<td align="center">该元素迭代器</td>
</tr>
<tr>
<td align="center">count(k)</td>
<td align="center">关键字为k的元素数量</td>
<td align="center">数量</td>
</tr>
<tr>
<td align="center">lower_bound(k)</td>
<td align="center">访问第一次出现的关键字≤k的元素</td>
<td align="center">该元素迭代器</td>
</tr>
<tr>
<td align="center">upper_bound(k)</td>
<td align="center">访问第一次出现的关键字＞k的元素</td>
<td align="center">该元素迭代器</td>
</tr>
<tr>
<td align="center">equal_range(k)</td>
<td align="center">关键字为k的所有元素的范围</td>
<td align="center">一个pair，两个成员均为迭代器</td>
</tr>
</tbody></table>
<p>对于允许关键字重复的容器，关键字相同的元素会在容器中相邻存储，也就是可以通过迭代器递增的方式依次访问</p>
<p><strong>这些操作与下标操作不同的是不能创建新元素</strong></p>
<h2 id="单词转换程序"><a href="#单词转换程序" class="headerlink" title="单词转换程序"></a>单词转换程序</h2><p>根据书上的思路写了一个简化版的拼音转汉字程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将文件流绑定的文件数据导入到本程序的map中,文件数据格式如下*/</span></span><br><span class="line"><span class="comment">/*拼音 对应汉字*/</span></span><br><span class="line"><span class="function">map&lt;string,string&gt; <span class="title">bulidmap</span><span class="params">(ifstream &amp;map_file)</span><span class="comment">//返回值为一个map&lt;string,string&gt;</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;string,string&gt; the_map;</span><br><span class="line">    string key,value;</span><br><span class="line">    <span class="keyword">while</span>(map_file&gt;&gt;key &amp;&amp; <span class="built_in">getline</span>(map_file,value))</span><br><span class="line">    <span class="comment">//将拼音存入key变量中，该行剩下的内容存入value中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果value有值，则删除开头的空格</span></span><br><span class="line">        <span class="keyword">if</span>(value.<span class="built_in">size</span>()&gt;<span class="number">1</span>)  the_map[key]=value.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> the_map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ifstream mapfile;<span class="comment">//创建一个读取文件流用于读取文件</span></span><br><span class="line">    <span class="function">stringstream <span class="title">str</span><span class="params">(<span class="string">&quot;cy shi wo die&quot;</span>)</span></span>;<span class="comment">//字符串流用于程序输入</span></span><br><span class="line">    mapfile.<span class="built_in">open</span>(<span class="string">&quot;c++\\ass_container\\map.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> trans_map=<span class="built_in">bulidmap</span>(mapfile);<span class="comment">//将文件流内容导入新创建的map类型变量中</span></span><br><span class="line">    <span class="keyword">auto</span> end=trans_map.<span class="built_in">end</span>();<span class="comment">//指向map末端之后的一个迭代器</span></span><br><span class="line">    string s,s1;</span><br><span class="line">    <span class="keyword">while</span>(str&gt;&gt;s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> i= trans_map.<span class="built_in">find</span>(s);<span class="comment">//将字符串流中的每一个单词取出，在map中寻找有无对应的key</span></span><br><span class="line">        <span class="keyword">if</span> (i !=end)<span class="comment">//如果未寻找到，迭代器i会等于end</span></span><br><span class="line">        &#123;</span><br><span class="line">            s=i-&gt;second;<span class="comment">//用寻找到的key对应的value（拼音对应汉字）覆盖s中原有的拼音</span></span><br><span class="line">        &#125;</span><br><span class="line">        s1=s1+s;<span class="comment">//s1用于存储全部的转换结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>21行：字符串删除函数，可以删除字符串中指定数量的字符</li>
<li>38行：find函数如果未找到对应关键字则会返回队尾之后的迭代器</li>
</ul>
<h1 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h1><p>无序容器也属于关联容器的一种，但无序容器不是使用比较关键字的方式来组织元素顺序，而是通过一个哈希函数算法进行组织元素，简单地来说，该算法就是用比普通关联容器组织方式代价更小的方式进行元素组织，<strong>通常用于关键字没有明显的序关系等情况下使用，也许可以节省性能的占用</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">unordered_map</td>
<td align="center">用哈希函数组织的map</td>
</tr>
<tr>
<td align="center">unordered_set</td>
<td align="center">用哈希函数组织的set</td>
</tr>
<tr>
<td align="center">unordered_multimap</td>
<td align="center">~</td>
</tr>
<tr>
<td align="center">unordered_multiset</td>
<td align="center">~</td>
</tr>
</tbody></table>
<h2 id="无序容器的管理措施"><a href="#无序容器的管理措施" class="headerlink" title="无序容器的管理措施"></a>无序容器的管理措施</h2><p>无序容器在存储上组织为一组“桶”，哈希函数会计算每个元素的哈希值，具有相同哈希值的元素会被存入一个桶中，对于桶的维护，标准库也给出了一系列函数，但是我觉得用处不大，就先不写在这里了</p>
<h2 id="无序容器对关键字类型的要求"><a href="#无序容器对关键字类型的要求" class="headerlink" title="无序容器对关键字类型的要求"></a>无序容器对关键字类型的要求</h2><p>无序容器中有一个hash<key_type>类型用于存储哈希值，内置类型和string等标准库类型均定义了hash类型，均可以作为关键字。不能作为无序容器关键字的是另一个自定义的无序容器，原因与模板有关。</key_type></p>
]]></content>
      
        
        <tags>
            
            <tag> C++学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[FreeRTOS任务延时分析]]></title>
      <url>/2022/12/14/FreeRTOS%E4%BB%BB%E5%8A%A1%E5%BB%B6%E6%97%B6%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>前几章中都有涉及FreeRTOS的列表相关内容，在学习过程中，我们也能看出来列表与任务的状态（就绪、延时、堵塞）与任务调度息息相关，本文就针对任务延时进行<strong>列表运行机制</strong>的进一步学习</p>
<p>参考：<a href="https://freertos.blog.csdn.net/article/details/51705148">FreeRTOS高级篇9—FreeRTOS系统延时分析_研究是为了理解的博客-CSDN博客_pdms_to_ticks</a></p>
<h1 id="相对延时"><a href="#相对延时" class="headerlink" title="相对延时"></a>相对延时</h1><table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">参数</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">vTaskDelay( const TickType_t xTicksToDelay )</td>
<td align="center">系统节拍个数</td>
<td align="center">无</td>
</tr>
</tbody></table>
<p>再次提醒一下，FreeRTOS中的延时参数都是以FreeRTOS<strong>自身的系统节拍</strong>为单位，系统节拍可以在在配置文件FreeRTOSConfig.h，改变宏configTICK_RATE_HZ的值；cubemx中的配置项也有相关的配置处，单位为Hz</p>
<h2 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelay</span><span class="params">( <span class="type">const</span> TickType_t xTicksToDelay )</span></span><br><span class="line">&#123;</span><br><span class="line">BaseType_t xAlreadyYielded = pdFALSE;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 如果延时时间为0,则不会将当前任务加入延时列表 */</span></span><br><span class="line">    <span class="keyword">if</span>( xTicksToDelay &gt; ( TickType_t ) <span class="number">0U</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        configASSERT( uxSchedulerSuspended == <span class="number">0</span> );<span class="comment">//禁用中断</span></span><br><span class="line">        vTaskSuspendAll();<span class="comment">//将调度器挂起</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">/* 将当前任务从就绪列表中移除,并根据当前系统节拍计数器值计算唤醒时间,然后将任务加入延时列表 */</span></span><br><span class="line">            prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );</span><br><span class="line">        &#125;</span><br><span class="line">        xAlreadyYielded = xTaskResumeAll();<span class="comment">//恢复调度器运行</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 强制执行一次上下文切换*/</span></span><br><span class="line">    <span class="keyword">if</span>( xAlreadyYielded == pdFALSE )</span><br><span class="line">    &#123;</span><br><span class="line">        portYIELD_WITHIN_API();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，关键函数为prvAddCurrentTaskToDelayedList()：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvAddCurrentTaskToDelayedList</span><span class="params">( TickType_t xTicksToWait, <span class="type">const</span> BaseType_t xCanBlockIndefinitely )</span></span><br><span class="line">&#123;</span><br><span class="line">TickType_t xTimeToWake;</span><br><span class="line"><span class="type">const</span> TickType_t xConstTickCount = xTickCount;</span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span>( INCLUDE_xTaskAbortDelay == 1 )</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 延时相关标志位清零 */</span></span><br><span class="line">		pxCurrentTCB-&gt;ucDelayAborted = pdFALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将列表项移出当前列表（就绪列表），pxCurrentTCB作为全局变量指向当前任务TCB，uxListRemove()返回列表的成员个数 */</span></span><br><span class="line">	<span class="keyword">if</span>( uxListRemove( &amp;( pxCurrentTCB-&gt;xStateListItem ) ) == ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* The current task must be in a ready list, so there is no need to</span></span><br><span class="line"><span class="comment">		check, and the port reset macro can be called directly. */</span></span><br><span class="line">		portRESET_READY_PRIORITY( pxCurrentTCB-&gt;uxPriority, uxTopReadyPriority );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		mtCOVERAGE_TEST_MARKER();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> ( INCLUDE_vTaskSuspend == 1 )</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>( ( xTicksToWait == portMAX_DELAY ) &amp;&amp; ( xCanBlockIndefinitely != pdFALSE ) )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/*如果设置的延时参数等于portMAX_DELAY(0xffffffff)，则视为堵塞而不是延时 */</span></span><br><span class="line">			vListInsertEnd( &amp;xSuspendedTaskList, &amp;( pxCurrentTCB-&gt;xStateListItem ) );</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 计算唤醒时间 */</span></span><br><span class="line">			xTimeToWake = xConstTickCount + xTicksToWait;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 将当前任务TCB的状态列表项值设置为唤醒时间 */</span></span><br><span class="line">			listSET_LIST_ITEM_VALUE( &amp;( pxCurrentTCB-&gt;xStateListItem ), xTimeToWake );</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>( xTimeToWake &lt; xConstTickCount )</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* Wake time has overflowed.  Place this item in the overflow</span></span><br><span class="line"><span class="comment">				list. */</span></span><br><span class="line">				vListInsert( pxOverflowDelayedTaskList, &amp;( pxCurrentTCB-&gt;xStateListItem ) );</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* 使用的是插入函数，因此延时列表中列表项会根据唤醒时间的大小进行排序 */</span></span><br><span class="line">				vListInsert( pxDelayedTaskList, &amp;( pxCurrentTCB-&gt;xStateListItem ) );</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* If the task entering the blocked state was placed at the</span></span><br><span class="line"><span class="comment">				head of the list of blocked tasks then xNextTaskUnblockTime</span></span><br><span class="line"><span class="comment">				needs to be updated too. */</span></span><br><span class="line">				<span class="keyword">if</span>( xTimeToWake &lt; xNextTaskUnblockTime )</span><br><span class="line">				&#123;</span><br><span class="line">					xNextTaskUnblockTime = xTimeToWake;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					mtCOVERAGE_TEST_MARKER();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">		<span class="comment">/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */</span></span><br><span class="line">		( <span class="type">void</span> ) xCanBlockIndefinitely;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span> <span class="comment">/* INCLUDE_vTaskSuspend */</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过对上述代码解释了列表的具体使用方法：</p>
<ul>
<li><p>若要将当前任务延时或挂起，可以通过全局变量pxCurrentTCB找到该任务TCB，再操作该TCB的<strong>状态</strong>列表项</p>
</li>
<li><p>当任务延时或挂起时，状态列表项的列表项值xItemValue会用于存放唤醒（延时结束）的时间，由于列表插入函数会自动根据xItemValue的值进行排序，<strong>所以唤醒时间越短的列表项会越排在列表前面</strong></p>
</li>
<li><p>FreeRTOS使用了两个延时列表：xDelayedTaskList1和xDelayedTaskList2，并使用两个列表指针类型变量pxDelayedTaskList和pxOverflowDelayedTaskList分别指向上面的延时列表1和延时列表2</p>
<p>pxOverflowDelayedTaskList用于解决计时溢出的问题：</p>
<p>tasks.c中定义了很多局部静态变量，其中有一个变量xTickCount用于记录系统节拍中断次数（可以理解为记录当前时间），当xTicksToDelay达到4294967295后再增加，就会溢出变成0。 如果内核判断出xTickCount+ xTicksToDelay溢出，就将当前任务挂接到列表指针pxOverflowDelayedTaskList指向的列表中</p>
</li>
</ul>
<h2 id="相对延时的缺点"><a href="#相对延时的缺点" class="headerlink" title="相对延时的缺点"></a>相对延时的缺点</h2><p>由于相对延时是在每次调用vTaskDelay之后才开启延时，如果调用延时的任务在运行过程中发生中断，那通过相对延时进行的周期任务就会因为该中断而被影响导致不能发生中断。</p>
<p>因此，为了能最大程度的使相对延时达到精准的效果，最好将使用相对延时的任务优先级设置为最高</p>
<h1 id="绝对延时"><a href="#绝对延时" class="headerlink" title="绝对延时"></a>绝对延时</h1><table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">参数</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, <br>                   const TickType_t xTimeIncrement )</td>
<td align="center">上一次记录的时间；<br>周期循环时间</td>
<td align="center">无</td>
</tr>
</tbody></table>
<h2 id="函数体-1"><a href="#函数体-1" class="headerlink" title="函数体"></a>函数体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelayUntil</span><span class="params">( TickType_t * <span class="type">const</span> pxPreviousWakeTime, <span class="type">const</span> TickType_t xTimeIncrement )</span></span><br><span class="line">&#123;</span><br><span class="line">TickType_t xTimeToWake;</span><br><span class="line">BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;</span><br><span class="line"> </span><br><span class="line">    vTaskSuspendAll();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 保存系统节拍中断次数计数器 */</span></span><br><span class="line">        <span class="type">const</span> TickType_t xConstTickCount = xTickCount;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 计算任务下次唤醒时间(以系统节拍中断次数表示)   */</span></span><br><span class="line">        xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* *pxPreviousWakeTime中保存的是上次唤醒时间,唤醒后需要一定时间执行任务主体代码,如果上次唤醒时间大于当前时间,说明节拍计数器溢出了 */</span></span><br><span class="line">        <span class="keyword">if</span>( xConstTickCount &lt; *pxPreviousWakeTime )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*只有当周期性延时时间大于任务主体代码执行时间,才会将任务挂接到延时列表.*/</span></span><br><span class="line">            <span class="keyword">if</span>( ( xTimeToWake &lt; *pxPreviousWakeTime ) &amp;&amp; ( xTimeToWake &gt; xConstTickCount ) )</span><br><span class="line">            &#123;</span><br><span class="line">                xShouldDelay = pdTRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 也都是保证周期性延时时间大于任务主体代码执行时间 */</span></span><br><span class="line">            <span class="keyword">if</span>( ( xTimeToWake &lt; *pxPreviousWakeTime ) || ( xTimeToWake &gt; xConstTickCount ) )</span><br><span class="line">            &#123;</span><br><span class="line">                xShouldDelay = pdTRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 更新唤醒时间,为下一次调用本函数做准备. */</span></span><br><span class="line">        *pxPreviousWakeTime = xTimeToWake;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>( xShouldDelay != pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 将本任务加入延时列表,注意阻塞时间并不是以当前时间为参考,因此减去了当前系统节拍中断计数器值*/</span></span><br><span class="line">            prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xAlreadyYielded = xTaskResumeAll();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 强制执行一次上下文切换 */</span></span><br><span class="line">    <span class="keyword">if</span>( xAlreadyYielded == pdFALSE )</span><br><span class="line">    &#123;</span><br><span class="line">        portYIELD_WITHIN_API();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写法和基本思路和相对延时区别不大，唯一需要注意的是。绝对延时之所以叫绝对延时，<strong>是因为其第一个参数pxPreviousWakeTime除开第一次使用时需获取当前系统时间外，每次调用绝对延时函数时pxPreviousWakeTime内保存的值为上一次调用时计算出的唤醒时间</strong></p>
<p>也就是说，绝对延时的<strong>每一次延时的起点都是上一次延时的终点</strong>，这也就保证了任务主体即使被中断也不会影响到下一次执行任务主体（前提是任务主体+中断执行的时间小于延时长度，如果超过延时时间，需要重新获取pxPreviousWakeTime为当前系统的最新时间）</p>
]]></content>
      
        
        <tags>
            
            <tag> 嵌入式学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[FreeRTOS的任务创建分析]]></title>
      <url>/2022/12/12/FreeRTOS%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>本文的学习参考了<a href="https://freertos.blog.csdn.net/article/details/51303639">FreeRTOS高级篇2—FreeRTOS任务创建分析_研究是为了理解的博客-CSDN博客_</a></p>
<h1 id="任务TCB分析"><a href="#任务TCB分析" class="headerlink" title="任务TCB分析"></a>任务TCB分析</h1><p>在<a href="https://dhkkk.gitee.io/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/">基于FreeRTOS的列表学习 | 小董的BLOG (gitee.io)</a>中对列表项分析时，在列表项的结构中有一个无类型指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * pvOwner;                                     <span class="comment">/*指向一个任务TCB*/</span></span><br></pre></td></tr></table></figure>

<p>该指针用于指向任务的TCB（Task Control Block）。顾名思义，该结构作为一个用于控制任务的集合。它用于存储任务的状态信息，包括任务运行时的环境。<strong>每个任务都有自己的任务TCB。</strong></p>
<h2 id="结构解读"><a href="#结构解读" class="headerlink" title="结构解读"></a>结构解读</h2><p>可以在task.c中找到定义TCB的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tskTaskControlBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">volatile</span> StackType_t	*pxTopOfStack;		<span class="comment">//栈顶指针</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> ( portUSING_MPU_WRAPPERS == 1 )		<span class="comment">//是否使用MPU</span></span></span><br><span class="line">		xMPU_SETTINGS	xMPUSettings;		</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	ListItem_t			xStateListItem;	<span class="comment">//状态列表项</span></span><br><span class="line">	ListItem_t			xEventListItem;	<span class="comment">//事件列表项	</span></span><br><span class="line">	UBaseType_t			uxPriority;			<span class="comment">//优先级</span></span><br><span class="line">	StackType_t			*pxStack;			<span class="comment">//指向堆栈起始位置</span></span><br><span class="line">	<span class="type">char</span>				pcTaskName[ configMAX_TASK_NAME_LEN ];		<span class="comment">//任务名字最大长度</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> ( portSTACK_GROWTH &gt; 0 )		<span class="comment">//判断堆栈生长方向,&gt;0为向上生长</span></span></span><br><span class="line">		StackType_t		*pxEndOfStack;		 <span class="comment">//需要额外的一个指针来判断堆栈是否溢出</span></span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> ( portCRITICAL_NESTING_IN_TCB == 1 )</span></span><br><span class="line">		UBaseType_t		uxCriticalNesting;	</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span></span><br><span class="line">		UBaseType_t		uxTCBNumber;		<span class="comment">//一个数值，每个任务都有一个唯一的值</span></span><br><span class="line">		UBaseType_t		uxTaskNumber;		<span class="comment">//存储一个特定数值</span></span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> ( configUSE_MUTEXES == 1 )	<span class="comment">//是否使用互斥量</span></span></span><br><span class="line">		UBaseType_t		uxBasePriority;		<span class="comment">//用于保存任务的基础的基础优先级</span></span><br><span class="line">		UBaseType_t		uxMutexesHeld;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> ( configUSE_APPLICATION_TASK_TAG == 1 )</span></span><br><span class="line">		TaskHookFunction_t pxTaskTag;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span>( configNUM_THREAD_LOCAL_STORAGE_POINTERS &gt; 0 )</span></span><br><span class="line">		<span class="type">void</span> *pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span>( configGENERATE_RUN_TIME_STATS == 1 )</span></span><br><span class="line">		<span class="type">uint32_t</span>		ulRunTimeCounter;		<span class="comment">//记录任务在运行状态下执行的总时间</span></span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> ( configUSE_NEWLIB_REENTRANT == 1 )</span></span><br><span class="line">    <span class="comment">/* 为任务分配一个Newlibreent结构体变量。Newlib是一个C库函数，并非FreeRTOS维护，FreeRTOS也不对使用结果负责。如果用户使用Newlib，必须熟知Newlib的细节*/</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span>	_<span class="title">reent</span> <span class="title">xNewLib_reent</span>;</span></span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span>( configUSE_TASK_NOTIFICATIONS == 1 ) 		<span class="comment">//与任务通知相关</span></span></span><br><span class="line">		<span class="keyword">volatile</span> <span class="type">uint32_t</span> ulNotifiedValue;</span><br><span class="line">		<span class="keyword">volatile</span> <span class="type">uint8_t</span> ucNotifyState;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span>( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )</span></span><br><span class="line">		<span class="type">uint8_t</span>	ucStaticallyAllocated; 		</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span>( INCLUDE_xTaskAbortDelay == 1 )</span></span><br><span class="line">		<span class="type">uint8_t</span> ucDelayAborted;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; tskTCB;</span><br><span class="line"><span class="keyword">typedef</span> tskTCB TCB_t;</span><br></pre></td></tr></table></figure>

<h3 id="状态列表项与事件列表项"><a href="#状态列表项与事件列表项" class="headerlink" title="状态列表项与事件列表项"></a>状态列表项与事件列表项</h3><p>从TCB的结构中可以发现两个定义的列表项，分别是<strong>状态列表项和事件列表项</strong>，在上一章也略微提到过，列表与列表项用于调度任务、跟踪任务状态。例如：在task.c中，定义了一些静态列表变量，其中有就绪、阻塞、挂起列表，例如当某个任务处于就绪态时，调度器就将这个任务TCB的<strong>状态列表项</strong>挂接到就绪列表。事件列表项也与之类似，当队列满的情况下，任务因入队操作而阻塞时，就会将<strong>事件列表项</strong>挂接到队列的等待入队列表上。具体实现方法和规则会在之后学习任务调度时讲到。</p>
<h3 id="uxTCBNumber与uxTaskNumber"><a href="#uxTCBNumber与uxTaskNumber" class="headerlink" title="uxTCBNumber与uxTaskNumber"></a>uxTCBNumber与uxTaskNumber</h3><p>这两个变量主要用于调试与可视化追踪。仅当宏configUSE_TRACE_FACILITY（位于FreeRTOSConfig.h中）为1时有效。变量uxTCBNumber在创建任务时<strong>由内核自动分配</strong>，每个任务对应一个值，<strong>后续不再改变</strong>。变量uxTaskNumber由<strong>API函数vTaskSetTaskNumber()来设置的</strong>，数值由函数参数指定。</p>
<p>其定义在task.c中如下，参数为对应任务的引用句柄和要设置的数值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskSetTaskNumber</span><span class="params">( TaskHandle_t xTask, <span class="type">const</span> UBaseType_t uxHandle )</span></span><br><span class="line">&#123;</span><br><span class="line">	TCB_t *pxTCB;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>( xTask != <span class="literal">NULL</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			pxTCB = ( TCB_t * ) xTask;</span><br><span class="line">			pxTCB-&gt;uxTaskNumber = uxHandle;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="任务创建的内部流程"><a href="#任务创建的内部流程" class="headerlink" title="任务创建的内部流程"></a>任务创建的内部流程</h1><p>假设当前创建了一个任务如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> TaskHandle_t xHandle；</span><br><span class="line">xTaskCreate(vTask_A,”Task A”,<span class="number">120</span>,<span class="literal">NULL</span>,<span class="number">1</span>,&amp;xHandle);</span><br></pre></td></tr></table></figure>

<p>当这个语句执行后，任务A被创建并加入就绪任务列表，我们这章的主要目的，就是看看这个语句在执行过程中，发生了什么事情。</p>
<h2 id="1、创建任务堆栈和TCB所用空间"><a href="#1、创建任务堆栈和TCB所用空间" class="headerlink" title="1、创建任务堆栈和TCB所用空间"></a>1、创建任务堆栈和TCB所用空间</h2><p>注：原博客中也就是接下来讲到的函数在我使用的基于STM32的FreeRTOS中并不存在，但是可以在对xTaskCreate的定义下找到基本类似的操作（可能是版本原因）<strong>，不过其并不是用函数封装的，但是功能基本一致</strong>。为了方便学习就使用原博客中的函数来理解。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> TCB_t *<span class="title function_">prvAllocateTCBAndStack</span><span class="params">( <span class="type">const</span> <span class="type">uint16_t</span> usStackDepth, StackType_t * <span class="type">const</span> puxStackBuffer, TCB_t * <span class="type">const</span> pxTaskBuffer )</span></span><br><span class="line">&#123;</span><br><span class="line">TCB_t *pxNewTCB;</span><br><span class="line">StackType_t *pxStack;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 分配堆栈空间*/</span></span><br><span class="line">    pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( <span class="type">size_t</span> ) usStackDepth ) * <span class="keyword">sizeof</span>( StackType_t ) ), puxStackBuffer );</span><br><span class="line">    <span class="keyword">if</span>( pxStack != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 分配TCB空间 */</span></span><br><span class="line">        pxNewTCB = ( TCB_t * ) pvPortMallocAligned( <span class="keyword">sizeof</span>( TCB_t ), pxTaskBuffer );</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>( pxNewTCB != <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 将堆栈起始位置存入TCB*/</span></span><br><span class="line">            pxNewTCB-&gt;pxStack = pxStack;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 如果TCB分配失败，释放之前申请的堆栈空间 */</span></span><br><span class="line">            <span class="keyword">if</span>( puxStackBuffer == <span class="literal">NULL</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                vPortFree( pxStack );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pxNewTCB = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>( pxNewTCB != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 如果需要，使用固定值填充堆栈 */</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span>( ( configCHECK_FOR_STACK_OVERFLOW&gt; 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark== 1 ) )</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 仅用于调试 */</span></span><br><span class="line">            ( <span class="type">void</span> ) <span class="built_in">memset</span>( pxNewTCB-&gt;pxStack, ( <span class="type">int</span> ) tskSTACK_FILL_BYTE, ( <span class="type">size_t</span> ) usStackDepth * <span class="keyword">sizeof</span>( StackType_t ) );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> pxNewTCB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本就是一些分配内存的逻辑与操作，还是比较好理解的。</p>
<h2 id="2、初始化TCB必要的字段"><a href="#2、初始化TCB必要的字段" class="headerlink" title="2、初始化TCB必要的字段"></a>2、初始化TCB必要的字段</h2><p>这些操作在我的版本中都是用预编译判断执行的，没有使用函数封装，要找到对应操作实在是有点眼花，姑且看到大部分操作都是在task.c中对xTaskCreate的定义的后面，这里为了<strong>方便理解</strong>还是使用原博主的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvInitialiseTCBVariables</span><span class="params">( </span></span><br><span class="line"><span class="params">TCB_t * <span class="type">const</span> pxTCB,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName, </span></span><br><span class="line"><span class="params">UBaseType_t uxPriority,   </span></span><br><span class="line"><span class="params"><span class="type">const</span> MemoryRegion_t * <span class="type">const</span> xRegions, </span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">uint16_t</span> usStackDepth </span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	UBaseType_t x;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 将任务描述存入TCB */</span></span><br><span class="line">    <span class="keyword">for</span>( x = ( UBaseType_t ) <span class="number">0</span>; x &lt; ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )</span><br><span class="line">    &#123;</span><br><span class="line">        pxTCB-&gt;pcTaskName[ x ] = pcName[ x ];</span><br><span class="line">        <span class="keyword">if</span>( pcName[ x ] == <span class="number">0x00</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 确保字符串有结束 */</span></span><br><span class="line">    pxTCB-&gt;pcTaskName[ configMAX_TASK_NAME_LEN - <span class="number">1</span> ] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 调整优先级，宏configMAX_PRIORITIES的值在FreeRTOSConfig.h中设置 */</span></span><br><span class="line">    <span class="keyword">if</span>( uxPriority &gt;= ( UBaseType_t ) configMAX_PRIORITIES )</span><br><span class="line">    &#123;</span><br><span class="line">        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) <span class="number">1U</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    pxTCB-&gt;uxPriority = uxPriority;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_MUTEXES == 1 )              <span class="comment">/*使用互斥量*/</span></span></span><br><span class="line">    &#123;  </span><br><span class="line">        pxTCB-&gt;uxBasePriority = uxPriority;</span><br><span class="line">        pxTCB-&gt;uxMutexesHeld = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_MUTEXES */</span></span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">/*初始化列表项*/</span></span><br><span class="line">    vListInitialiseItem( &amp;( pxTCB-&gt;xStateListItem ) );</span><br><span class="line">    vListInitialiseItem( &amp;( pxTCB-&gt;xEventListItem ) );</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 设置列表项xStateListItem的成员pvOwner指向当前任务控制块 */</span></span><br><span class="line">    listSET_LIST_ITEM_OWNER( &amp;( pxTCB-&gt;xStateListItem ), pxTCB );</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 设置列表项xEventListItem的成员xItemValue*/</span></span><br><span class="line">    listSET_LIST_ITEM_VALUE( &amp;( pxTCB-&gt;xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority );</span><br><span class="line">    <span class="comment">/* 设置列表项xEventListItem的成员pvOwner指向当前任务控制块 */</span></span><br><span class="line">    listSET_LIST_ITEM_OWNER( &amp;( pxTCB-&gt;xEventListItem ), pxTCB );</span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( portCRITICAL_NESTING_IN_TCB ==1 )    <span class="comment">/*使能临界区嵌套功能*/</span></span></span><br><span class="line">    &#123;  </span><br><span class="line">        pxTCB-&gt;uxCriticalNesting = ( UBaseType_t ) <span class="number">0U</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* portCRITICAL_NESTING_IN_TCB */</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_APPLICATION_TASK_TAG == 1 ) <span class="comment">/*使能任务标签功能*/</span></span></span><br><span class="line">    &#123;  </span><br><span class="line">        pxTCB-&gt;pxTaskTag = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_APPLICATION_TASK_TAG */</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configGENERATE_RUN_TIME_STATS == 1 )  <span class="comment">/*使能事件统计功能*/</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        pxTCB-&gt;ulRunTimeCounter = <span class="number">0UL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configGENERATE_RUN_TIME_STATS */</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( portUSING_MPU_WRAPPERS == 1 )         <span class="comment">/*使用MPU功能*/</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        vPortStoreTaskMPUSettings( &amp;( pxTCB-&gt;xMPUSettings ), xRegions, pxTCB-&gt;pxStack, usStackDepth );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span> <span class="comment">/* portUSING_MPU_WRAPPERS */</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        ( <span class="type">void</span> ) xRegions;</span><br><span class="line">        ( <span class="type">void</span> ) usStackDepth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* portUSING_MPU_WRAPPERS */</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span>( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )<span class="comment">/*使能线程本地存储指针*/</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>( x = <span class="number">0</span>; x &lt; ( UBaseType_t )configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )</span><br><span class="line">        &#123;</span><br><span class="line">            pxTCB-&gt;pvThreadLocalStoragePointers[ x ] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_TASK_NOTIFICATIONS == 1 )   <span class="comment">/*使能任务通知功能*/</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        pxTCB-&gt;ulNotifiedValue = <span class="number">0</span>;</span><br><span class="line">        pxTCB-&gt;ucNotifyState = taskNOT_WAITING_NOTIFICATION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_NEWLIB_REENTRANT == 1 )     <span class="comment">/*使用Newlib*/</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        _REENT_INIT_PTR( ( &amp;( pxTCB-&gt;xNewLib_reent ) ) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span>( INCLUDE_xTaskAbortDelay == 1 )</span></span><br><span class="line">    &#123;</span><br><span class="line">        pxTCB-&gt;ucDelayAborted = pdFALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实大部分也就是对应TCB结构体中各个成员的初始化，其中有几点需要着重讲一下：</p>
<h3 id="对两个列表项的初始化："><a href="#对两个列表项的初始化：" class="headerlink" title="对两个列表项的初始化："></a>对两个列表项的初始化：</h3><ul>
<li><p>对状态列表项的初始化</p>
<p>使成员pvOwner指向对应的任务TCB，其余成员不对其操作</p>
</li>
<li><p><strong>对事件列表项的初始化</strong></p>
<p>之前讲到过事件列表项值会存储任务的优先级相关信息，其存储方式比较特别：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置列表项xEventListItem的成员xItemValue*/</span></span><br><span class="line">listSET_LIST_ITEM_VALUE( </span><br><span class="line">&amp;( pxTCB-&gt;xEventListItem ), </span><br><span class="line">( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority );</span><br></pre></td></tr></table></figure>

<p>可以看出，事件列表项的xItemValue中存储的值为**<u>用户设置的最大优先级-当前任务的优先级</u><strong>，也就是说，ItemValue的值越小，当前任务的优先级</strong>越高**</p>
<p>再回想一下列表项插入列表的函数vListInsert()：</p>
<img src="/images/loading.png" data-original="/2022/12/12/FreeRTOS%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E5%88%86%E6%9E%90/15.jpg" class title="This is an image"> 

<p>可以发现xItemValue越小的值越是排在列表的前面，这也就解释了这样做的原因，<strong>其实也就是优先级越高的任务越在列表前面</strong></p>
</li>
</ul>
<h3 id="任务通知"><a href="#任务通知" class="headerlink" title="任务通知"></a>任务通知</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> ( configUSE_TASK_NOTIFICATIONS == 1 )   <span class="comment">/*使能任务通知功能*/</span></span></span><br><span class="line">&#123;</span><br><span class="line">    pxTCB-&gt;ulNotifiedValue = <span class="number">0</span>;</span><br><span class="line">    pxTCB-&gt;ucNotifyState = taskNOT_WAITING_NOTIFICATION;</span><br></pre></td></tr></table></figure>

<p>在<a href="https://dhkkk.gitee.io/2022/08/30/freertos%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F/">FreeRTOS任务间的交互方法 | 小董的BLOG (gitee.io)</a>中将任务通知的流程时也使用到了使用该值的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotifyWait</span><span class="params">( uint32_tulBits ToClearOnEntry,</span></span><br><span class="line"><span class="params">									 uint32_tulBits ToClearOnExit,</span></span><br><span class="line"><span class="params">									 <span class="type">uint32_t</span>* pulNotificationValue,</span></span><br><span class="line"><span class="params">									 TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>

<p>其实pulNotificationValue就是拷贝自TCB中的ulNotifiedValue值，该值在任务通知发送函数将ulValue的值拷贝进ulNotifiedValue，在接收时用户可以通过pulNotificationValue判断任务通知发送的值。在初始化时，其为0，因此发送的任务值不能为0</p>
<h2 id="3、初始化任务堆栈"><a href="#3、初始化任务堆栈" class="headerlink" title="3、初始化任务堆栈"></a>3、初始化任务堆栈</h2><p>调用函数pxPortInitialiseStack()初始化任务堆栈，并将最新的栈顶指针赋值给任务TCB的pxTopOfStack字段。</p>
<p>具体与寄存器的调用有关，目前不深读。</p>
<h2 id="4、进入临界区"><a href="#4、进入临界区" class="headerlink" title="4、进入临界区"></a>4、进入临界区</h2><p> 调用taskENTER_CRITICAL()进入临界区，进入临界区后的代码段将不能被打断，比如有的外设的初始化需要严格的时序，初始化过程中不能被打断。FreeRTOS 在进入临界区代码的时候需要关闭中断，当处理完临界区代码以后再打开中断。</p>
<p>FreeRTOS 与 临界区代 码 保 护 有 关 的 函 数 有 4 个 ： taskENTER_CRITICAL() 、taskEXIT_CRITICAL() 、taskENTER_CRITICAL_FROM_ISR() 和taskEXIT_CRITICAL_FROM_ISR()，这四个函数其实是宏定义，在 task.h 文件中有定义。 这四个函数的区别是<strong>前两个是任务级的</strong>临界段代码保护，<strong>后两个是中断级</strong>的临界段代码保护。</p>
<h2 id="5、改变跟踪任务的变量"><a href="#5、改变跟踪任务的变量" class="headerlink" title="5、改变跟踪任务的变量"></a>5、改变跟踪任务的变量</h2><p>在task.c中定义了一些静态私有变量用于跟踪任务的数量、状态等信息，每当有任务发生变化时这些对应的变量也会发生变化。</p>
<p>其中变量uxCurrentNumberOfTasks表示当前任务的总数量，每创建一个任务，这个变量都会增加1。</p>
<h2 id="6、第一次运行的必要初始化"><a href="#6、第一次运行的必要初始化" class="headerlink" title="6、第一次运行的必要初始化"></a>6、第一次运行的必要初始化</h2><p>如果当前创建的任务为第一个任务，则会调用函数prvInitialiseTaskLists()对列表进行<strong>初始化</strong>，在这之前，task.c中定义了这些静态类型的列表变量：(List_t类型变量在上一章已经讲过)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PRIVILEGED_DATAstatic List_t pxReadyTasksLists[ configMAX_PRIORITIES ];<span class="comment">/*按照优先级排序的就绪态任务*/</span></span><br><span class="line">PRIVILEGED_DATAstatic List_t xDelayedTaskList1;                    <span class="comment">/*延时的任务 */</span></span><br><span class="line">PRIVILEGED_DATAstatic List_t xDelayedTaskList2;                    <span class="comment">/*延时的任务 */</span></span><br><span class="line">PRIVILEGED_DATAstatic List_t xPendingReadyList;             <span class="comment">/*任务已就绪,但调度器被挂起 */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (INCLUDE_vTaskDelete == 1 )</span></span><br><span class="line">    PRIVILEGED_DATA <span class="type">static</span> List_t xTasksWaitingTermination;<span class="comment">/*任务已经被删除,但内存尚未释放*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (INCLUDE_vTaskSuspend == 1 )</span></span><br><span class="line">    PRIVILEGED_DATA <span class="type">static</span> List_t xSuspendedTaskList;            <span class="comment">/*当前挂起的任务*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvInitialiseTaskLists</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">UBaseType_tuxPriority;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>( uxPriority = ( UBaseType_t ) <span class="number">0U</span>; uxPriority &lt; ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )</span><br><span class="line">    &#123;</span><br><span class="line">        vListInitialise( &amp;( pxReadyTasksLists[ uxPriority ] ) );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    vListInitialise( &amp;xDelayedTaskList1 );</span><br><span class="line">    vListInitialise( &amp;xDelayedTaskList2 );</span><br><span class="line">    vListInitialise( &amp;xPendingReadyList );</span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( INCLUDE_vTaskDelete == 1 )</span></span><br><span class="line">    &#123;</span><br><span class="line">        vListInitialise( &amp;xTasksWaitingTermination );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* INCLUDE_vTaskDelete */</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( INCLUDE_vTaskSuspend == 1 )</span></span><br><span class="line">    &#123;</span><br><span class="line">        vListInitialise( &amp;xSuspendedTaskList );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* INCLUDE_vTaskSuspend */</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskListusing list2. */</span></span><br><span class="line">    pxDelayedTaskList = &amp;xDelayedTaskList1;</span><br><span class="line">    pxOverflowDelayedTaskList = &amp;xDelayedTaskList2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中主要调用的函数vListInitialise()在讲列表时已经讲过，其作用就是初始化列表成员的一些指针的初始指向，为后续接入列表项做准备。</p>
<h2 id="7、更新任务TCB指针"><a href="#7、更新任务TCB指针" class="headerlink" title="7、更新任务TCB指针"></a>7、更新任务TCB指针</h2><p>tasks.c中定义了一个任务TCB指针型变量：</p>
<ul>
<li>PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB&#x3D; NULL;</li>
</ul>
<p> 这是一个全局变量，在tasks.c中只定义了这一个全局变量。这个变量用来指向当前正在运行的任务TCB。</p>
<p>当调度器还没有开启时（程序刚开始运行时，可能会先创建几个任务，之后才会启动调度器），如果新创建的任务优先级大于pxCurrentTCB指向的任务优先级，则设置pxCurrentTCB指向当前新创建的任务TCB。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( xSchedulerRunning == pdFALSE )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( pxCurrentTCB-&gt;uxPriority &lt;= uxPriority )</span><br><span class="line">    &#123;</span><br><span class="line">        pxCurrentTCB = pxNewTCB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这项操作可以<strong>确保pxCurrentTCB始终指向优先级最高的就绪任务。</strong></p>
<h2 id="8、将新创建的任务加入就绪列表数组"><a href="#8、将新创建的任务加入就绪列表数组" class="headerlink" title="8、将新创建的任务加入就绪列表数组"></a>8、将新创建的任务加入就绪列表数组</h2><p>新创建的任务会被直接加入到就绪列表中，因为它不会一被创建就被阻塞或挂起。观察在task.c中定义的几个静态类型的列表可以发现就绪列表是一个结构体数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PRIVILEGED_DATAstatic List_t pxReadyTasksLists[ configMAX_PRIORITIES ];</span><br><span class="line"><span class="comment">/*按照优先级排序的就绪态任务*/</span></span><br></pre></td></tr></table></figure>

<p>因此当前新创建的任务会根据该任务TCB中存储的优先级<strong>决定存入的列表下标</strong>。比如我们新创建的任务优先级为1，则这个任务被加入到列表pxReadyTasksLists[1]中。</p>
<p>并且由于同一个列表中任务的优先级是相同的，因此每次加入列表时会直接将当前任务放入列表尾：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> prvAddTaskToReadyList( pxTCB )                        </span></span><br><span class="line">    taskRECORD_READY_PRIORITY( ( pxTCB)-&gt;uxPriority );       </span><br><span class="line">    vListInsertEnd( &amp;( pxReadyTasksLists[ (pxTCB )-&gt;uxPriority ] ), </span><br><span class="line">                    &amp;( ( pxTCB )-&gt;xStateListItem ) );</span><br></pre></td></tr></table></figure>

<p>调用一个宏将任务放入列表。可以看到，加入列表的为任务的<strong>状态列表项</strong>，但最终调用宏的<strong>参数直接是任务TCB</strong>，因此可能用户不用关心何时操作状态列表项，何时操作事件列表项？（我的猜测，因为目前还不太清楚二者的明显区别）</p>
<h2 id="9、退出临界区"><a href="#9、退出临界区" class="headerlink" title="9、退出临界区"></a>9、退出临界区</h2><p>到此，一个任务的创建基本结束，也就可以退出临界区了（本身进入临界区的原因就是让任务的创建过程不被打断）</p>
<h2 id="10、新任务进入调度"><a href="#10、新任务进入调度" class="headerlink" title="10、新任务进入调度"></a>10、新任务进入调度</h2><p>如果调度器已开启，新任务便会根据其优先级由调度器进行相关调度。</p>
<h1 id="任务创建过程总结"><a href="#任务创建过程总结" class="headerlink" title="任务创建过程总结"></a>任务创建过程总结</h1><ul>
<li>为当前任务<strong>分配内存</strong>创建堆栈，为任务TCB创建空间</li>
<li><strong>初始化TCB</strong>，主要是使TCB成员中的两个列表项指向当前TCB和改变<strong>事件列表项的列表项值</strong></li>
<li><strong>初始化</strong>任务的<strong>堆栈</strong></li>
<li><em><strong>进入临界区，之后的进程不能被打断</strong></em></li>
<li>改变一些存储任务信息的<strong>变量</strong>（主要是全局的信息，并不是指某一个任务的信息。比如任务的总数量等）</li>
<li>如果当前为第一个任务，则<strong>初始化各列表</strong></li>
<li><strong>更新</strong>当前的任务TCB指针（该指针专用于指向当前TCB）</li>
<li>将新任务加入就绪列表数组中，<strong>根据优先级决定加入的数组下标</strong></li>
<li><em><strong>退出临界区</strong></em></li>
<li>新任务也加入调度过程中</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 嵌入式学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于FreeRTOS的列表学习]]></title>
      <url>/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p><em>本文参考了<a href="https://freertos.blog.csdn.net/article/details/51190095">FreeRTOS高级篇1—FreeRTOS列表和列表项研究是为了理解的博客-CSDN博客freertos list</a>进行学习</em></p>
<h1 id="列表与列表项"><a href="#列表与列表项" class="headerlink" title="列表与列表项"></a>列表与列表项</h1><p>FreeRTOS内核为了调度任务之间的关系，大量地使用了列表和列表项的数据结果来跟踪任务当前的状态。例如，处于挂起、延时、就绪的任务都会被挂接<strong>到各自的列表中</strong></p>
<p>FreeRTOS中使用指针实现列表的功能，类似于链式列表。<strong>一个列表下有多个列表项</strong>，且每个列表项中都有一个指针指向列表。</p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/1.jpg" class title="This is an image"> 

<p><strong>需要注意的是，<u>列表</u>和之前讲到任务交互时使用的<u>队列</u>是两个东西！</strong></p>
<h1 id="FreeRTOS列表项的构成"><a href="#FreeRTOS列表项的构成" class="headerlink" title="FreeRTOS列表项的构成"></a>FreeRTOS列表项的构成</h1><h2 id="全功能版列表项"><a href="#全功能版列表项" class="headerlink" title="全功能版列表项"></a>全功能版列表项</h2><p>我们可以在list.h中找到freertos对列表项的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE           <span class="comment">/*用于检测列表项数据是否完整*/</span></span><br><span class="line">     configLIST_VOLATILE TickType_t xItemValue;           <span class="comment">/*列表项值*/</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxNext</span>;</span>      <span class="comment">/*指向列表中下一个列表项*/</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxPrevious</span>;</span>  <span class="comment">/*指向列表中上一个列表项*/</span></span><br><span class="line">     <span class="type">void</span> * pvOwner;                                     <span class="comment">/*指向一个任务TCB*/</span></span><br><span class="line">     <span class="type">void</span> * configLIST_VOLATILE pvContainer;             <span class="comment">/*指向包含该列表项的列表 */</span></span><br><span class="line">     listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE          <span class="comment">/*用于检测列表项数据是否完整*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> <span class="title">ListItem_t</span>;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE 和listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE 这两个宏定义用于<strong>检查列表项的数据是否完整</strong>。</p>
<p>当使能projdefs.h中的宏configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES时，这两个宏会被替换成两个已知的数值用于检测完整性。</p>
</li>
<li><p>xItemValue为<strong>列表项值</strong>，通常是一个被跟踪的任务优先级或是一个调度事件的计数器值。</p>
<p>例如在队列的使用中，如果一个任务因为在等待从队列中读取数据而进入阻塞态，则该任务的<strong>事件列表项中的列表项值</strong>会用于保存该任务的优先级有关信息；该任务的<strong>状态列表项的列表项值</strong>会用于保存阻塞时间的有关信息（之前讲过，当有多个任务等待读取队列时，读取顺序与优先级和阻塞时间相关）。至于什么是事件列表项和状态列表项，之后的文章会讲到。</p>
<p>由于列表项值应是随时都可能更新的，因此该变量被configLIST_VOLATILE修饰，<strong>该宏被映射为C的关键字volatile</strong>。</p>
</li>
<li><p>pxNext和pxPrevious为两个结构体指针，用于指向上下列表项，实现类似于双向链表的结构，对结构体指针还不太懂的话可以参考<a href="https://dhkkk.gitee.io/2022/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/">数据结构_链表 | 小董的BLOG (gitee.io)</a>中的一些解释。</p>
</li>
<li><p>pvOwner用于指向一个任务的TCB（Task Control Block），之后的文章会讲到。</p>
</li>
<li><p>pvContainer用于指向<strong>包含该列表项的列表</strong>。</p>
</li>
</ul>
<h2 id="迷你版列表项"><a href="#迷你版列表项" class="headerlink" title="迷你版列表项"></a>迷你版列表项</h2><p>list.h中还有一个迷你版列表项的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xMINI_LIST_ITEM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			<span class="comment">//检测完整性</span></span><br><span class="line">	configLIST_VOLATILE TickType_t xItemValue;	<span class="comment">//列表项值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxNext</span>;</span>		<span class="comment">//指向下一列表项</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxPrevious</span>;</span>	<span class="comment">//指向前一列表项</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xMINI_LIST_ITEM</span> <span class="title">MiniListItem_t</span>;</span></span><br></pre></td></tr></table></figure>

<p>迷你版列表项的作用下一节讲列表时会讲到。</p>
<h2 id="初始化列表项"><a href="#初始化列表项" class="headerlink" title="初始化列表项"></a>初始化列表项</h2><p>  列表项的初始比较简单，只要确保列表项不在任何列表中即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vListInitialiseItem</span><span class="params">( ListItem_t * <span class="type">const</span> pxItem )</span></span><br><span class="line">&#123;</span><br><span class="line">     pxItem-&gt;pvContainer = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/*设置为已知值，用于检测列表项数据是否完整*/</span></span><br><span class="line">     listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem );</span><br><span class="line">     listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="FreeRTOS的列表构成"><a href="#FreeRTOS的列表构成" class="headerlink" title="FreeRTOS的列表构成"></a>FreeRTOS的列表构成</h1><h2 id="列表的定义"><a href="#列表的定义" class="headerlink" title="列表的定义"></a>列表的定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xLIST</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	listFIRST_LIST_INTEGRITY_CHECK_VALUE				<span class="comment">//检测完整性</span></span><br><span class="line">	configLIST_VOLATILE UBaseType_t uxNumberOfItems;</span><br><span class="line">	ListItem_t * configLIST_VOLATILE pxIndex;			</span><br><span class="line">	MiniListItem_t xListEnd;							</span><br><span class="line">	listSECOND_LIST_INTEGRITY_CHECK_VALUE				<span class="comment">//检测完整性</span></span><br><span class="line">&#125; List_t;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>uxNumberOfItems用于表示该列表中挂接的列表项数目，0表示列表为空。</p>
</li>
<li><p>pxIndex为一个类型为完全体列表项的结构体指针，用于<strong>遍历列表项。</strong></p>
</li>
<li><p>列表项xListEnd用于标记列表结束，<strong>因为该列表项只用于标记列表的结束，因此不需要完全体列表项的所有功能</strong>，因此使用了迷你版列表项的类型。</p>
<p>xListEnd.xItemValue被<strong>初始化为一个常数</strong>，其值与硬件架构相关，为0xFFFF（16位架构）或0xFFFFFFFF（32位架构）。</p>
</li>
</ul>
<h2 id="列表的初始化"><a href="#列表的初始化" class="headerlink" title="列表的初始化"></a>列表的初始化</h2><p>可以在list.c中找到初始化函数vListInitialise()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vListInitialise</span><span class="params">( List_t * <span class="type">const</span> pxList )</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">/*列表索引指向列表项xListEnd*/</span></span><br><span class="line">     pxList-&gt;pxIndex = ( ListItem_t * )&amp;( pxList-&gt;xListEnd );                  </span><br><span class="line">     <span class="comment">/* 设置为最大可能值为0xffff */</span></span><br><span class="line">     pxList-&gt;xListEnd.xItemValue =portMAX_DELAY;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/* 列表项xListEnd的pxNext和pxPrevious指针指向了它自己 */</span></span><br><span class="line">     pxList-&gt;xListEnd.pxNext = (ListItem_t * ) &amp;( pxList-&gt;xListEnd );</span><br><span class="line">     pxList-&gt;xListEnd.pxPrevious= ( ListItem_t * ) &amp;( pxList-&gt;xListEnd );</span><br><span class="line">     pxList-&gt;uxNumberOfItems = ( UBaseType_t) <span class="number">0U</span>;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/* 设置为已知值，用于检测列表数据是否完整*/</span></span><br><span class="line">     listSET_LIST_INTEGRITY_CHECK_1_VALUE(pxList );</span><br><span class="line">     listSET_LIST_INTEGRITY_CHECK_2_VALUE(pxList );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果宏configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES设置为1，则使能列表项数据完整性检查，则宏listSET_LIST_INTEGRITY_CHECK_1_VALUE()和listSET_LIST_INTEGRITY_CHECK_2_VALUE被一个已知值代替，默认为0x5a5a（16位架构）或者0x5a5a5a5a（32位架构）。</p>
</li>
<li><p>按照上述初始化后就应该是下图的情况：</p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/2.jpg" class title="This is an image"> 

<p>此时pxIndex、pxList-&gt;xListEnd.pxNext、pxList-&gt;xListEnd.pxPrevious都指向了 pxList-&gt;xListEnd（也可以说是xListEnd这个结构体的首元素）</p>
</li>
</ul>
<h1 id="将列表项插入列表中"><a href="#将列表项插入列表中" class="headerlink" title="将列表项插入列表中"></a>将列表项插入列表中</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vListInsert</span><span class="params">( List_t * <span class="type">const</span> pxList, ListItem_t * <span class="type">const</span> pxNewListItem )</span></span><br><span class="line">&#123;</span><br><span class="line">ListItem_t *pxIterator;		<span class="comment">//函数内定义一个列表项指针，通过列表项值的比较，找到当前输入列表项需插入的位置</span></span><br><span class="line"><span class="type">const</span> TickType_t xValueOfInsertion = pxNewListItem-&gt;xItemValue;	<span class="comment">//定义一个变量存放当前输入列表项的列表项值</span></span><br><span class="line"></span><br><span class="line">	listTEST_LIST_INTEGRITY( pxList );		<span class="comment">//检测完整性</span></span><br><span class="line">	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );		<span class="comment">//检测完整性</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*开始为输入列表项寻找合适的插入位置*/</span></span><br><span class="line">	<span class="keyword">if</span>( xValueOfInsertion == portMAX_DELAY )</span><br><span class="line">	&#123;</span><br><span class="line">		pxIterator = pxList-&gt;xListEnd.pxPrevious;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>( pxIterator = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd ); </span><br><span class="line">								  pxIterator-&gt;pxNext-&gt;xItemValue &lt;= xValueOfInsertion; </span><br><span class="line">								  pxIterator = pxIterator-&gt;pxNext ) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* There is nothing to do here, just iterating to the wanted</span></span><br><span class="line"><span class="comment">			insertion position. */</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">   <span class="comment">/******************************/</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">/*此时pxIterator为当前pxNewListItem要插入的位置*/</span></span><br><span class="line">	pxNewListItem-&gt;pxNext = pxIterator-&gt;pxNext;</span><br><span class="line">	pxNewListItem-&gt;pxNext-&gt;pxPrevious = pxNewListItem;</span><br><span class="line">	pxNewListItem-&gt;pxPrevious = pxIterator;</span><br><span class="line">	pxIterator-&gt;pxNext = pxNewListItem;</span><br><span class="line">   </span><br><span class="line">	<span class="comment">/*将列表项接入列表，列表项数目+1*/</span></span><br><span class="line">	pxNewListItem-&gt;pvContainer = ( <span class="type">void</span> * ) pxList;</span><br><span class="line">	( pxList-&gt;uxNumberOfItems )++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数中比较难以理解的地方就是关于寻找列表项插入位置的判断和循环部分，接下来将一步一步讲解：</p>
<h2 id="当列表内无列表项时（当前插入的列表项为第一个列表项）"><a href="#当列表内无列表项时（当前插入的列表项为第一个列表项）" class="headerlink" title="当列表内无列表项时（当前插入的列表项为第一个列表项）"></a>当列表内无列表项时（当前插入的列表项为第一个列表项）</h2><p>假设该列表项值为50</p>
<h3 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h3><p>不满足条件，跳过</p>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><ul>
<li><p>初始化<code>pxIterator = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd );</code>后，此时情况为：</p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/3.jpg" class title="This is an image"> 

<p>此时pxIterator成员与pxList-&gt;xListEnd的成员一一对应</p>
</li>
<li><p>条件判断<code>pxIterator-&gt;pxNext-&gt;xItemValue &lt;= xValueOfInsertion;</code></p>
<p>这里需要注意：<strong>列表初始化时，xListEnd的成员pxNext，pxPrevious是指向xListEnd的</strong></p>
<p>因此pxIterator-&gt;pxNext-&gt;xItemValue的值就是0xFFFF，是大于50的，因此不满足条件，跳出循环</p>
</li>
</ul>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><ul>
<li><p><strong>pxNewListItem-&gt;pxNext &#x3D; pxIterator-&gt;pxNext;</strong></p>
<p>pxIterator-&gt;pxNext指向pxList-&gt;xListEnd.pxnext，而pxList-&gt;xListEnd.pxnext又指向本身xListEnd；因此，<u><strong>最终pxNewListItem-&gt;pxNext指向了pxList-&gt;xListEnd</strong></u></p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/4.jpg" class title="cysgbj"> 
</li>
<li><p><strong>pxNewListItem-&gt;pxNext-&gt;pxPrevious &#x3D; pxNewListItem;</strong></p>
<p>上一步中pxNewListItem-&gt;pxNext指向了pxList-&gt;xListEnd，因此pxNewListItem-&gt;pxNext-&gt;pxPrevious等同于pxList-&gt;xListEnd.pxPrevious，而pxList-&gt;xListEnd.pxPrevious之前是指向pxList-&gt;xListEnd本身的，因此<u><strong>这一步最终的结果相当于将pxList-&gt;xListEnd.pxPrevious改变指向，指向pxNewListItem</strong></u></p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/5.jpg" class title="cysgbj"> 
</li>
<li><p><strong>pxNewListItem-&gt;pxPrevious &#x3D; pxIterator;</strong></p>
<p>由于pxIterator本身就是指向pxList-&gt;xListEnd的，因此这一步相当于：</p>
<p><u><strong>pxNewListItem-&gt;pxPrevious &#x3D; pxList-&gt;xListEnd</strong></u></p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/6.jpg" class title="cysgbj"> 
</li>
<li><p><strong>pxIterator-&gt;pxNext &#x3D; pxNewListItem;</strong></p>
<p>pxIterator-&gt;pxNext指向pxList-&gt;xListEnd.pxnext，此时pxList-&gt;xListEnd.pxnext本来是指向自己（pxList-&gt;xListEnd）的，因此这一步最终是：</p>
<p><strong><u>将pxList-&gt;xListEnd.pxnext改变指向，指向pxNewListItem</u></strong></p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/7.jpg" class title="cysgbj"> 
</li>
<li><p>综上，最终的结果为：</p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/8.jpg" class title="cysgbj"> 

<p><em>上图省略了pvContainer和pxIndex的指向和uxNumberOfItems的变化</em></p>
</li>
</ul>
<h2 id="第二次，当列表中已有列表项时，且该列表项值大于上一个"><a href="#第二次，当列表中已有列表项时，且该列表项值大于上一个" class="headerlink" title="第二次，当列表中已有列表项时，且该列表项值大于上一个"></a>第二次，当列表中已有列表项时，且该列表项值大于上一个</h2><p>假设第二个列表项值为60（第一个为50）</p>
<h3 id="if判断-1"><a href="#if判断-1" class="headerlink" title="if判断"></a>if判断</h3><p>不满足条件，跳过</p>
<h3 id="for循环-1"><a href="#for循环-1" class="headerlink" title="for循环"></a>for循环</h3><ul>
<li><p>初始化<code>pxIterator = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd );</code>后，由于在上一个列表项插入后，pxList.xListEnd中的pxNext和pxPrevious已经改变了指向，因此当前情况为：</p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/9.jpg" class title="cysgbj"> 
</li>
<li><p>条件判断<code>pxIterator-&gt;pxNext-&gt;xItemValue &lt;= xValueOfInsertion;</code></p>
<p>由上图可得知，此时pxIterator-&gt;pxNext-&gt;xItemValue为50，小于60，条件成立</p>
</li>
<li><p>执行<code>pxIterator = pxIterator-&gt;pxNext</code></p>
<p>由于pxIterator-&gt;pxNext指向pxNewListItem(1)，因此当前情况如下：</p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/10.jpg" class title="cysgbj"> 
</li>
<li><p>再次进行条件判断<code>pxIterator-&gt;pxNext-&gt;xItemValue &lt;= xValueOfInsertion;</code></p>
<p>此时pxIterator-&gt;pxNext-&gt;xItemValue为0xffff，不满足条件，循环结束。</p>
</li>
</ul>
<p><strong>综上，通过该for循环，可以根据每个列表项值的大小进行列表中的位置排序</strong></p>
<h3 id="赋值-1"><a href="#赋值-1" class="headerlink" title="赋值"></a>赋值</h3><p>这里的所有pxNewListItem在未特别说明的情况下都是指pxNewListItem(2）</p>
<ul>
<li><p><strong>pxNewListItem-&gt;pxNext &#x3D; pxIterator-&gt;pxNext;</strong></p>
<p>同第一次插入列表，<u><strong>最终pxNewListItem-&gt;pxNext指向了pxList-&gt;xListEnd</strong></u></p>
</li>
<li><p><strong>pxNewListItem-&gt;pxNext-&gt;pxPrevious &#x3D; pxNewListItem;</strong></p>
<p>同第一次插入列表，<u><strong>将pxList-&gt;xListEnd.pxPrevious改变指向，指向pxNewListItem</strong></u></p>
</li>
<li><p><strong>pxNewListItem-&gt;pxPrevious &#x3D; pxIterator;</strong></p>
<p>pxIterator在for循环中已经指向了pxNewListItem(1)，因此这里：</p>
<p><u><strong>pxNewListItem-&gt;pxPrevious指向pxNewListItem(1)</strong></u></p>
</li>
<li><p><strong>pxIterator-&gt;pxNext &#x3D; pxNewListItem;</strong></p>
<p>pxIterator-&gt;pxNext指向pxNewListItem(1)-&gt;pxnext，而pxNewListItem(1)-&gt;next最终指向了pxlist.xListEnd，因此这里相当于:</p>
<p><u><strong>改变pxNewListItem(1)-&gt;pxnext的指向，使其指向pxNewListItem(2)</strong></u></p>
</li>
</ul>
<p>综上，当前结果为：</p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/11.jpg" class title="cysgbj"> 

<p>有点乱，也可以参考下图，一样的</p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/12.jpg" class title="cysgbj">

<p>不难看出，赋值的最后两步将各个列表项相互链接</p>
<h2 id="第二次，当列表中已有列表项时，但该列表项值小于上一个"><a href="#第二次，当列表中已有列表项时，但该列表项值小于上一个" class="headerlink" title="第二次，当列表中已有列表项时，但该列表项值小于上一个"></a>第二次，当列表中已有列表项时，但该列表项值小于上一个</h2><p>假设第二个列表值为30，小于第一个列表值50</p>
<h3 id="if判断-2"><a href="#if判断-2" class="headerlink" title="if判断"></a>if判断</h3><p>不满足条件，跳过</p>
<h3 id="for循环-2"><a href="#for循环-2" class="headerlink" title="for循环"></a>for循环</h3><ul>
<li><p>初始化<code>pxIterator = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd );</code>后，由于在上一个列表项插入后，pxList.xListEnd中的pxNext和pxPrevious已经改变了指向，因此当前情况为：</p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/9.jpg" class title="cysgbj"> 
</li>
<li><p>条件判断<code>pxIterator-&gt;pxNext-&gt;xItemValue &lt;= xValueOfInsertion;</code></p>
<p>由上图可得知，此时pxIterator-&gt;pxNext-&gt;xItemValue为50，大于30，条件不成立，循环结束</p>
</li>
</ul>
<h3 id="赋值-2"><a href="#赋值-2" class="headerlink" title="赋值"></a>赋值</h3><p>这里的所有pxNewListItem在未特别说明的情况下都是指pxNewListItem(2）</p>
<ul>
<li><p><strong>pxNewListItem-&gt;pxNext &#x3D; pxIterator-&gt;pxNext;</strong></p>
<p><u><strong>不同第一次插入列表！此时pxNewListItem-&gt;pxNext最终指向了xNewListItem(1)</strong></u></p>
</li>
<li><p><strong>pxNewListItem-&gt;pxNext-&gt;pxPrevious &#x3D; pxNewListItem;</strong></p>
<p><strong>不同第一次插入列表！</strong>此时pxNewListItem-&gt;pxNext-&gt;pxPrevious 即是：</p>
<p><u><strong>pxNewListItem(1)-&gt;xPrevious指向了pxNewListItem(2)</strong></u></p>
</li>
<li><p><strong>pxNewListItem-&gt;pxPrevious &#x3D; pxIterator;</strong></p>
<p>pxIterator是直接指向pxList-&gt;xListEnd的，因此：</p>
<p><u><strong>pxNewListItem-&gt;pxPrevious 直接指向pxList-&gt;xListEnd</strong></u></p>
</li>
<li><p><strong>pxIterator-&gt;pxNext &#x3D; pxNewListItem;</strong></p>
<p>在执行这一步之前，情况如下：</p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/13.jpg" class title="cysgbj"> 

<p>这里我产生了一个疑问，pxIterator-&gt;pxNext是指向pxNewListItem(1)，那让pxNewListItem(1)&#x3D;pxNewListItem是什么意思呢？让上一个列表项指向当前列表项？这明显是不符合列表逻辑的。</p>
<p>后来在找寻问题的过程中，才发现自己又犯了老错误，pxNewListItem(1)其实也是一个指针变量，他是直接指向列表项1的内存单元的，<strong>因此pxIterator-&gt;pxNext是直接指向了列表项1的内存单元</strong>，因此改变pxIterator-&gt;pxNext是直接改变了这个指针的指向，也就是说结果是：</p>
<p><strong><u>将pxList-&gt;xListEnd.pxNext改变指向，使其指向pxNewListItem(2)</u></strong></p>
</li>
</ul>
<p>综上，最后结果为：</p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/14.jpg" class title="cysgbj"> 

<h2 id="对比两种情况"><a href="#对比两种情况" class="headerlink" title="对比两种情况"></a>对比两种情况</h2><p>第二个列表项值大于第一个的情况：</p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/11.jpg" class title="cysgbj"> 

<p>对比一下，可以看出：</p>
<ul>
<li><strong>pxList-&gt;xListEnd.pxNext总是指向列表项值最小的列表项</strong></li>
<li><strong>pxList-&gt;xListEnd.pxPrevious总是指向列表项值最大的列表项</strong></li>
<li><strong>列表项值小的列表项的pxNext总是指向列表项值大的列表项</strong></li>
<li><strong>列表项值大的列表项的PxPrevious总是指向列表项值小的列表项</strong></li>
<li><strong>首列表项的pxPrevious和尾列表项的pxNext都指向pxList-&gt;xListEnd</strong></li>
</ul>
<p>根据上述的规律，就可以清晰地明白FreeRTOS对列表的插入方式了：</p>
<img src="/images/loading.png" data-original="/2022/12/09/%E5%9F%BA%E4%BA%8EFreeRTOS%E7%9A%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0/15.jpg" class title="cysgbj"> 

<p>因此，若要访问列表项，要通过pxList-&gt;xListEnd.pxNext访问手列表项，通过pxList-&gt;xListEnd.pxPrevious访问尾列表项。</p>
<p>实现插入的方法看了之后感觉真的很巧妙，我感觉也只能停留在理解的阶段，要自己写出来感觉难度还是很大。。。<strong>但是规律还是很好记住的😋</strong></p>
<h1 id="直接将列表项插入列表尾"><a href="#直接将列表项插入列表尾" class="headerlink" title="直接将列表项插入列表尾"></a>直接将列表项插入列表尾</h1><p>原理跟上面的是一样的，如果能理解插入的方法，相信这个理解起来就很ez了，就不多说了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vListInsertEnd</span><span class="params">( List_t * <span class="type">const</span> pxList, ListItem_t * <span class="type">const</span> pxNewListItem )</span></span><br><span class="line">&#123;</span><br><span class="line">ListItem_t* <span class="type">const</span> pxIndex = pxList-&gt;pxIndex;</span><br><span class="line"> </span><br><span class="line">         <span class="comment">/*检查列表和列表项数据的完整性，仅当configASSERT()定义时有效。*/</span></span><br><span class="line">         listTEST_LIST_INTEGRITY( pxList );</span><br><span class="line">         listTEST_LIST_ITEM_INTEGRITY(pxNewListItem );</span><br><span class="line"> </span><br><span class="line">         <span class="comment">/*向列表中插入新的列表项*/</span></span><br><span class="line">         pxNewListItem-&gt;pxNext = pxIndex;</span><br><span class="line">         pxNewListItem-&gt;pxPrevious =pxIndex-&gt;pxPrevious;</span><br><span class="line"> </span><br><span class="line">         mtCOVERAGE_TEST_DELAY();</span><br><span class="line"> </span><br><span class="line">         pxIndex-&gt;pxPrevious-&gt;pxNext =pxNewListItem;</span><br><span class="line">         pxIndex-&gt;pxPrevious = pxNewListItem;</span><br><span class="line"> </span><br><span class="line">         pxNewListItem-&gt;pvContainer = ( <span class="type">void</span>* ) pxList;</span><br><span class="line"> </span><br><span class="line">         ( pxList-&gt;uxNumberOfItems )++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在FreeRTOS中，任务的调度与列表息息相关，因此要想学好任务调度的原理，列表是第一大难关！</p>
]]></content>
      
        
        <tags>
            
            <tag> 嵌入式学习 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[单片机复习]]></title>
      <url>/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><ul>
<li><p>原码、反码、补码</p>
<p>正数的三者相同，负数反码为原码除符号位其余取反，补码为其反码+1</p>
<p><u><strong>负数的机器码是其原码的补码</strong></u></p>
</li>
<li><p>微型计算机配置高速缓冲存储器是为了解决： CPU于内存储器速度不匹配</p>
</li>
<li><p>ROM和RAM</p>
<ul>
<li>ROM：只读存储器，在单片机中用于存放程序，配有较大空间，<strong>掉电数据不丢失</strong></li>
<li>RAM：随机存储器，存放临时数据，使单片机<strong>更适用于实时控制系统</strong>，<strong>掉电数据丢失</strong></li>
<li><strong>计算机的内存容量主要指RAM</strong></li>
</ul>
</li>
<li><p><u><strong>系统总线：地址总线 AB，控制总线 CB 和双向数据总线 DB。</strong></u></p>
<ul>
<li>数据总线（Data Bus―DB）双向、三态：数据总线的根数决定了一次可以传递二进制数的<strong>位数</strong>。 </li>
<li>地址总线（Address Bus―AB）单向、三态：地址总线的位数决定了<strong>可以直接访问的存储单元(或 I&#x2F;O 口)的最大可能数 量（即容量）</strong>。 </li>
<li>控制总线（Control Bus―CB）：控制总线用来<strong>传输控制信号</strong>，数据总线和每个元件的数据线相连，为了使 CPU 能够和 其中一个元件正确通信，必须使用三态逻辑元件（特别针对输入元件）。</li>
</ul>
</li>
</ul>
<h2 id="题"><a href="#题" class="headerlink" title="题"></a>题</h2><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/1_1.jpg" class title="This is an image"> 

<h1 id="单片机硬件结构"><a href="#单片机硬件结构" class="headerlink" title="单片机硬件结构"></a>单片机硬件结构</h1><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>分为运算器和控制器</p>
<ul>
<li><p>控制器：依次取出ROM中存储单元的指令</p>
<ul>
<li>程序计数器：PC，16位，指向下一条指令的<strong>地址</strong>，复位后为0000H</li>
<li>指令寄存器</li>
<li>指令译码器</li>
<li>定时控制电路</li>
</ul>
</li>
<li><p>运算器ALU：对数据进行算术、逻辑运算</p>
<ul>
<li>算术逻辑运算部件ALU，负责运算，结果传回ACC，结果的状态传回PSW</li>
<li>累加器ACC</li>
<li><strong>程序状态寄存器PSW</strong></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">位</th>
<th align="center">7</th>
<th align="center">6</th>
<th align="center">5</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">位名</td>
<td align="center">Cy</td>
<td align="center">AC</td>
<td align="center">F0</td>
<td align="center">RS1</td>
<td align="center">RS0</td>
<td align="center">OV</td>
<td align="center">F1</td>
<td align="center">P</td>
</tr>
<tr>
<td align="center">作用</td>
<td align="center">进位&#x2F;借位</td>
<td align="center">辅助进位</td>
<td align="center">自定义</td>
<td align="center">寄存器选择</td>
<td align="center">寄存器选择</td>
<td align="center">溢出</td>
<td align="center">自定义</td>
<td align="center">奇偶效验</td>
</tr>
</tbody></table>
<ul>
<li>Cy：运算结果最高位有无进位&#x2F;错位</li>
<li>AC：运算结果低四位有无向高四位进位</li>
<li>F0、F1：用户自定义</li>
<li>RS1、RS0：一起决定当前寄存器组(00对应寄存器0组，依次增加)</li>
<li>OV：数据是否溢出</li>
<li>P：1的个数为奇&#x2F;偶</li>
</ul>
<h2 id="时钟电路"><a href="#时钟电路" class="headerlink" title="时钟电路"></a>时钟电路</h2><ul>
<li>XTAL1:片内振荡电路输入端</li>
<li>XTAL2：输出端</li>
</ul>
<p>当外部信号源为单片机提供时钟时，1接地，2接信号源</p>
<h2 id="EA"><a href="#EA" class="headerlink" title="EA"></a>EA</h2><p><strong>EA（反）</strong>为1时CPU从片内读取指令，为0时访问外部</p>
<h2 id="并行IO口"><a href="#并行IO口" class="headerlink" title="并行IO口"></a>并行IO口</h2><h3 id="P1"><a href="#P1" class="headerlink" title="P1"></a>P1</h3><p>通用输入、输出接口</p>
<img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/p1.jpg" class title="This is an image"> 

<h4 id="作输出时："><a href="#作输出时：" class="headerlink" title="作输出时："></a>作输出时：</h4><ul>
<li><p><strong>输出的数据通过内部总线送入锁存器保存</strong></p>
</li>
<li><p>判断数据的每一位。</p>
<p>为1时，Q&#x3D;1，Q（反）&#x3D;0，VT截止，Vcc向引脚输出高电平。</p>
</li>
</ul>
<p><strong>上拉电阻的作用</strong>：当VT截止时，使输出强制为1，若没有上拉电阻，输出可能由于噪音上下浮动。</p>
<h4 id="作输入时："><a href="#作输入时：" class="headerlink" title="作输入时："></a>作输入时：</h4><ul>
<li><strong>先向锁存器写1（准双向），使VT一直为截止状态。</strong>否则VT导通会拉低输入信号。</li>
<li>CPU执行读指令时，2导通，<strong>数据通过2直接进入</strong>内部总线，因此内部总线信号跟随引脚变化。</li>
</ul>
<h3 id="P2"><a href="#P2" class="headerlink" title="P2"></a>P2</h3><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/p2.jpg" class title="This is an image"> 

<p>有两种用途，准双向IO和高8位地址总线</p>
<p>当用作IO时，控制信号使开关接左侧，Q输出1使VT截止。</p>
<h3 id="P3"><a href="#P3" class="headerlink" title="P3"></a>P3</h3><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/p3.jpg" class title="This is an image"> 

<p><strong>用户可自行操作第二功能实现相关功能，P3默认为准双向IO</strong></p>
<p>第二功能包括：串口收发、外部中断、定时器输出等</p>
<h3 id="P0"><a href="#P0" class="headerlink" title="P0"></a>P0</h3><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/p0.jpg" class title="This is an image"> 

<p>可作为准双向IO，<strong>IO时必须外接上拉电阻</strong>。第二功能时提供外部存储地址低8位<strong>和P2组成16位地址</strong>，之后用作数据总线（此时锁存器会保存低八位地址）。</p>
<p>P0具有高阻态</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>四个IO均为准双向，<strong>在用作输入时都应向锁存器写“1”</strong></li>
<li>除P1外，其余端口都有第二功能：<ul>
<li>P0：低八位地址和数据总线</li>
<li>P2：高八位地址</li>
<li>P3：自定义功能</li>
</ul>
</li>
<li><strong>P0作为通用IO时需要外接上拉电阻！</strong></li>
<li><strong><u>P0、P2作地址时剩下引脚不能作为IO使用；但是P3各个口独立，未用作第二功能的可以作为IO使用</u></strong></li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>51单片机存储器<strong>物理</strong>上分为四个空间：</p>
<ul>
<li>片内<strong>程序</strong>存储器</li>
<li>片外<strong>程序</strong>存储器</li>
<li>片内<strong>数据</strong>存储器</li>
<li>片外<strong>数据</strong>存储器</li>
</ul>
<p>从用户使用的逻辑上分为三个区域：</p>
<ul>
<li>片内外统一编址的程序存储器	0000H-FFFFH(64KB)</li>
<li>片内数据存储	00-FFH 128B </li>
<li>片外数据存储    0000H-FFFFH</li>
</ul>
<h3 id="程序存储器"><a href="#程序存储器" class="headerlink" title="程序存储器"></a>程序存储器</h3><p>程序存储器由ROM和EPROM构成，掉电后数据不丢失</p>
<p>用于存放程序和程序运行时所需的常数。<strong>51片内有4K ROM，但地址线为16位，因此做多可以扩展到64KB</strong>。当PC值超过内部ROM容量时会自动转向外部寻址。\EA&#x3D;1时为寻址内部ROM。</p>
<p>MOVC指令用于访问程序存储器。</p>
<h3 id="数据存储器"><a href="#数据存储器" class="headerlink" title="数据存储器"></a>数据存储器</h3><p>数据存储器由RAM和专用寄存器组成，掉电后数据丢失</p>
<p>用于存放程序运算的中间结果、标志位、数据缓冲等。51片内有128+128B的数据存储器，可扩充至64KB</p>
<p>内部数据存储器分为低128B和高128B</p>
<img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/ram.jpg" class title="This is an image"> 

<h4 id="低128B：RAM区"><a href="#低128B：RAM区" class="headerlink" title="低128B：RAM区"></a>低128B：RAM区</h4><ul>
<li><p><strong>通用寄存器区</strong>，供用户使用，用于临时存放8位数据</p>
<p>通过修改程序状态寄存器PSW中的RS1和RS0实现选择，00H-1FH 128位</p>
</li>
<li><p><strong>位寻址区</strong>，提供地址读写数据 </p>
<p>RAM中的20H-2FH，128位</p>
</li>
<li><p><strong>数据缓存区</strong></p>
</li>
</ul>
<h4 id="特殊功能寄存器SFR"><a href="#特殊功能寄存器SFR" class="headerlink" title="特殊功能寄存器SFR"></a>特殊功能寄存器SFR</h4><p>包括51中有特殊功能的寄存器，如ACC、PSW、P0-P3等</p>
<p><u><strong>不包括PC</strong></u></p>
<h2 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h2><h3 id="时钟周期（振荡周期）"><a href="#时钟周期（振荡周期）" class="headerlink" title="时钟周期（振荡周期）"></a>时钟周期（振荡周期）</h3><p>也叫振荡周期，<strong>为振荡器频率的倒数</strong>，是时序中的<strong>最小单位</strong></p>
<h3 id="状态周期"><a href="#状态周期" class="headerlink" title="状态周期"></a>状态周期</h3><p>两个振荡周期，一个完成运算，一个完成传送</p>
<h3 id="机器周期"><a href="#机器周期" class="headerlink" title="机器周期"></a>机器周期</h3><p>执行一条指令的一个阶段的时间。<strong>是单片机的基本操作周期</strong>。1个机器周期&#x3D;6个状态周期&#x3D;12个振荡周期</p>
<h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><p>执行一条指令的周期，通常含有1~4个机器周期。</p>
<p>51单片机分为单周期指令、双周期指令、四周期指令，分别对应n个机器周期。<strong>只有乘法和除法是四周砌指令。</strong></p>
<p>因此，晶振周期为12MHz时：</p>
<ul>
<li>振荡周期&#x3D;1&#x2F;12us</li>
<li>机器周期&#x3D;1us</li>
<li>指令周期：1、2、4us</li>
</ul>
<h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><h3 id="复位方式"><a href="#复位方式" class="headerlink" title="复位方式"></a>复位方式</h3><ul>
<li>上电复位</li>
<li>按键复位</li>
</ul>
<h3 id="复位后寄存器状态"><a href="#复位后寄存器状态" class="headerlink" title="复位后寄存器状态"></a>复位后寄存器状态</h3><ul>
<li><strong>P0~P3：0FFH（全高电平）</strong></li>
<li><strong>PC：0000H</strong></li>
<li><strong>SP：07H</strong></li>
<li><strong>PSW:  00H</strong></li>
</ul>
<p><strong>51单片机在电复位时RAM保持不变</strong></p>
<h3 id="低功耗模式"><a href="#低功耗模式" class="headerlink" title="低功耗模式"></a>低功耗模式</h3><ul>
<li>休眠模式：只有外部中断工作</li>
<li>空闲模式（待机）：只有CPU停止工作</li>
</ul>
<h2 id="错题"><a href="#错题" class="headerlink" title="错题"></a>错题</h2><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/1.jpg" class title="This is an image"> 



<img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/2.jpg" class title="This is an image"> 



<img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/7.jpg" class title="This is an image"> 

<p><strong><u>由于RAM片内外访问指令一个是MOV一个是MOVX，因此其地址可以重叠。外部地址总线16位对应64KB，而内部地址可以与其重合，因此RAM最大总量是大于64KB的</u></strong></p>
<h1 id="51指令系统"><a href="#51指令系统" class="headerlink" title="51指令系统"></a>51指令系统</h1><p><a href="https://dhkkk.gitee.io/2022/10/14/51%E5%8D%95%E7%89%87%E6%9C%BA%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/">51单片机汇编指令查询 | 小董的BLOG (gitee.io)</a></p>
<h2 id="题-1"><a href="#题-1" class="headerlink" title="题"></a>题</h2><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/3.jpg" class title="This is an image"> 



<img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/4.jpg" class title="This is an image"> 

<p><strong>一般只有A能参与这些逻辑运算</strong></p>
<img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/5.jpg" class title="This is an image"> 

<p><strong>经典</strong></p>
<img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/6.jpg" class title="This is an image"> 

<p><strong>规定</strong></p>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><h2 id="中断请求标志寄存器"><a href="#中断请求标志寄存器" class="headerlink" title="中断请求标志寄存器"></a>中断请求标志寄存器</h2><h3 id="定时器-x2F-计数器控制寄存器TCON"><a href="#定时器-x2F-计数器控制寄存器TCON" class="headerlink" title="定时器&#x2F;计数器控制寄存器TCON"></a>定时器&#x2F;计数器控制寄存器TCON</h3><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/tcon.jpg" class title="This is an image"> 

<ul>
<li>IT 0&#x2F;1:外部中断触发方式，0低电平触发，1下降沿触发</li>
<li>IE 0&#x2F;1:中断请求标志位，触发中断后硬件自动清零</li>
<li>TF 0&#x2F;1:定时器&#x2F;计数器溢出中断标志位，触发中断后自动清零</li>
<li>TR 0&#x2F;1:启停定时器</li>
</ul>
<p>一般就只需设置IT和TR</p>
<h3 id="串行口控制寄存器SCON"><a href="#串行口控制寄存器SCON" class="headerlink" title="串行口控制寄存器SCON"></a>串行口控制寄存器SCON</h3><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/scon.jpg" class title="This is an image"> 

<ul>
<li>TI:发送中断标志位，每发送完一帧数据后硬件会对其置1，<strong>需用户自行软件清零！</strong></li>
<li>RI:接收中断标志位，规则同上。</li>
</ul>
<h3 id="中断允许寄存器IE"><a href="#中断允许寄存器IE" class="headerlink" title="中断允许寄存器IE"></a>中断允许寄存器IE</h3><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/ie.jpg" class title="This is an image"> 

<ul>
<li>EA：总中断允许位</li>
<li>ES：串口中断允许位</li>
<li>ET：定时器中断允许位</li>
<li>EX：外部中断允许位</li>
</ul>
<p>都是置1允许</p>
<p>若要使用某个中断，必须先开启中断允许位，复位后清零</p>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>I开头为TCON寄存器，控制<strong>定时器</strong>中断触发的方法和标志位</li>
<li>RI和TI为SCON寄存器，控制<strong>串口</strong>相关</li>
<li>E开头为中断允许寄存器IE</li>
</ul>
<h2 id="中断优先级"><a href="#中断优先级" class="headerlink" title="中断优先级"></a>中断优先级</h2><p>由中断优先级寄存器IP控制</p>
<img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/ip.jpg" class title="This is an image"> 

<ul>
<li>PX:外部中断优先级设置</li>
<li>PT:定时器中断优先级设置</li>
<li>PS:串口中断优先级设置</li>
</ul>
<h2 id="中断响应过程"><a href="#中断响应过程" class="headerlink" title="中断响应过程"></a>中断响应过程</h2><h3 id="中断请求"><a href="#中断请求" class="headerlink" title="中断请求"></a>中断请求</h3><p>硬件完成，请求完成后对应标志位置1</p>
<h3 id="中断查询"><a href="#中断查询" class="headerlink" title="中断查询"></a>中断查询</h3><p>CPU检测TCON和SCON中各标志位状态，确定是哪个中断</p>
<h3 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h3><p>响应条件：</p>
<ul>
<li><strong>EA使能</strong></li>
<li><strong>该中断允许位也使能</strong></li>
<li>有中断请求</li>
<li>无同级或高级中断正在运行</li>
</ul>
<h3 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h3><p>中断服务程序</p>
<h3 id="中断返回"><a href="#中断返回" class="headerlink" title="中断返回"></a>中断返回</h3><p>复位置位的标志位，重新执行原程序（PC被弹出堆栈）</p>
<h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><ul>
<li>打开对应中断允许位</li>
<li>设置触发方式</li>
<li>开启总中断允许</li>
<li>编写服务函数</li>
</ul>
<h2 id="题-2"><a href="#题-2" class="headerlink" title="题"></a>题</h2><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/zd1.jpg" class title="This is an image"> 

<h1 id="定时器-x2F-计数器"><a href="#定时器-x2F-计数器" class="headerlink" title="定时器&#x2F;计数器"></a>定时器&#x2F;计数器</h1><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>T1、T2分别由两个8位特殊功能寄存器TH和TL组成。当它对外部事件进行计数时，作为计数器使用；当对内部固<strong>定频率的机器周期进行计数时</strong>，便可以达到定时的目的。</p>
<h2 id="两种工作模式"><a href="#两种工作模式" class="headerlink" title="两种工作模式"></a>两种工作模式</h2><ul>
<li><p>计数器工作模式</p>
<p>对外部事件进行计数，计数脉冲来自P3中的对应引脚。</p>
<p>下降沿触发</p>
<p><strong>最高频率为振荡频率的1&#x2F;24，因为识别下降沿需要2个机器周期，即24个振荡周期</strong></p>
</li>
<li><p>定时器工作模式</p>
<p>计数脉冲为内部时钟脉冲，也就是每个机器周期+1，<strong>因此计数频率为振荡频率的1&#x2F;12</strong>，得到的时间：定时器计数值*机器周期时间</p>
</li>
</ul>
<p>当设置好定时器后，定时器就将独立工作，不再占用CPU，只有溢出时才会申请中断。</p>
<h2 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h2><h3 id="工作模式寄存器TMOD"><a href="#工作模式寄存器TMOD" class="headerlink" title="工作模式寄存器TMOD"></a>工作模式寄存器TMOD</h3><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/tmod.jpg" class title="This is an image"> 

<ul>
<li>GATE：门控位，使用外部中断引脚的高电平来启动定时器（前提是该定时器已被置位运行）</li>
<li>C&#x2F;(&#x2F;T)：1为计数器模式，0为定时器模式</li>
<li>M1，M0：同时控制定时器的工作模式，同PSW中的RS用法</li>
</ul>
<h3 id="控制寄存器TCON"><a href="#控制寄存器TCON" class="headerlink" title="控制寄存器TCON"></a>控制寄存器TCON</h3><p>上一节中断中已讲过，控制定时器的开启。</p>
<h2 id="定时器的工作方式"><a href="#定时器的工作方式" class="headerlink" title="定时器的工作方式"></a>定时器的工作方式</h2><h3 id="方式0"><a href="#方式0" class="headerlink" title="方式0"></a>方式0</h3><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/mod0.jpg" class title="This is an image"> 

<p>易得其定时时间为：(2^13 - 初值)*机器周期</p>
<p>计算后的值低5位赋给TL，高8位赋给TH</p>
<h3 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h3><p>16位计数器，其余与方式0一样。</p>
<h3 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h3><p>方式2为8位定时器</p>
<ul>
<li>TL用作定时，TH用于保存初值。当TL溢出后，中断标志置位，<strong>同时自动将TH中的值重新装载进TL</strong>，无需用户再手动重新装入初值。</li>
</ul>
<p>更加精准，但计时范围小。</p>
<h3 id="方式3"><a href="#方式3" class="headerlink" title="方式3"></a>方式3</h3><ul>
<li>只有T0能被设置为模式3，T1若为模式3，则停止计数，保存原样。</li>
</ul>
<h4 id="T0为模式3时"><a href="#T0为模式3时" class="headerlink" title="T0为模式3时"></a>T0为模式3时</h4><p>TH和TL分别单独工作</p>
<ul>
<li>TL：使用T0的状态控制位，同方式2，但是溢出后需用户手动装入初值</li>
<li>TH：<strong>被固定为一个内部定时器</strong>，受T1控制位的TR1控制启停，同上占用T1的中断请求TF1</li>
</ul>
<h4 id="T0为模式3时，T1的设置"><a href="#T0为模式3时，T1的设置" class="headerlink" title="T0为模式3时，T1的设置"></a>T0为模式3时，T1的设置</h4><p>T1仍可设置为方式0、1、2，但由于中断被占用，只能将输出送往串口</p>
<h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><ul>
<li><p>设置模式TMOD</p>
</li>
<li><p>赋初值TL、TH</p>
</li>
<li><p>开启中断ET、EA</p>
</li>
<li><p>开启定时器TR</p>
</li>
</ul>
<h1 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h1><p>串行通信：数据的各位在同一根数据线上逐位发送、接收。</p>
<p>串行通信按同步方式分为异步通信和同步通信</p>
<h2 id="同步通信"><a href="#同步通信" class="headerlink" title="同步通信"></a>同步通信</h2><p>数据传输速率高，但是要求发送时钟和接收时钟严格同步</p>
<h2 id="异步通信"><a href="#异步通信" class="headerlink" title="异步通信"></a>异步通信</h2><p>数据组成数据帧方式，收、发端相互独立、互不同步，只需规定收发数据的帧格式即可相互识别。</p>
<h3 id="数据帧格式"><a href="#数据帧格式" class="headerlink" title="数据帧格式"></a>数据帧格式</h3><ul>
<li>起始位：低电平有效</li>
<li>数据位：5~8位</li>
<li>奇偶校验位</li>
<li>停止位：高电平有效</li>
</ul>
<h3 id="波特率"><a href="#波特率" class="headerlink" title="波特率"></a>波特率</h3><p>每秒传输二进制数码的位数，每位的传输时间为1&#x2F;波特率</p>
<h2 id="51单片机的串口通信"><a href="#51单片机的串口通信" class="headerlink" title="51单片机的串口通信"></a>51单片机的串口通信</h2><p>51内部有一个可编程全双工串口。</p>
<h3 id="串口相关寄存器"><a href="#串口相关寄存器" class="headerlink" title="串口相关寄存器"></a>串口相关寄存器</h3><h4 id="串行数据缓冲器SBUF"><a href="#串行数据缓冲器SBUF" class="headerlink" title="串行数据缓冲器SBUF"></a>串行数据缓冲器SBUF</h4><p>包括发送和接收寄存器，但在逻辑上只有一个SBUF，在使用时可用作发送和接收。（物理上有两个完全独立的SBUF，但是他们地址是一样的）</p>
<h4 id="串行控制寄存器SCON"><a href="#串行控制寄存器SCON" class="headerlink" title="串行控制寄存器SCON"></a>串行控制寄存器SCON</h4><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/scon2.jpg" class title="This is an image"> 

<ul>
<li><p>SM0、1工作方式选择位</p>
<img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/smod.jpg" class title="This is an image"> 
</li>
<li><p>SM2:多机通信控制位</p>
</li>
<li><p>REN：<strong>允许接收控制位</strong></p>
</li>
<li><p>TB8：方式2、3的<strong>发送</strong>第九位</p>
</li>
<li><p>RB8：方式2、3的接收第九位</p>
</li>
</ul>
<h4 id="电源控制寄存器PCON"><a href="#电源控制寄存器PCON" class="headerlink" title="电源控制寄存器PCON"></a>电源控制寄存器PCON</h4><p>其中第七位SMOD为1波特率加倍</p>
<h2 id="基础流程"><a href="#基础流程" class="headerlink" title="基础流程"></a>基础流程</h2><ul>
<li><strong><u>配置SCON</u></strong></li>
<li><strong><u>数据送往SBUF</u></strong></li>
<li><strong><u>发送、接收数据</u></strong></li>
<li><strong><u>中断置位</u></strong></li>
</ul>
<h2 id="题-3"><a href="#题-3" class="headerlink" title="题"></a>题</h2><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/8.jpg" class title="This is an image"> 

<h1 id="常用的一些寄存器"><a href="#常用的一些寄存器" class="headerlink" title="常用的一些寄存器"></a>常用的一些寄存器</h1><h2 id="片内特殊功能寄存器SFR"><a href="#片内特殊功能寄存器SFR" class="headerlink" title="片内特殊功能寄存器SFR"></a>片内特殊功能寄存器SFR</h2><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/sfr.jpg" class title="This is an image"> 

<p>大多数特殊寄存器都在这里，<strong>但不包括PC！！</strong></p>
<h2 id="程序状态寄存器PSW"><a href="#程序状态寄存器PSW" class="headerlink" title="程序状态寄存器PSW"></a>程序状态寄存器PSW</h2><p>用于表示运算结果的状态</p>
<table>
<thead>
<tr>
<th align="center">位</th>
<th align="center">7</th>
<th align="center">6</th>
<th align="center">5</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">位名</td>
<td align="center">Cy</td>
<td align="center">AC</td>
<td align="center">F0</td>
<td align="center">RS1</td>
<td align="center">RS0</td>
<td align="center">OV</td>
<td align="center">F1</td>
<td align="center">P</td>
</tr>
<tr>
<td align="center">作用</td>
<td align="center">进位&#x2F;借位</td>
<td align="center">辅助进位</td>
<td align="center">自定义</td>
<td align="center">寄存器选择</td>
<td align="center">寄存器选择</td>
<td align="center">溢出</td>
<td align="center">自定义</td>
<td align="center">奇偶效验</td>
</tr>
</tbody></table>
<h2 id="中断允许寄存器IE（管理中断允许）E开头"><a href="#中断允许寄存器IE（管理中断允许）E开头" class="headerlink" title="中断允许寄存器IE（管理中断允许）E开头"></a>中断允许寄存器IE（管理中断允许）E开头</h2><p>用于管理所有中断</p>
<img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/ie.jpg" class title="This is an image"> 

<h2 id="中断优先级寄存器IP（管理中断优先级）P开头"><a href="#中断优先级寄存器IP（管理中断优先级）P开头" class="headerlink" title="中断优先级寄存器IP（管理中断优先级）P开头"></a>中断优先级寄存器IP（管理中断优先级）P开头</h2><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/ip.jpg" class title="This is an image"> 

<p>外部中断2位，定时器2位，串口1位，共5位</p>
<h2 id="定时器工作模式寄存器TMOD（管理定时器工作模式）"><a href="#定时器工作模式寄存器TMOD（管理定时器工作模式）" class="headerlink" title="定时器工作模式寄存器TMOD（管理定时器工作模式）"></a>定时器工作模式寄存器TMOD（管理定时器工作模式）</h2><p>8位，下4位控制T0，上4位控制T1</p>
<h2 id="定时器中断控制寄存器TCON（管理定时器启动、定时器和外部中断的中断标志位）"><a href="#定时器中断控制寄存器TCON（管理定时器启动、定时器和外部中断的中断标志位）" class="headerlink" title="定时器中断控制寄存器TCON（管理定时器启动、定时器和外部中断的中断标志位）"></a>定时器中断控制寄存器TCON（管理定时器启动、定时器和外部中断的中断标志位）</h2><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/tcon.jpg" class title="This is an image"> 

<p>其中IT和IE为控制外部中断的位</p>
<p>需要操作的位只有IT和TR，其他都会自动复位</p>
<h2 id="串行控制寄存器SCON（管理串口中断位和串口配置）"><a href="#串行控制寄存器SCON（管理串口中断位和串口配置）" class="headerlink" title="串行控制寄存器SCON（管理串口中断位和串口配置）"></a>串行控制寄存器SCON（管理串口中断位和串口配置）</h2><img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/scon2.jpg" class title="This is an image"> 

<h2 id="电源控制寄存器PCON（波特率翻倍）"><a href="#电源控制寄存器PCON（波特率翻倍）" class="headerlink" title="电源控制寄存器PCON（波特率翻倍）"></a>电源控制寄存器PCON（波特率翻倍）</h2><p>仅串口中需使用其第七位翻倍波特率</p>
<h1 id="题-4"><a href="#题-4" class="headerlink" title="题"></a>题</h1><ul>
<li><p>堆栈的作用：保护现场和断点</p>
</li>
<li><p>JB为判断当前位，为1则跳转</p>
</li>
</ul>
<img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/wxz.jpg" class title="This is an image"> 

<p>如果是A，就是直接寻址，C则为位寻址，位寻址只能操作位</p>
<img src="/images/loading.png" data-original="/2022/11/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%8D%E4%B9%A0/ct.jpg" class title="This is an image"> 

<ul>
<li>C&#x2F;(&#x2F;T)：<strong>0为定时器模式</strong></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 嵌入式学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据结构_链表]]></title>
      <url>/2022/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h1 id="1-链表的概念"><a href="#1-链表的概念" class="headerlink" title="1.链表的概念"></a>1.链表的概念</h1><p>通过多个<strong>节点</strong>将多个数据元素组成一个链表。</p>
<ul>
<li>节点：数据元素的存储映像， 由<strong>数据域和指针域</strong>两部分组成。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>数据元素的个数可以自由扩充</li>
<li>插入、删除等操作不必移动数据，只需修改链接指针，修改效率较高</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>存储密度小</li>
<li>存取效率不高，必须采用顺序存取，即存取数据元素时，只能按链表的顺序进行访问（顺藤摸瓜）</li>
</ul>
<h1 id="2-创建一个单向列表"><a href="#2-创建一个单向列表" class="headerlink" title="2.创建一个单向列表"></a>2.创建一个单向列表</h1><p>单向列表即每个节点之间的联系是单向的，仅通过一个指针链接。</p>
<p>创建列表有两种方法：前插法和后插法。</p>
<h2 id="前插法"><a href="#前插法" class="headerlink" title="前插法"></a>前插法</h2><p>新的节点链接到上一节点的开头</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> num; 	<span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">last</span>;</span>	<span class="comment">//指针域</span></span><br><span class="line">&#125;test;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setlist</span><span class="params">(test* linkhead, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">   test *tmp=(test*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(test));<span class="comment">//分配动态内存，防止生成野指针</span></span><br><span class="line">   tmp-&gt;num=data;</span><br><span class="line">   tmp-&gt;last=linkhead-&gt;last;</span><br><span class="line">   linkhead-&gt;last=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> a[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   test* head=(test*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(test));</span><br><span class="line">   head-&gt;last=<span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)</span><br><span class="line">   &#123;</span><br><span class="line">      setlist(head,a[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   test* p= head-&gt;last;</span><br><span class="line">   <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p-&gt;num);</span><br><span class="line">      p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前插法创建链表的步骤为（以创建两个节点为例）:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setlist</span><span class="params">(test* linkhead, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//开辟一个新节点</span></span><br><span class="line">   test *tmp=(test*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(test));</span><br><span class="line">   <span class="comment">//写入需要的数据</span></span><br><span class="line">   tmp-&gt;num=data;</span><br><span class="line">   <span class="comment">//将节点的指针域指向linkhead的指针域</span></span><br><span class="line">   tmp-&gt;last=linkhead-&gt;last;</span><br><span class="line">   <span class="comment">//将linkhead的指针域指向新节点首地址</span></span><br><span class="line">   linkhead-&gt;last=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，创建第一个节点时，该节点的指针域先指向NULL后，linkhead指针域再指向该节点首地址。</p>
<p>当刚创建第二个节点时，情况如下：</p>
<img src="/images/loading.png" data-original="/2022/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/1.jpg" class title="This is an image"> 

<p>当执行<code>tmp-&gt;last=linkhead-&gt;last;</code>时，由于linkhead的指针域此时指向tmp(1)（这里的1指第一块节点的内存空间）的首地址，<strong>所以tmp(2)的指针域会通过linkhead直接也指向tmp(1)的首地址:</strong></p>
<img src="/images/loading.png" data-original="/2022/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/2.jpg" class title="This is an image"> 

<p>这样之后，两个节点就通过指针链接在了一起，且tmp(2)在tmp(1)之前。</p>
<p>由此可以看出，前插法的原理就是以linkhead为媒介来链接节点，<strong>linkhead本身是不存储数据的</strong></p>
<p>最后，执行<code>linkhead-&gt;last=tmp;</code>，<strong>将linkhead指针域指向第二个节点首地址，以供第三个节点的指针域找到第二个节点。</strong></p>
<img src="/images/loading.png" data-original="/2022/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/3.jpg" class title="This is an image"> 

<p>以此类推，假如现在创建了4个节点，那情况就应该像这样：</p>
<img src="/images/loading.png" data-original="/2022/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/4.jpg" class title="This is an image"> 

<p>在例程中，由于前插法得到的链表顺序为最后输入的数据开始，所以最后打印的结果为3 2 1</p>
<h2 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h2><p>相对于前插法，尾插法使用起来逻辑会更加清晰，因为其链接顺序是在每一个节点后，所以尾插法要更容易理解一些。</p>
<p>在<a href="https://dhkkk.gitee.io/2022/08/01/C-%E7%BB%93%E6%9E%84%E4%BD%93/">结构体复习 | 小董的BLOG (gitee.io)</a>中讲到的列表就是使用的尾插法，核心代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">30</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;test;</span><br><span class="line"></span><br><span class="line">test *<span class="title function_">creat</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	test *linkhead,*linkend,*tmp;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp=(test*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(test));<span class="comment">//分配动态内存</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %s&quot;</span>,&amp;tmp-&gt;num,tmp-&gt;name);</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			linkhead=tmp;<span class="comment">//第一次先将当前节点赋给链头链尾</span></span><br><span class="line">			linkend=tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//若不是第一次，先将当前节点存入上一个节点的next中，再将linkend更新为当前节点以供下一次访问</span></span><br><span class="line">		&#123;                                                                <span class="comment">//当前节点的next</span></span><br><span class="line">			linkend-&gt;next=tmp;<span class="comment">//通过linkend直接指向内存中的一个struct list变量使其指向tmp的内存</span></span><br><span class="line">			linkend=tmp;</span><br><span class="line">         <span class="comment">//以第二个节点为例，先将第linkend（也就是tmp(1)）的指针域指向二个节点首地址</span></span><br><span class="line">         <span class="comment">//再将linkend指向tmp(2)，以供后面的节点重复23、24行的操作</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	linkend-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> linkhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果说前插法是通过linkhead为媒介进行链接，那尾插法就是通过linkend为媒介链接各节点。</p>
<h1 id="3-双向链表的创建"><a href="#3-双向链表的创建" class="headerlink" title="3.双向链表的创建"></a>3.双向链表的创建</h1><p>同样分为使用前插法和后插法，但是尾插法会简单很多，所以先讲一下尾插法</p>
<h2 id="尾插法创建双向链表"><a href="#尾插法创建双向链表" class="headerlink" title="尾插法创建双向链表"></a>尾插法创建双向链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">30</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">last</span>;</span>	<span class="comment">//存放上一节点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">next</span>;</span>	<span class="comment">//存放下一节点</span></span><br><span class="line">&#125;test;</span><br><span class="line"></span><br><span class="line">test *<span class="title function_">creat</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	test *linkhead,*linkend,*tmp;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp=(test*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(test)); </span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %s&quot;</span>,&amp;tmp-&gt;num,tmp-&gt;name);</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			linkhead=tmp;</span><br><span class="line">			linkend=tmp;</span><br><span class="line">			linkhead-&gt;last=<span class="literal">NULL</span>; <span class="comment">//因为链头没有上一节点，固其last指针域指向NULL</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			tmp-&gt;last=linkend;	<span class="comment">//把上一节点地址存入本节点的last指针中</span></span><br><span class="line">			linkend-&gt;next=tmp;</span><br><span class="line">			linkend=tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	linkend-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> linkhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尾插法由于其创建链表的方式为顺序创建，因此只需在原有的基础上添加存放上一节点的指针就行了</p>
<p>使用双向链表会增加内存，但是就可以通过任意节点找到其他节点了。</p>
<h2 id="使用前插法创建双向链表"><a href="#使用前插法创建双向链表" class="headerlink" title="使用前插法创建双向链表"></a>使用前插法创建双向链表</h2><p>使用前插法的话会稍微麻烦一些，而且理解起来也会有点绕，感觉用尾插法好一些。</p>
<p>（这是我自己写的方法，感觉有点绕）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> num; 	<span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">last</span>;</span>	</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">next</span>;</span>	</span><br><span class="line">&#125;test;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> time=<span class="number">1</span>;</span><br><span class="line">test* <span class="title function_">InsertList</span><span class="params">(test *head,<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">   test *tmp,*end;</span><br><span class="line">   tmp=(test *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (test));</span><br><span class="line">	<span class="keyword">if</span>(time==<span class="number">1</span>) <span class="comment">//建立第一个节点时将该节点作为链尾</span></span><br><span class="line">	&#123;</span><br><span class="line">		tmp-&gt;num=val;</span><br><span class="line">		tmp-&gt;last=head-&gt;last;</span><br><span class="line">		head-&gt;last=tmp;	</span><br><span class="line">		end=tmp;	<span class="comment">//end作为链尾将一直指向第一个建立的节点，后续不再改变end</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		tmp-&gt;num=val;</span><br><span class="line">		tmp-&gt;last=head-&gt;last;</span><br><span class="line">		head-&gt;last-&gt;next=tmp;	<span class="comment">//将上一个节点的next指针指向当前节点（有点套娃的感觉）</span></span><br><span class="line">		head-&gt;last=tmp;</span><br><span class="line">		tmp-&gt;next=<span class="literal">NULL</span>; <span class="comment">//每个节点的next先清零，为了让最后一个节点指向null</span></span><br><span class="line">	&#125;</span><br><span class="line">	++time;</span><br><span class="line">	<span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> a[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   test *linkhead, *linkend;</span><br><span class="line">   linkhead=(test *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (test));</span><br><span class="line">   linkhead-&gt;last=<span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">2</span>;i&gt;=<span class="number">0</span>;--i) <span class="comment">//由于是前插法，所以输入倒序输入</span></span><br><span class="line">   &#123;</span><br><span class="line">      linkend=InsertList(linkhead,a[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   test *p1,*p2;</span><br><span class="line">   p1=linkhead-&gt;last;</span><br><span class="line">   p2=linkend;</span><br><span class="line">   <span class="keyword">while</span>(p1!=<span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p1-&gt;num);</span><br><span class="line">      p1=p1-&gt;last;      </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span>(p2!=<span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p2-&gt;num);</span><br><span class="line">      p2=p2-&gt;next;      </span><br><span class="line">   &#125;</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/images/loading.png" data-original="/2022/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/5.jpg" class title="This is an image"> 

<p>在写这个双向链表时我遇见了个问题：对于linkend变量，我在主函数中定义后，像通过像linkhead一样的方式对linkend进行改变，但是始终无法实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertList</span><span class="params">(test *head,test *end;<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">   test *tmp,*end;</span><br><span class="line">   tmp=(test *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (test));</span><br><span class="line">	<span class="keyword">if</span>(time==<span class="number">1</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		tmp-&gt;num=val;</span><br><span class="line">		tmp-&gt;last=head-&gt;last;</span><br><span class="line">		head-&gt;last=tmp;	</span><br><span class="line">		end=tmp;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		tmp-&gt;num=val;</span><br><span class="line">		tmp-&gt;last=head-&gt;last;</span><br><span class="line">		head-&gt;last-&gt;next=tmp;	</span><br><span class="line">		head-&gt;last=tmp;</span><br><span class="line">		tmp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	++time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   test *linkhead, *linkend;</span><br><span class="line">   linkhead=(test *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (test));</span><br><span class="line">   linkhead-&gt;last=<span class="literal">NULL</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在主函数中没有对linkend分配内存，linkend将成为一个野指针，无法指向字符值常量。</p>
<p>但是如果分配了内存，由于linkhead是通过last成员来寻找链表，但是linkend却无法像linkhead一样正常实现功能，在经过整整一天的查找资料＆调试后，终于发现了原因：</p>
<p>当一个函数的形参是结构体指针时，<strong>这个形参本身的地址（不是所指向的地址）和实参的地址（也不是所指向的地址）是不同的</strong>。用例程举例：</p>
<ul>
<li><strong>&amp;linkend≠&amp;end，</strong>因此，<strong>在函数中改变形参end所指向的内容是完全不会影响实参linkend的，因为此时这两位可以理解成两个变量</strong></li>
</ul>
<p>那这时大家肯定会有个疑惑：那linkhead为什么就可以实现想要链表功能呢？</p>
<p>我们仔细看InsertList函数中的内容，你肯定会发现，函数中没有出现直接操作linkhead的操作，只有操作linkhead成员的操作，<strong>这里就引出了一个折磨了我半天的知识点</strong>：</p>
<ul>
<li><p>对于一个结构体指针形参，形参名的地址和实参名的地址是不能划等号的，<strong>但是形参成员的地址和实参成员的地址是完全相同的</strong>，用例程举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;linkend≠&amp;end</span><br><span class="line">linkend-&gt;next=end-&gt;next      (=是等于的意思，不是赋值的意思)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>其实这里的解释有点类似于在<a href="https://dhkkk.gitee.io/2022/08/01/C-%E7%BB%93%E6%9E%84%E4%BD%93/">结构体复习 | 小董的BLOG (gitee.io)</a>最后我对一重指针的解释：</p>
<ul>
<li><strong>假如有两个并列的指针指向同一个变量，你不能通过改变其中一个指针的指向来影响另一个指针的指向</strong></li>
</ul>
<p>那么这时又引出了一个问题，形参end和实参linkend指向哪里？</p>
<p>先说一下结论：<strong>linkend和end都指向linkend的第一个成员num的地址。</strong></p>
<p>也就是说，<strong>形参end和实参linkend作为两个不同的指针变量，他们指向了同一个地址</strong>（也许可以通过这一特性来写一个链表？但是我不想写了😋）</p>
<p>其实这个知识点符合我们对形参和指针变量的认知，所以这里比较重要的点其实是：</p>
<ul>
<li>不同于数组，<strong>结构体指针名地址≠第一个成员的地址，但指针名指向第一个成员的地址</strong>，可以理解为，结构体指针名指向一块内存，该内存是由若干个结构体成员组成的，这些成员的类型在定义结构体时确定。</li>
</ul>
<p>这也加深了我对<code>end=(LNode*)malloc(sizeof (LNode));</code>的理解，<strong>其实就是一个指针指向了一块内存，但是可以通过结构体的方式访问这块内存中的成员</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>当一个函数的参数是结构体指针时，操作这个函数的形参名不会影响实参，同时这个形参名的作用域只限于函数体；但是操作这个形参的任何成员等同于直接操作实参的对应成员，因为它们本身的地址是相同的</strong></li>
<li><strong>结构体指针名指向第一个成员的地址</strong></li>
</ul>
<p><strong>所以，结构体指针并不一定要指向一个明确的结构体，当他指向一块内存时，可以通过直接赋值结构体指针成员的方式操作这块内存</strong>（这块内存其实就是一个隐式的，没有具体名字的结构体）</p>
<p>一些感想：好久没有遇到过这么折磨的问题了，一开始完全没有头绪，网络上对于这方面的讲解也是几乎没有，还好找到了这篇博客启发了我[C语言理解指针作为形参作用](<a href="https://blog.csdn.net/qq_36733983/article/details/92184983?ops_request_misc=%7B%22request_id%22:%22166891705416800213084052%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&amp;request_id=166891705416800213084052&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-92184983-null-null.142%5Ev65%5Epc_rank_34_queryrelevant25,201%5Ev3%5Eadd_ask,213%5Ev2%5Et3_esquery_v3&amp;utm_term=C">https://blog.csdn.net/qq_36733983/article/details/92184983?ops_request_misc=%7B%22request%5Fid%22%3A%22166891705416800213084052%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=166891705416800213084052&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-92184983-null-null.142^v65^pc_rank_34_queryrelevant25,201^v3^add_ask,213^v2^t3_esquery_v3&amp;utm_term=C</a> 指针作为参数的作用域&amp;spm&#x3D;1018.2226.3001.4187)（博客中用的C++，但是原理是完全相同的）</p>
]]></content>
      
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[matlab]]></title>
      <url>/2022/11/09/matlab/</url>
      <content type="html"><![CDATA[<p><strong>内容大部分来自<a href="https://www.w3cschool.cn/matlab/matlab-5use28gb.html">MATLAB介绍_w3cschool</a>只是cv一下方便自己查阅</strong></p>
<h1 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h1><h2 id="常用运算符和特殊字符"><a href="#常用运算符和特殊字符" class="headerlink" title="常用运算符和特殊字符"></a>常用运算符和特殊字符</h2><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">目的</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>+</strong></td>
<td align="center">加；加法运算符</td>
</tr>
<tr>
<td align="center"><strong>-</strong></td>
<td align="center">减；减法运算符</td>
</tr>
<tr>
<td align="center">*****</td>
<td align="center">标量和矩阵乘法运算符</td>
</tr>
<tr>
<td align="center"><strong>.*</strong></td>
<td align="center">数组乘法运算符</td>
</tr>
<tr>
<td align="center"><strong>^</strong></td>
<td align="center">标量和矩阵求幂运算符</td>
</tr>
<tr>
<td align="center"><strong>.^</strong></td>
<td align="center">数组求幂运算符</td>
</tr>
<tr>
<td align="center">*<em>*</em></td>
<td align="center">矩阵左除</td>
</tr>
<tr>
<td align="center"><strong>&#x2F;</strong></td>
<td align="center">矩阵右除</td>
</tr>
<tr>
<td align="center">**.**</td>
<td align="center">阵列左除</td>
</tr>
<tr>
<td align="center"><strong>.&#x2F;</strong></td>
<td align="center">阵列右除</td>
</tr>
<tr>
<td align="center"><strong>:</strong></td>
<td align="center">向量生成；子阵提取</td>
</tr>
<tr>
<td align="center"><strong>( )</strong></td>
<td align="center">下标运算；参数定义</td>
</tr>
<tr>
<td align="center"><strong>[ ]</strong></td>
<td align="center">矩阵生成</td>
</tr>
<tr>
<td align="center"><strong>.</strong></td>
<td align="center">点乘运算，常与其他运算符联合使用</td>
</tr>
<tr>
<td align="center"><strong>…</strong></td>
<td align="center">续行标志；行连续运算符</td>
</tr>
<tr>
<td align="center"><strong>,</strong></td>
<td align="center">分行符（该行结果不显示）</td>
</tr>
<tr>
<td align="center"><strong>;</strong></td>
<td align="center"><strong>语句结束；分行符（该行结果显示）</strong></td>
</tr>
<tr>
<td align="center"><strong>%</strong></td>
<td align="center"><strong>注释标志</strong></td>
</tr>
<tr>
<td align="center"><strong>_</strong></td>
<td align="center">引用符号和转置运算符</td>
</tr>
<tr>
<td align="center"><strong>._</strong></td>
<td align="center">非共轭转置运算符</td>
</tr>
<tr>
<td align="center"><strong>&#x3D;</strong></td>
<td align="center">赋值运算符</td>
</tr>
</tbody></table>
<h2 id="特殊变量和常量"><a href="#特殊变量和常量" class="headerlink" title="特殊变量和常量"></a>特殊变量和常量</h2><table>
<thead>
<tr>
<th align="center">Name</th>
<th align="center">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>ans</strong></td>
<td align="center">默认的变量名，以应答最近依次操作运算结果</td>
</tr>
<tr>
<td align="center"><strong>eps</strong></td>
<td align="center">浮点数的相对误差</td>
</tr>
<tr>
<td align="center"><strong>i,j</strong></td>
<td align="center">虚数单位，定义为 i2 &#x3D; j2 &#x3D; -1</td>
</tr>
<tr>
<td align="center"><strong>Inf</strong></td>
<td align="center">代表无穷大</td>
</tr>
<tr>
<td align="center"><strong>NaN</strong></td>
<td align="center">代表不定值（不是数字）</td>
</tr>
<tr>
<td align="center"><strong>pi</strong></td>
<td align="center">圆周率</td>
</tr>
</tbody></table>
<h2 id="matlab命名变量"><a href="#matlab命名变量" class="headerlink" title="matlab命名变量"></a>matlab命名变量</h2><ul>
<li>名称为字母开头，后可接任意数量的下划线、字母、数字</li>
<li>区分大小写</li>
</ul>
<h2 id="保存工作进度"><a href="#保存工作进度" class="headerlink" title="保存工作进度"></a>保存工作进度</h2><p>MATLAB使用save命令保存工作区中的所有变量，然后作为一个扩展名为.mat的文件，在当前目录中。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save myfile</span><br><span class="line">load myfile</span><br></pre></td></tr></table></figure>

<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="显示已使用的变量"><a href="#显示已使用的变量" class="headerlink" title="显示已使用的变量"></a>显示已使用的变量</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">who</span><br><span class="line">whos</span><br><span class="line">clear <span class="comment">%删除所有（或指定）的变量%</span></span><br></pre></td></tr></table></figure>

<h2 id="延伸行"><a href="#延伸行" class="headerlink" title="延伸行"></a>延伸行</h2><ul>
<li>使用<code>...</code>将当前行延伸至下一行</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initial_velocity = <span class="number">0</span>;</span><br><span class="line">acceleration = <span class="number">9.8</span>;</span><br><span class="line">time = <span class="number">20</span>;</span><br><span class="line">final_velocity = initial_velocity ...</span><br><span class="line">    + acceleration * time</span><br></pre></td></tr></table></figure>

<h2 id="格式命令"><a href="#格式命令" class="headerlink" title="格式命令"></a>格式命令</h2><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">format short</td>
<td align="center">显示4位小数</td>
</tr>
<tr>
<td align="center">format long</td>
<td align="center">显示16位小数</td>
</tr>
<tr>
<td align="center">format bank</td>
<td align="center">显示两位小数</td>
</tr>
<tr>
<td align="center">format rat</td>
<td align="center">显示有理表达式</td>
</tr>
<tr>
<td align="center">format +</td>
<td align="center">正数</td>
</tr>
</tbody></table>
<ul>
<li>在命令后加<code>e</code>则会显示对应的指数形式</li>
</ul>
<h2 id="创建矩阵"><a href="#创建矩阵" class="headerlink" title="创建矩阵"></a>创建矩阵</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line">     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>同理可创建行、列向量。</p>
<h1 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h1><h2 id="向量、矩阵相关"><a href="#向量、矩阵相关" class="headerlink" title="向量、矩阵相关"></a>向量、矩阵相关</h2><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用&#x2F;目的</th>
</tr>
</thead>
<tbody><tr>
<td align="center">cat</td>
<td align="center">连接数组</td>
</tr>
<tr>
<td align="center">find</td>
<td align="center">查找非零元素的索引</td>
</tr>
<tr>
<td align="center">length</td>
<td align="center">计算元素数量</td>
</tr>
<tr>
<td align="center">linspace</td>
<td align="center">创建间隔向量</td>
</tr>
<tr>
<td align="center">logspace</td>
<td align="center">创建对数间隔向量</td>
</tr>
<tr>
<td align="center">max</td>
<td align="center">返回最大元素</td>
</tr>
<tr>
<td align="center">min</td>
<td align="center">返回最小元素</td>
</tr>
<tr>
<td align="center">prod</td>
<td align="center">计算数组元素的连乘积</td>
</tr>
<tr>
<td align="center">reshape</td>
<td align="center">重新调整矩阵的行数、列数、维数</td>
</tr>
<tr>
<td align="center">size</td>
<td align="center">计算数组大小</td>
</tr>
<tr>
<td align="center">sort</td>
<td align="center">排序每个列</td>
</tr>
<tr>
<td align="center">sum</td>
<td align="center">每列相加</td>
</tr>
<tr>
<td align="center">eye</td>
<td align="center">创建一个单位矩阵</td>
</tr>
<tr>
<td align="center">ones</td>
<td align="center">生成全1矩阵</td>
</tr>
<tr>
<td align="center">zeros</td>
<td align="center">生成零矩阵</td>
</tr>
<tr>
<td align="center">cross</td>
<td align="center">计算矩阵交叉乘积</td>
</tr>
<tr>
<td align="center">dot</td>
<td align="center">计算矩阵点积</td>
</tr>
<tr>
<td align="center">det</td>
<td align="center">计算数组的行列式</td>
</tr>
<tr>
<td align="center">inv</td>
<td align="center">计算矩阵的逆</td>
</tr>
<tr>
<td align="center">pinv</td>
<td align="center">计算矩阵的伪逆</td>
</tr>
<tr>
<td align="center">rank</td>
<td align="center">计算矩阵的秩</td>
</tr>
<tr>
<td align="center">rref</td>
<td align="center">将矩阵化成行最简形</td>
</tr>
<tr>
<td align="center">cell</td>
<td align="center">创建单元数组</td>
</tr>
<tr>
<td align="center">celldisp</td>
<td align="center">显示单元数组</td>
</tr>
<tr>
<td align="center">cellplot</td>
<td align="center">显示单元数组的图形表示</td>
</tr>
<tr>
<td align="center">num2cell</td>
<td align="center">将数值阵列转化为异质阵列</td>
</tr>
<tr>
<td align="center">deal</td>
<td align="center">匹配输入和输出列表</td>
</tr>
<tr>
<td align="center">iscell</td>
<td align="center">判断是否为元胞类型</td>
</tr>
</tbody></table>
<h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用&#x2F;目的</th>
</tr>
</thead>
<tbody><tr>
<td align="center">axis</td>
<td align="center">人工选择坐标轴尺寸</td>
</tr>
<tr>
<td align="center">fplot</td>
<td align="center">智能绘图功能</td>
</tr>
<tr>
<td align="center">grid</td>
<td align="center">显示网格线</td>
</tr>
<tr>
<td align="center">plot</td>
<td align="center">生成XY图</td>
</tr>
<tr>
<td align="center">print</td>
<td align="center">打印或绘图到文件</td>
</tr>
<tr>
<td align="center">title</td>
<td align="center">把文字置于顶部</td>
</tr>
<tr>
<td align="center">xlabel</td>
<td align="center">将文本标签添加到x轴</td>
</tr>
<tr>
<td align="center">ylabel</td>
<td align="center">将文本标签添加到y轴</td>
</tr>
<tr>
<td align="center">axes</td>
<td align="center">创建轴对象</td>
</tr>
<tr>
<td align="center">close</td>
<td align="center">关闭当前的绘图</td>
</tr>
<tr>
<td align="center">close all</td>
<td align="center">关闭所有绘图</td>
</tr>
<tr>
<td align="center">figure</td>
<td align="center">打开一个新的图形窗口</td>
</tr>
<tr>
<td align="center">gtext</td>
<td align="center">通过鼠标在指定位置放注文</td>
</tr>
<tr>
<td align="center">hold</td>
<td align="center">保持当前图形</td>
</tr>
<tr>
<td align="center">legend</td>
<td align="center">鼠标放置图例</td>
</tr>
<tr>
<td align="center">refresh</td>
<td align="center">重新绘制当前图形窗口</td>
</tr>
<tr>
<td align="center">set</td>
<td align="center">指定对象的属性，如轴</td>
</tr>
<tr>
<td align="center">subplot</td>
<td align="center">在子窗口中创建图</td>
</tr>
<tr>
<td align="center">text</td>
<td align="center">在图上做标记</td>
</tr>
<tr>
<td align="center">bar</td>
<td align="center">创建条形图</td>
</tr>
<tr>
<td align="center">loglog</td>
<td align="center">创建双对数图</td>
</tr>
<tr>
<td align="center">polar</td>
<td align="center">创建极坐标图像</td>
</tr>
<tr>
<td align="center">semilogx</td>
<td align="center">创建半对数图（对数横坐标）</td>
</tr>
<tr>
<td align="center">semilogy</td>
<td align="center">创建半对数图（对数纵坐标）</td>
</tr>
<tr>
<td align="center">stairs</td>
<td align="center">创建阶梯图</td>
</tr>
<tr>
<td align="center">stem</td>
<td align="center">创建针状图</td>
</tr>
</tbody></table>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="常用的数据类型"><a href="#常用的数据类型" class="headerlink" title="常用的数据类型"></a>常用的数据类型</h2><table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>int8</code></td>
<td align="center"><code>8</code>位有符号整数</td>
</tr>
<tr>
<td align="center"><code>uint8</code></td>
<td align="center"><code>8</code>位无符号整数</td>
</tr>
<tr>
<td align="center"><code>int16</code></td>
<td align="center"><code>16</code>位有符号整数</td>
</tr>
<tr>
<td align="center"><code>uint16</code></td>
<td align="center"><code>16</code>位无符号整数</td>
</tr>
<tr>
<td align="center"><code>int32</code></td>
<td align="center"><code>32</code>位有符号整数</td>
</tr>
<tr>
<td align="center"><code>uint32</code></td>
<td align="center"><code>32</code>位无符号整数</td>
</tr>
<tr>
<td align="center"><code>int64</code></td>
<td align="center"><code>64</code>位有符号整数</td>
</tr>
<tr>
<td align="center"><code>uint64</code></td>
<td align="center"><code>64</code>位无符号整数</td>
</tr>
<tr>
<td align="center"><code>single</code></td>
<td align="center">单精度数值数据</td>
</tr>
<tr>
<td align="center"><code>double</code></td>
<td align="center">双精度数值数据</td>
</tr>
<tr>
<td align="center"><code>logical</code></td>
<td align="center">逻辑值为<code>1</code>或<code>0</code>，分别代表<code>true</code>和<code>false</code></td>
</tr>
<tr>
<td align="center"><code>char</code></td>
<td align="center">字符数据(字符串作为字符向量存储)</td>
</tr>
</tbody></table>
<ul>
<li><p>但是用法和C不同，matlab中用法类似于函数（matlab的变量不用任何定义语句）</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line">n = <span class="number">2345</span></span><br><span class="line">d = double(n)</span><br><span class="line">un = uint32(<span class="number">789.50</span>)</span><br><span class="line">rn = <span class="number">5678.92347</span></span><br><span class="line">c = int32(rn)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="数据类型确认函数"><a href="#数据类型确认函数" class="headerlink" title="数据类型确认函数"></a>数据类型确认函数</h2><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">描述说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>is</code></td>
<td align="center">检测状态</td>
</tr>
<tr>
<td align="center"><code>isa</code></td>
<td align="center">确定输入是否是指定类的对象</td>
</tr>
<tr>
<td align="center"><code>iscell</code></td>
<td align="center">确定输入是单元格数组</td>
</tr>
<tr>
<td align="center"><code>iscellstr</code></td>
<td align="center">确定输入是字符串的单元格数组</td>
</tr>
<tr>
<td align="center"><code>ischar</code></td>
<td align="center">确定项目是否是字符数组</td>
</tr>
<tr>
<td align="center"><code>isfield</code></td>
<td align="center">确定输入是否是结构数组字段</td>
</tr>
<tr>
<td align="center"><code>isfloat</code></td>
<td align="center">确定输入是否为浮点数组</td>
</tr>
<tr>
<td align="center"><code>ishghandle</code></td>
<td align="center">确定是否用于处理图形对象句柄</td>
</tr>
<tr>
<td align="center"><code>isinteger</code></td>
<td align="center">确定输入是否为整数数组</td>
</tr>
<tr>
<td align="center"><code>isjava</code></td>
<td align="center">确定输入是否为Java对象</td>
</tr>
<tr>
<td align="center"><code>islogical</code></td>
<td align="center">确定输入是否为逻辑数组</td>
</tr>
<tr>
<td align="center"><code>isnumeric</code></td>
<td align="center">确定输入是否是数字数组</td>
</tr>
<tr>
<td align="center"><code>isobject</code></td>
<td align="center">确定输入是否为MATLAB对象</td>
</tr>
<tr>
<td align="center"><code>isreal</code></td>
<td align="center">检查输入是否为实数数组</td>
</tr>
<tr>
<td align="center"><code>isscalar</code></td>
<td align="center">确定输入是否为标量</td>
</tr>
<tr>
<td align="center"><code>isstr</code></td>
<td align="center">确定输入是否是字符数组</td>
</tr>
<tr>
<td align="center"><code>isstruct</code></td>
<td align="center">确定输入是否是结构数组</td>
</tr>
<tr>
<td align="center"><code>isvector</code></td>
<td align="center">确定输入是否为向量</td>
</tr>
<tr>
<td align="center"><code>class</code></td>
<td align="center">确定对象的类</td>
</tr>
<tr>
<td align="center"><code>validateattributes</code></td>
<td align="center">检查数组的有效性</td>
</tr>
<tr>
<td align="center"><code>whos</code></td>
<td align="center">在工作区中列出变量，其大小和类型</td>
</tr>
</tbody></table>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">目的&#x2F;作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bitand(a, b)</td>
<td align="left">当a、b是一个或数个无符号整数或无符号整数数组，返回参数a和b位和，</td>
</tr>
<tr>
<td align="left">bitcmp(a)</td>
<td align="left">a的补码</td>
</tr>
<tr>
<td align="left">bitget(a,pos)</td>
<td align="left">在指定位置pos中获取位，在整数数组a中</td>
</tr>
<tr>
<td align="left">bitor(a, b)</td>
<td align="left">对数a和b按位或</td>
</tr>
<tr>
<td align="left">bitset(a, pos)</td>
<td align="left">a的集合点在一个特定的位置pos</td>
</tr>
<tr>
<td align="left">bitshift(a, k)</td>
<td align="left">返回一个移到左K位，相当于乘以2K。K负值对应的位权转移或除以2|K|向负无穷舍入到最近的整数。任何溢出位都被截断。</td>
</tr>
<tr>
<td align="left">bitxor(a, b)</td>
<td align="left">对数a和b按位异或</td>
</tr>
<tr>
<td align="left">swapbytes</td>
<td align="left">交换字节顺序</td>
</tr>
</tbody></table>
<h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">intersect(A,B)</td>
<td align="left">设置两个数组的交集；返回A和B所共有的值。返回的值按排序顺序排列。</td>
</tr>
<tr>
<td align="left">intersect(A,B,’rows’)</td>
<td align="left">将A和B的每一行作为单个实体处理，并返回A和B的公共行。返回的矩阵的行按排序顺序排列。</td>
</tr>
<tr>
<td align="left">ismember(A,B)</td>
<td align="left">返回与A大小相同的数组，包含1（true），其中A的元素在其他地方的B中找到，它返回0（false）。</td>
</tr>
<tr>
<td align="left">ismember(A,B,’rows’)</td>
<td align="left">将A和B的每一行作为单个实体处理，并返回一个包含1（true）的向量，其中矩阵A的行也是B的行；否则，它返回0（false）。</td>
</tr>
<tr>
<td align="left">issorted(A)</td>
<td align="left">如果A的元素按排序顺序返回逻辑1（true），否则返回逻辑0（false）。输入A可以是向量，也可以是N-by-1或1-by-N的字符串数组。如果A和sort（A）的输出相等，则A被认为是排序的。</td>
</tr>
<tr>
<td align="left">issorted(A, ‘rows’)</td>
<td align="left">如果二维矩阵A的行按排序顺序返回逻辑1（真），否则返回逻辑0（假）。 如果A和排序（A）的输出相等，则认为矩阵A被排序。</td>
</tr>
<tr>
<td align="left">setdiff(A,B)</td>
<td align="left">设置两个数组的差值；返回不在B中的值。返回数组中的值按排序顺序排列。</td>
</tr>
<tr>
<td align="left">setdiff(A,B,’rows’)</td>
<td align="left">将每一行A和B行作为单个实体处理，并返回一个不在B中的行。返回的矩阵的行按排序顺序排列。“行”选项不支持单元格数组。</td>
</tr>
<tr>
<td align="left">setxor</td>
<td align="left">设置两个数组的异或</td>
</tr>
<tr>
<td align="left">union</td>
<td align="left">设置两个数组的并集</td>
</tr>
<tr>
<td align="left">unique</td>
<td align="left">数组中唯一的值</td>
</tr>
</tbody></table>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...)</span><br><span class="line">	.....;</span><br><span class="line">	.....;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(...)</span><br><span class="line">	<span class="keyword">case</span> .. 	<span class="comment">%无冒号</span></span><br><span class="line">		....;</span><br><span class="line">		....;</span><br><span class="line">	<span class="keyword">case</span> ..</span><br><span class="line">		....	<span class="comment">%单行可以不加分号</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>其他用法与C基本相同</li>
<li>end后不须跟分号（即使后面还有语句）</li>
</ul>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while()</span><br><span class="line">	...;</span><br><span class="line">	...;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for循环有三种用法：</p>
<ul>
<li><p>initval:endval  默认步长为+1，递增</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> a = <span class="number">10</span>:<span class="number">20</span> </span><br><span class="line">	...;</span><br><span class="line">	...;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>initval:step:endval  step可自定义步长</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> a = <span class="number">1.0</span>: <span class="number">-0.1</span>: <span class="number">0.0</span></span><br><span class="line">	...;</span><br><span class="line">	...;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>索引数组</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> a = [<span class="number">24</span>,<span class="number">18</span>,<span class="number">17</span>,<span class="number">23</span>,<span class="number">28</span>]</span><br><span class="line">	...;</span><br><span class="line">	...;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h1><h2 id="元素索引"><a href="#元素索引" class="headerlink" title="元素索引"></a>元素索引</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rv = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>];</span><br><span class="line">sub_rv = rv(<span class="number">3</span>:<span class="number">7</span>)</span><br><span class="line">rv(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="向量转置"><a href="#向量转置" class="headerlink" title="向量转置"></a>向量转置</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = [ <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> ];</span><br><span class="line">tr = r&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="求向量的模"><a href="#求向量的模" class="headerlink" title="求向量的模"></a>求向量的模</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v = [<span class="number">1</span>: <span class="number">2</span>: <span class="number">20</span>];</span><br><span class="line">sv = v.* v;    </span><br><span class="line">dp = sum(sv);    </span><br><span class="line">mag = <span class="built_in">sqrt</span>(dp);  </span><br></pre></td></tr></table></figure>

<h2 id="向量点积"><a href="#向量点积" class="headerlink" title="向量点积"></a>向量点积</h2><p>若要求取向量的点积，不能直接使用运算符求得，需使用函数dot(a,b)</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v1 = [<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>];</span><br><span class="line">v2 = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>];</span><br><span class="line">dp = <span class="built_in">dot</span>(v1, v2);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>*</code>号用于运算矩阵乘法，而<code>.*</code>用于数组的乘法（数组的乘法有一套自己的算法）</li>
</ul>
<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="矩阵索引"><a href="#矩阵索引" class="headerlink" title="矩阵索引"></a>矩阵索引</h2><ul>
<li><p>第m行，第n列的一个元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mx(m,n);</span><br></pre></td></tr></table></figure>
</li>
<li><p>第m列的所有元素</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [ <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>; <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>];</span><br><span class="line">v = a(:,<span class="number">4</span>) <span class="comment">%第4列的所有元素，并返回一个列向量</span></span><br></pre></td></tr></table></figure>

<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [ <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>; <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>];</span><br><span class="line">a(:, <span class="number">2</span>:<span class="number">3</span>) <span class="comment">%第2-3列的所有元素</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注：索引从1开始，而不是0</strong></p>
<h2 id="删除行或列"><a href="#删除行或列" class="headerlink" title="删除行或列"></a>删除行或列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [ 1 2 3 4 5; 2 3 4 5 6; 3 4 5 6 7; 4 5 6 7 8];</span><br><span class="line">a( 4 , : ) = []</span><br></pre></td></tr></table></figure>

<h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [ <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> ; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>];</span><br><span class="line">b = [ <span class="number">7</span> <span class="number">5</span> <span class="number">6</span> ; <span class="number">2</span> <span class="number">0</span> <span class="number">8</span>; <span class="number">5</span> <span class="number">7</span> <span class="number">1</span>];</span><br><span class="line">c = a / b	<span class="comment">%a右乘b的逆矩阵(inv(b))</span></span><br><span class="line">d = a \ b	<span class="comment">%b左乘a的逆矩阵</span></span><br></pre></td></tr></table></figure>

<ul>
<li>必须为方阵，因为只有方阵才有逆矩阵</li>
</ul>
<h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [ <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>; <span class="number">1</span> <span class="number">2</span> <span class="number">5</span>]</span><br><span class="line">det(a)</span><br></pre></td></tr></table></figure>

<ul>
<li>行列式一定为方阵</li>
<li>转置不改变行列式的值</li>
</ul>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = [7 9 5; 6 1 9; 4 3 2];</span><br><span class="line">a(:, :, 2)= [ 1 2 3; 4 5 6; 7 8 9];</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">a(:,:,1) =</span><br><span class="line">     7     9     5</span><br><span class="line">     6     1     9</span><br><span class="line">     4     3     2</span><br><span class="line"></span><br><span class="line">a(:,:,2) =</span><br><span class="line">     1     2     3</span><br><span class="line">     4     5     6</span><br><span class="line">     7     8     9</span><br></pre></td></tr></table></figure>

<p>或使用cat函数：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="built_in">cat</span>(<span class="number">3</span>,a,[ <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]); <span class="comment">%维度+要串联的阵列</span></span><br></pre></td></tr></table></figure>

<h1 id="单元阵列"><a href="#单元阵列" class="headerlink" title="单元阵列"></a>单元阵列</h1><p>单元阵列的阵列中每个单元格可以存储不同的维度和数据类型的数组的索引单元格</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C = cell(dim1,...,dimN) <span class="comment">%dim 是一个标量整数或整数向量，指定单元格阵列C的尺寸</span></span><br></pre></td></tr></table></figure>

<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c = cell(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">c = &#123;<span class="string">&#x27;Red&#x27;</span>, <span class="string">&#x27;Blue&#x27;</span>, <span class="string">&#x27;Green&#x27;</span>, <span class="string">&#x27;Yellow&#x27;</span>, <span class="string">&#x27;White&#x27;</span>; <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">c = </span><br><span class="line">    <span class="string">&#x27;Red&#x27;</span>    <span class="string">&#x27;Blue&#x27;</span>    <span class="string">&#x27;Green&#x27;</span>    <span class="string">&#x27;Yellow&#x27;</span>    <span class="string">&#x27;White&#x27;</span></span><br><span class="line">    [  <span class="number">1</span>]    [   <span class="number">2</span>]    [    <span class="number">3</span>]    [     <span class="number">4</span>]    [    <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<h2 id="单元阵列索引"><a href="#单元阵列索引" class="headerlink" title="单元阵列索引"></a>单元阵列索引</h2><p>可以使用大括号或小括号索引，索引方法与前相同</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="一般函数格式"><a href="#一般函数格式" class="headerlink" title="一般函数格式"></a>一般函数格式</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[out1,out2,...]</span> = <span class="title">fun_name</span><span class="params">(in1,in2,...)</span></span></span><br><span class="line"><span class="comment">%帮助文本</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">power = @(x, n) x.^n;</span><br><span class="line">result1 = power(<span class="number">7</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h1 id="绘图-1"><a href="#绘图-1" class="headerlink" title="绘图"></a>绘图</h1><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">plot</span>(x, y), xlabel(<span class="string">&#x27;x&#x27;</span>), ylabel(<span class="string">&#x27;Sin(x)&#x27;</span>), title(<span class="string">&#x27;Sin(x) Graph&#x27;</span>),</span><br></pre></td></tr></table></figure>

<h2 id="绘制多条曲线"><a href="#绘制多条曲线" class="headerlink" title="绘制多条曲线"></a>绘制多条曲线</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">-10</span> : <span class="number">0.01</span>: <span class="number">10</span>];</span><br><span class="line">y = <span class="number">3</span>*x.^<span class="number">4</span> + <span class="number">2</span> * x.^<span class="number">3</span> + <span class="number">7</span> * x.^<span class="number">2</span> + <span class="number">2</span> * x + <span class="number">9</span>;</span><br><span class="line">g = <span class="number">5</span> * x.^<span class="number">3</span> + <span class="number">9</span> * x + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">plot</span>(x, y, <span class="string">&#x27;r&#x27;</span>, x, g, <span class="string">&#x27;g&#x27;</span>) <span class="comment">% &#x27;r&#x27;,&#x27;g&#x27;代表曲线颜色</span></span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;y(x)&#x27;</span>,<span class="string">&#x27;g(x)&#x27;</span>);</span><br></pre></td></tr></table></figure>

<img src="/images/loading.png" data-original="/2022/11/09/matlab/p1.jpg" class title="This is an image"> 

<h2 id="设置轴刻度"><a href="#设置轴刻度" class="headerlink" title="设置轴刻度"></a>设置轴刻度</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axis ( [xmin xmax ymin ymax] )</span><br></pre></td></tr></table></figure>

<h2 id="绘制多个图像"><a href="#绘制多个图像" class="headerlink" title="绘制多个图像"></a>绘制多个图像</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subplot(a,b,c);</span><br></pre></td></tr></table></figure>

<ul>
<li>a：总行</li>
<li>b：总列</li>
<li>c：第几图</li>
</ul>
<p>例如生成2*2个图像，第二行第一个图则为<code>subplot(2,2,3);</code></p>
<h1 id="代数"><a href="#代数" class="headerlink" title="代数"></a>代数</h1><h2 id="声明一个代数"><a href="#声明一个代数" class="headerlink" title="声明一个代数"></a>声明一个代数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syms x </span><br></pre></td></tr></table></figure>

<h2 id="解代数方程"><a href="#解代数方程" class="headerlink" title="解代数方程"></a>解代数方程</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solve(x^<span class="number">2</span> <span class="number">-7</span>*x + <span class="number">12</span> == <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>或：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eq=<span class="string">&#x27;x^2 -7*x + 12 == 0&#x27;</span>;</span><br><span class="line">result=solve(eq);</span><br></pre></td></tr></table></figure>

<p>若要单独显示各个根：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disp</span>(result(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">disp</span>(result(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">disp</span>(result(<span class="number">3</span>));</span><br><span class="line"><span class="built_in">disp</span>(result(<span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>我的matlab必须手动打印结果，不知道为什么</strong></li>
</ul>
<h1 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h1><p>当计算一个一元多次项时，可以使用行向量表示，例如：</p>
<p>方程 P(x) &#x3D; x^4 + 7x^3 - 5x + 9 可以表示为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = [1 7 0 -5 9]；</span><br></pre></td></tr></table></figure>

<p>求解：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">polyval(p,<span class="number">4</span>) <span class="comment">%计算当x=4时多项式的值</span></span><br></pre></td></tr></table></figure>

<p>还可以通过输入矩阵的方式计算多个值：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p = [<span class="number">1</span> <span class="number">7</span> <span class="number">0</span>  <span class="number">-5</span> <span class="number">9</span>];</span><br><span class="line">X = [<span class="number">1</span> <span class="number">2</span> <span class="number">-3</span> <span class="number">4</span>; <span class="number">2</span> <span class="number">-5</span> <span class="number">6</span> <span class="number">3</span>; <span class="number">3</span> <span class="number">1</span> <span class="number">0</span> <span class="number">2</span>; <span class="number">5</span> <span class="number">-7</span> <span class="number">3</span> <span class="number">8</span>];</span><br><span class="line">polyval(p, X);</span><br><span class="line"></span><br><span class="line"><span class="comment">%结果：</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">        <span class="number">2307</span>       <span class="number">-1769</span>        <span class="number">-939</span>        <span class="number">4499</span></span><br><span class="line">        <span class="number">2314</span>       <span class="number">-2376</span>        <span class="number">-249</span>        <span class="number">4695</span></span><br><span class="line">        <span class="number">2256</span>       <span class="number">-1892</span>        <span class="number">-549</span>        <span class="number">4310</span></span><br><span class="line">        <span class="number">4570</span>       <span class="number">-4532</span>       <span class="number">-1062</span>        <span class="number">9269</span></span><br></pre></td></tr></table></figure>

<h2 id="使用多项式的曲线拟合"><a href="#使用多项式的曲线拟合" class="headerlink" title="使用多项式的曲线拟合"></a>使用多项式的曲线拟合</h2><p>当我们要对离散点拟合一条曲线时，可以使用polyfit函数，该函数的作用是通过最小二乘法的方式<strong>拟合出一条曲线的多项式</strong>。</p>
<ul>
<li>polyfit(x,y,n)	n为需要拟合的最高次幂，具体求法可参考[MATLAB polyfit曲线拟合及拟合最高次幂的选择](<a href="https://blog.csdn.net/weixin_39796363/article/details/116188595?ops_request_misc=%7B%22request_id%22:%22166808186016782425129618%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&amp;request_id=166808186016782425129618&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-6-116188595-null-null.142%5Ev63%5Epc_rank_34_queryrelevant25,201%5Ev3%5Eadd_ask,213%5Ev2%5Et3_esquery_v3&amp;utm_term=matlab">https://blog.csdn.net/weixin_39796363/article/details/116188595?ops_request_misc=%7B%22request%5Fid%22%3A%22166808186016782425129618%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=166808186016782425129618&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-6-116188595-null-null.142^v63^pc_rank_34_queryrelevant25,201^v3^add_ask,213^v2^t3_esquery_v3&amp;utm_term=matlab</a> polyfit&amp;spm&#x3D;1018.2226.3001.4187)</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]; y = [<span class="number">5.5</span> <span class="number">43.1</span> <span class="number">128</span> <span class="number">290.7</span> <span class="number">498.4</span> <span class="number">978.67</span>]; </span><br><span class="line">p = polyfit(x,y,<span class="number">5</span>)   </span><br></pre></td></tr></table></figure>

<p>此时p为一个多项式，可以使用polyval在坐标集上拟合出该曲线</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x2 = <span class="number">1</span>:<span class="number">0.1</span>:<span class="number">6</span>;          </span><br><span class="line">y2 = polyval(p,x2);</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;o&#x27;</span>,x2,y2)</span><br></pre></td></tr></table></figure>

]]></content>
      
        
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++_IO库]]></title>
      <url>/2022/10/31/C++-7/</url>
      <content type="html"><![CDATA[<h1 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h1><p>在之前的一些用到输入与输出的程序都是用户对流的读写，也就是使用的iostream类，但是C++中的IO处理并不止通过流进行读写，为了支持不同的IO操作，标准库中还定义了其他的一些IO类，他们被包含在不同的头文件中：</p>
<table>
<thead>
<tr>
<th align="center">头文件</th>
<th align="center">类</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">iostream</td>
<td align="center">(w)istream<br>(w)ostream<br>(w)iostream</td>
<td align="center">从<strong>普通流</strong>中读写数据</td>
</tr>
<tr>
<td align="center">fstream</td>
<td align="center">(w)ifstream<br>(w)ofstream<br>(w)fstream</td>
<td align="center">从<strong>文件流</strong>中读写数据</td>
</tr>
<tr>
<td align="center">sstream</td>
<td align="center">(w)istringstream<br>(w)ostringstream<br>(w)stringstream</td>
<td align="center">从<strong>字符串流</strong>中读写数据</td>
</tr>
</tbody></table>
<ul>
<li>在类和其函数前添加w则为正常类对象、函数等（例如wcin，wcout）的宽字符版。</li>
</ul>
<h2 id="IO类型间的关系"><a href="#IO类型间的关系" class="headerlink" title="IO类型间的关系"></a>IO类型间的关系</h2><p>类型ifstream和istringstream都<strong>继承</strong>自istream，因此，我们如何使用istream，就如何使用其他IO类型。在之后介绍的标准库的流特性<strong>均可以无差别地使用于各个IO类型</strong>。</p>
<h1 id="IO类型的特性"><a href="#IO类型的特性" class="headerlink" title="IO类型的特性"></a>IO类型的特性</h1><h2 id="IO对象不能拷贝"><a href="#IO对象不能拷贝" class="headerlink" title="IO对象不能拷贝"></a>IO对象不能拷贝</h2><p>当我们定义了一些IO对象时（通常是用于IO操作的一些函数），之前也使用过，是不能对这些对象进行拷贝或赋值的操作的，<strong>因此当我们操作流时，通常都是使用引用的方式传递和返回流</strong>，这也意味着这些IO操作函数的返回类型要定义为IO类的引用，参数中的流也需定义为IO类的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;in, person &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in&gt;&gt;item.name&gt;&gt;item.addr;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;<span class="comment">//上一章讲到的read函数就是一个IO操作函数</span></span><br></pre></td></tr></table></figure>

<h2 id="条件状态"><a href="#条件状态" class="headerlink" title="条件状态"></a>条件状态</h2><p>当使用IO操作流时可能会发生多种错误，为了查询这些错误，标准库中定义了相关函数和标准以访问当前流的条件状态。</p>
<p>流分为以下几个状态：（这些状态为IO类中定义）</p>
<table>
<thead>
<tr>
<th align="center">badbit</th>
<th align="center">当前流已崩溃</th>
</tr>
</thead>
<tbody><tr>
<td align="center">failbit</td>
<td align="center">当前IO操作失败了</td>
</tr>
<tr>
<td align="center">eofbit</td>
<td align="center">当前流到达了文件结束</td>
</tr>
<tr>
<td align="center">goodbit</td>
<td align="center">为0代表流正常</td>
</tr>
</tbody></table>
<ul>
<li>可以对这些状态位进行位运算</li>
<li>badbit表示系统级错误，是不可恢复的错误。通常一旦被置位，流就无法再使用了。</li>
<li>failbit表示可恢复的错误，修正后流可以机械使用。<strong>badbit被置位后failbit也会被置位</strong>。</li>
<li>如果文件结束，failbit和eofbit<strong>都会被置位</strong>。</li>
<li>上面三位<strong>任意一位有置位情况goodbit都会被置位</strong>。</li>
</ul>
<p>以下是IO类的一些查询函数：</p>
<table>
<thead>
<tr>
<th align="center">类的子函数</th>
<th align="center">作用</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">eof()</td>
<td align="center">查询eofbit状态</td>
<td align="center">若对应状态位<strong>置位</strong>则返回ture</td>
</tr>
<tr>
<td align="center">fail()</td>
<td align="center">查询failbit状态</td>
<td align="center">若对应状态位<strong>置位</strong>则返回ture</td>
</tr>
<tr>
<td align="center">bad()</td>
<td align="center">查询badbit状态</td>
<td align="center">若对应状态位<strong>置位</strong>则返回ture</td>
</tr>
<tr>
<td align="center">good()</td>
<td align="center">查询goodbit状态</td>
<td align="center">若对应状态位<strong>置位</strong>则返回ture</td>
</tr>
<tr>
<td align="center">clear()</td>
<td align="center">将流中所有条件状态位复位</td>
<td align="center">void</td>
</tr>
<tr>
<td align="center">rdstate()</td>
<td align="center">返回当前流的状态</td>
<td align="center">一种包含所有状态位信息的类，但类型同状态位</td>
</tr>
<tr>
<td align="center">clear(flag)</td>
<td align="center">复位指定状态位</td>
<td align="center">void</td>
</tr>
<tr>
<td align="center">setstate(flag)</td>
<td align="center">置位指定状态位</td>
<td align="center">void</td>
</tr>
</tbody></table>
<h3 id="管理条件状态"><a href="#管理条件状态" class="headerlink" title="管理条件状态"></a>管理条件状态</h3><p>每进行一次流操作后恢复上一次的条件状态：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> oldstate = cin.<span class="built_in">rdstate</span>();</span><br><span class="line">cin.<span class="built_in">clear</span>();</span><br><span class="line">cin&gt;&gt;....<span class="comment">//一次输入流操作</span></span><br><span class="line">cin.<span class="built_in">setstate</span>(oldstate);</span><br></pre></td></tr></table></figure>

<p>通过位操作一次操作多个状态位：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设当前所有状态置位</span></span><br><span class="line">cin.<span class="built_in">clear</span>(cin.<span class="built_in">rdstate</span>() &amp; ~cin.failbit &amp; ~cin.badbit)<span class="comment">//只复位failbit，badbit</span></span><br></pre></td></tr></table></figure>

<h2 id="输出流的缓冲"><a href="#输出流的缓冲" class="headerlink" title="输出流的缓冲"></a>输出流的缓冲</h2><h3 id="刷新缓冲区"><a href="#刷新缓冲区" class="headerlink" title="刷新缓冲区"></a>刷新缓冲区</h3><p>之前讲到过输出endl可以刷新缓冲区，还有以下操作也可以刷新</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;endl; <span class="comment">//换行</span></span><br><span class="line">cout&lt;&lt;flush; <span class="comment">//不添加任何额外字符</span></span><br><span class="line">cout&lt;&lt;ends; <span class="comment">//添加一个空字符</span></span><br></pre></td></tr></table></figure>

<h3 id="刷新缓冲区的作用"><a href="#刷新缓冲区的作用" class="headerlink" title="刷新缓冲区的作用"></a>刷新缓冲区的作用</h3><p>我其实也不是特别理解，姑且谈一下我的理解，这是网上的一个例程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">setvbuf</span>( stdout, <span class="literal">NULL</span>, _IOLBF, <span class="number">1024</span> );  <span class="comment">//设置控制台输出为行缓存模式，把缓冲区与流相关 </span></span><br><span class="line">	cout &lt;&lt;<span class="string">&quot;hello world\n&quot;</span>&lt;&lt;endl;                </span><br><span class="line">	<span class="built_in">Sleep</span>(<span class="number">5000</span>);                            </span><br><span class="line">	cout &lt;&lt;<span class="string">&quot;leeboy&quot;</span> &lt;&lt;endl;                 </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果第四行不刷新缓冲区，则4行内容会和7行在5s后一起输出，所以刷新缓冲区的作用应该是立即输出当前内容？而按照网上说法，如果不刷新缓冲区，输出是由系统每隔一段时间检测输出流是否有内容。</p>
<h3 id="unitbuf操作符"><a href="#unitbuf操作符" class="headerlink" title="unitbuf操作符"></a>unitbuf操作符</h3><p>如果想设置每一次输出后自动刷新缓冲区，可以：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;std::unitbuf;</span><br><span class="line">cout&lt;&lt;std::nounitbuf;<span class="comment">//恢复正常缓冲模式</span></span><br></pre></td></tr></table></figure>

<h3 id="关联输入和输出流"><a href="#关联输入和输出流" class="headerlink" title="关联输入和输出流"></a>关联输入和输出流</h3><p>关联后任何试图从输入流读取数据的操作都会先刷新关联的输出流</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;std::ival;<span class="comment">//默认情况下cin和cerr都关联到了cout</span></span><br></pre></td></tr></table></figure>

<h1 id="文件的输入与输出"><a href="#文件的输入与输出" class="headerlink" title="文件的输入与输出"></a>文件的输入与输出</h1><p>头文件fstream中定义了三个类来支持关于文件的IO操作：</p>
<ul>
<li>ifstream：用于文件读操作，从给定文件读取内容</li>
<li>ofstream：用于文件写操作</li>
<li>fstream：读写操作，可以通过不同配置实现上两类的功能</li>
</ul>
<p>这些类都继承了iostream的相关操作，同时还定义了一些新的成员来管理与流相关的文件，以下列出了部分特有操作，<strong>这些操作都适用于上三个类</strong>，但不能对其他IO类调用</p>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">fstream a;</td>
<td align="center">创建一个未绑定的文件流</td>
</tr>
<tr>
<td align="center">fstream a(s);</td>
<td align="center">创建一个文件流，并打开名为s的文件，s为string类型或C风格字符串指针</td>
</tr>
<tr>
<td align="center">a.open()</td>
<td align="center">打开一个文件，并绑定至流a</td>
</tr>
<tr>
<td align="center">a.close()</td>
<td align="center">关闭绑定的文件</td>
</tr>
<tr>
<td align="center">a.is_open()</td>
<td align="center">返回一个bool值，指出文件是否成功打开</td>
</tr>
</tbody></table>
<h2 id="文件的打开"><a href="#文件的打开" class="headerlink" title="文件的打开"></a>文件的打开</h2><p>刚刚讲到了有两种方式打开一个文件，分别是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fstream <span class="title">a</span><span class="params">(<span class="string">&quot;dhk.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">///////////////////////</span></span><br><span class="line">fstream b;</span><br><span class="line">b.<span class="built_in">open</span>(<span class="string">&quot;dhk.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>我们先详解一下open函数：</p>
<h3 id="open-函数"><a href="#open-函数" class="headerlink" title="open()函数"></a>open()函数</h3><p>根据输入的参数数量，该函数有以下几个定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> member function</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">open</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * filename,</span></span></span><br><span class="line"><span class="params"><span class="function">            ios_base::openmode mode = ios_base::in | ios_base::out )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">wchar_t</span> *_Filename,</span></span></span><br><span class="line"><span class="params"><span class="function">        ios_base::openmode mode= ios_base::in | ios_base::out,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> prot = ios_base::_Openprot)</span>；</span></span><br><span class="line"><span class="function"> </span></span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li>filename：文件名</li>
<li>open mode：打开方式</li>
<li>prot：打开文件的属性，一般很少用到</li>
</ul>
<p>这里重点讲一下打开方式，刚刚我们讲过：头文件fstream中的fstream类可以实现读和写的操作，也就是可以通过不同的配置实现ifstream和ofstream的操作，也就是通过这里的打开方式配置。</p>
<p>打开方式在ios类中定义：</p>
<table>
<thead>
<tr>
<th align="center">ios::in</th>
<th align="center">为输入(读)而打开文件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ios::out</td>
<td align="center">为输出(写)而打开文件</td>
</tr>
<tr>
<td align="center">ios::ate</td>
<td align="center">初始位置：文件尾</td>
</tr>
<tr>
<td align="center">ios::app</td>
<td align="center">所有输出附加在文件末尾</td>
</tr>
<tr>
<td align="center">ios::trunc</td>
<td align="center">如果文件已存在则先删除该文件</td>
</tr>
<tr>
<td align="center">ios::binary</td>
<td align="center">二进制方式</td>
</tr>
</tbody></table>
<p><strong>这些方式可以通过或运算|组合使用</strong></p>
<ul>
<li>ate和binary通常用于打开任何类型的文件流对象</li>
</ul>
<h3 id="默认打开方式"><a href="#默认打开方式" class="headerlink" title="默认打开方式"></a>默认打开方式</h3><p>对于第二种方式<code>fstream a(&quot;dhk.txt&quot;);</code>其实是隐式地调用了open()函数，直接使用了默认打开方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;...&quot;</span>, ios::out)</span></span>;</span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;...&quot;</span>, ios::in)</span></span>;</span><br><span class="line"><span class="function">fstream <span class="title">foi</span><span class="params">(<span class="string">&quot;...&quot;</span>, ios::in|ios::out)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="以写模式打开一个文件会丢弃已有数据"><a href="#以写模式打开一个文件会丢弃已有数据" class="headerlink" title="以写模式打开一个文件会丢弃已有数据"></a>以写模式打开一个文件会丢弃已有数据</h3><p>默认情况下，当打开一个ofstream对象时，若没有指定模式，默认是隐含的使用截断(ios::trunc)，即每次打开该文件时会清空之前的内容，若要阻止清空，<strong>需显式地设置为ios::app模式</strong>，同时，使用app模式则隐式地包含了ios::out。</p>
<h2 id="使用fstream对象代替iostream-amp"><a href="#使用fstream对象代替iostream-amp" class="headerlink" title="使用fstream对象代替iostream&amp;"></a>使用fstream对象代替iostream&amp;</h2><p>由于fstream类继承自iostream，因此，接受一个iostream类型引用参数的函数也可以接收fstream类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">struct</span> <span class="title class_">person</span></span><br><span class="line"> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    string addr;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;in, person &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in&gt;&gt;item.name&gt;&gt;item.addr;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;out, person &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    out&lt;&lt;<span class="string">&quot;NAME: &quot;</span>&lt;&lt;item.name&lt;&lt;endl;</span><br><span class="line">    out&lt;&lt;<span class="string">&quot;ADDR: &quot;</span>&lt;&lt;item.addr&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    person man;</span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;D.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;dhk.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">read</span>(in,man);	<span class="comment">//使用ifstream代替istream</span></span><br><span class="line">    <span class="built_in">print</span>(out,man); 	<span class="comment">//使用ofstream代替ostream</span></span><br><span class="line">    out.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>对一个已经打开的文件流再调用open函数会导致该流的failbit置位，后续操作都会失败</p>
<ul>
<li>查看文件是否成功打开的快捷方式：if(a);</li>
</ul>
<h2 id="文件打开路径的问题"><a href="#文件打开路径的问题" class="headerlink" title="文件打开路径的问题"></a>文件打开路径的问题</h2><p>文件的默认打开路径我也没搞懂，最好使用相对路径打开相关文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;.vscode\\fstream\\D.txt&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p><u><strong>并且这里要使用双斜杠！！！</strong></u></p>
<h1 id="字符串流"><a href="#字符串流" class="headerlink" title="字符串流"></a>字符串流</h1><p>在头文件sstream中定义了三个类来支持操作字符串IO，分别是：</p>
<ul>
<li>istringstream</li>
<li>ostirngstream</li>
<li>stringstream</li>
</ul>
<p>这些类同样继承自iostream，用法同文件流，类特有操作有：</p>
<table>
<thead>
<tr>
<th align="center">stringstream a;</th>
<th align="center">创建一个未绑定string的流</th>
</tr>
</thead>
<tbody><tr>
<td align="center">stringstream a(s);</td>
<td align="center">与string对象s绑定的一个字符串流</td>
</tr>
<tr>
<td align="center">a.str();</td>
<td align="center">返回a中所保存的所有字符串</td>
</tr>
<tr>
<td align="center">a.str();</td>
<td align="center">将s拷贝至a中，返回void</td>
</tr>
<tr>
<td align="center">a.clear();</td>
<td align="center">清空流</td>
</tr>
</tbody></table>
<h2 id="读取string"><a href="#读取string" class="headerlink" title="读取string"></a>读取string</h2><p>与文件流相同，stringstream也可以实现读取和输入的功能</p>
<p>下面以一个例程说明string流的用法 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">person</span></span><br><span class="line"> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    string addr;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;in, person &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in&gt;&gt;item.name&gt;&gt;item.addr;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;out, person &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    out&lt;&lt;<span class="string">&quot;NAME: &quot;</span>&lt;&lt;item.name&lt;&lt;endl;</span><br><span class="line">    out&lt;&lt;<span class="string">&quot;ADDR: &quot;</span>&lt;&lt;item.addr&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    person man;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;sstream\\D.txt&quot;</span>)</span></span>;	<span class="comment">//打开一个txt文件并绑定一个输入文件流in</span></span><br><span class="line">   <span class="comment">/*D.txt的内容：</span></span><br><span class="line"><span class="comment">   dhk 12</span></span><br><span class="line"><span class="comment">   aca 34</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(in,line))	<span class="comment">//分别处理文件中每一行的数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">stringstream <span class="title">s</span><span class="params">(line)</span></span>;<span class="comment">//将该行内容与字符串流s绑定，s的寿命为当次循环，当次循环结束s自动销毁</span></span><br><span class="line">        s&gt;&gt;man.name;<span class="comment">//将该行第一个词输入进类成员</span></span><br><span class="line">        s&gt;&gt;man.addr;<span class="comment">//该行第二个词输入进类成员</span></span><br><span class="line">        <span class="built_in">print</span>(cout,man);<span class="comment">//通过iostream输出类成员</span></span><br><span class="line">    &#125;</span><br><span class="line">    in.<span class="built_in">close</span>();<span class="comment">//关闭打开的文件</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看出，流每次输出（入）的内容为一个“词”，也就是说空格和换行都会结束该次输出（入）的内容</li>
</ul>
<h2 id="输出到字符串流"><a href="#输出到字符串流" class="headerlink" title="输出到字符串流"></a>输出到字符串流</h2><p>当我们想逐步构造想要输出的内容，最后一口气打印时，就可以使用字符串的输出流，将构造好的内容分布写入到ostingstream（或stringstream的输出流）中，最后通过函数.str()输出到cout或者你想要的其他流中</p>
]]></content>
      
        
        <tags>
            
            <tag> C++学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C_杂项]]></title>
      <url>/2022/10/30/C-%E6%9D%82%E9%A1%B9/</url>
      <content type="html"><![CDATA[<h1 id="位域结构体"><a href="#位域结构体" class="headerlink" title="位域结构体"></a>位域结构体</h1><p>有时候，信息存储的时候，并不需要一个完整的字节，而只需占几个或一个二进制位就能满足需求。例如存放一个bool类型的变量，只需要true或者false即可，这种情况下，只需要0或者1一位二进制位即可。为了节省存储空间，并使处理简便，C语言又提供了一种数据结构，称为“位域”或“位段”。<strong>所谓“位域”是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。</strong>每个域有一个域名，允许在程序中按域名进行操作。<strong>这样就可以把几个不同的对象用一个字节的二进制位域来表示。</strong></p>
<p>格式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">net_pro_cdu</span>  </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="type">unsigned</span>  <span class="type">char</span> acs:<span class="number">4</span> </span><br><span class="line">    <span class="type">unsigned</span>  <span class="type">char</span> :<span class="number">0</span>  </span><br><span class="line">    <span class="type">unsigned</span>  <span class="type">char</span> ace:<span class="number">4</span>  </span><br><span class="line">    <span class="type">unsigned</span>  <span class="type">char</span> dve:<span class="number">4</span> </span><br><span class="line">&#125; Ncdu;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>无位域名的位域不能使用，仅用来填充、调整尾置（如第四行）</li>
<li>位大小不能超过定义用的类型（如上述例子位数不能超过8）</li>
</ul>
<h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><p>声明一个变量是易变的，可以防止编译器对程序一些变量运算的过度优化。</p>
<h1 id="for循环执行顺序"><a href="#for循环执行顺序" class="headerlink" title="for循环执行顺序"></a>for循环执行顺序</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">     <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行顺序解抛<br>执行的顺序如下：<br>第一步 ： i&#x3D;0  初始化值<br>第二步 ： i&lt;5 进行条件判断，如果为真，则继续执行<br>第三步 ： 执行循环体的内容<br>第四步 ： i++ 变量i自增<br>第五步 ： 回到第二步，条件判断为真，则执行循环体内容，再到i++一直循环，<br>直到第二步的判断条件为假，则退出该循环</p>
<p>原文链接：<a href="https://blog.csdn.net/weixin_44080187/article/details/123429045">https://blog.csdn.net/weixin_44080187/article/details/123429045</a></p>
<h1 id="union类型"><a href="#union类型" class="headerlink" title="union类型"></a>union类型</h1><h2 id="长度问题"><a href="#长度问题" class="headerlink" title="长度问题"></a>长度问题</h2><p>实例化为变量后，这个变量的长度是这个union中最长的数据类型的长度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">DEMO</span>&#123;</span> </span><br><span class="line">     <span class="type">char</span> status;</span><br><span class="line">     <span class="type">int</span> a; </span><br><span class="line">     <span class="type">int</span> serial[<span class="number">4</span>]; </span><br><span class="line">&#125;demo；<span class="comment">//大小为16字节</span></span><br></pre></td></tr></table></figure>

<h2 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h2><p>对于union成员，地址相同，存储有点像并列一样的存储（？我是这么理解的），一个成员变化一定会影响其他成员</p>
]]></content>
      
        
        <tags>
            
            <tag> C语言学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++_类]]></title>
      <url>/2022/10/26/C++-6/</url>
      <content type="html"><![CDATA[<h1 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h1><h2 id="定义一个类"><a href="#定义一个类" class="headerlink" title="定义一个类"></a>定义一个类</h2><p>C++中可以使用struct和class构建一个类，struct为继承C语言留下，但用法与C不同。struct和class使用方法完全相同，只是对类成员默认的访问权限不同，这点后面会谈到。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>/<span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	string addr;</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在类的外部定义成员函数"><a href="#在类的外部定义成员函数" class="headerlink" title="在类的外部定义成员函数"></a>在类的外部定义成员函数</h2><p>C++的struct与C最不同的一点就是C++可以在类中定义函数，例如上述类中声明了一个返回值为int型的函数。</p>
<p>该函数的内容可以在类中定义，也可以只在类中声明，再在外部定义。在外部定义时需注意以下几点：</p>
<ul>
<li>函数类型声明、函数名、参数列表必须和声明中一致</li>
<li>由于函数是在类中声明，在定义时需声明其命名空间（声明函数名）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">person::test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定义一个返回类的函数"><a href="#定义一个返回类的函数" class="headerlink" title="定义一个返回类的函数"></a>定义一个返回类的函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	string addr;</span><br><span class="line">   <span class="function">person&amp; <span class="title">copy</span><span class="params">(<span class="type">const</span> person &amp;x)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      name=x.name;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>该函数同样可以在类外定义，规则同上一节</p>
</li>
<li><p>函数返回的类型<strong>必须为引用</strong>，因为返回的值应该为一个左值</p>
</li>
<li><p>若函数参数也为一个类对象，也必须为引用格式</p>
</li>
<li><p>return *this意为返回该调用该函数的对象，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person test1,test2;</span><br><span class="line">test1.name=&quot;dhk&quot;; test2.name=&quot;aca&quot;;</span><br><span class="line">test1.copy(test2);</span><br><span class="line">cout&lt;&lt;test1.name; //输出&quot;aca&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数体中的name和addr为调用该函数的对象的类成员</p>
</li>
</ul>
<h2 id="定义类相关的非成员函数"><a href="#定义类相关的非成员函数" class="headerlink" title="定义类相关的非成员函数"></a>定义类相关的非成员函数</h2><h3 id="通过定义流的引用直接操作类成员的输入输出"><a href="#通过定义流的引用直接操作类成员的输入输出" class="headerlink" title="通过定义流的引用直接操作类成员的输入输出"></a>通过定义流的引用直接操作类成员的输入输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;in, person &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in&gt;&gt;item.name&gt;&gt;item.addr;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;out, person &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    out&lt;&lt;<span class="string">&quot;NAME: &quot;</span>&lt;&lt;item.name&lt;&lt;endl;</span><br><span class="line">    out&lt;&lt;<span class="string">&quot;ADDR: &quot;</span>&lt;&lt;item.addr&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>istream和ostream需提前声明其命名空间</li>
<li>IO类不能被拷贝，因此当其作为参数时<strong>必须通过引用传递值</strong></li>
<li>此处print函数的参数item可以不使用引用</li>
</ul>
<h1 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h1><p>当我们定义一个类对象时，并没有对每一个类成员进行初始化，这时，编译器便通过一个特殊的构造函数来控制当前初始化，此函数叫做默认构造函数，<strong>该函数会对所有成员进行默认初始化。</strong></p>
<p>但是如果我们想在定义类对象时就对一些成员进行我们想要的初始化该怎么办呢？这时我们就可以自己定义构造函数对一些类成员进行想要的初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span></span><br><span class="line">&#123;	</span><br><span class="line">   <span class="built_in">person</span>()=<span class="keyword">default</span>;</span><br><span class="line">   <span class="built_in">person</span>(string s1, string s2) &#123;name=s1;addr=s2;&#125;</span><br><span class="line">   <span class="built_in">person</span>(person &amp;item) &#123;<span class="built_in">copy</span>(item);&#125;</span><br><span class="line">   <span class="built_in">person</span>(istream &amp;in) &#123;<span class="built_in">read</span>(in,*<span class="keyword">this</span>);&#125;</span><br><span class="line"><span class="comment">/**********************以上为构造函数*******************/</span>      </span><br><span class="line">	string name;</span><br><span class="line">	string addr;</span><br><span class="line">   <span class="function">person&amp; <span class="title">copy</span><span class="params">(<span class="type">const</span> person &amp;x)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      name=x.name;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;in, person &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in&gt;&gt;item.name&gt;&gt;item.addr;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   person a;</span><br><span class="line">   <span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;dhk&quot;</span>)</span>,<span class="title">s2</span><span class="params">(<span class="string">&quot;aca&quot;</span>)</span></span>; <span class="function">person <span class="title">b</span><span class="params">(s1,s2)</span></span>;</span><br><span class="line">   <span class="function">person <span class="title">c</span><span class="params">(b)</span></span>;</span><br><span class="line">   <span class="function">person <span class="title">d</span><span class="params">(cin)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在person类中一共定义了四个构造函数，下面将分别讲解这四个构造函数的含义和相关知识：</p>
<ul>
<li><p><code>person()=default;</code>默认构造函数</p>
<p>当一个类中定义了其他构造函数时，编译器便不会自动生成默认构造函数。因此，若没有此函数，主函数中24行便会报错，原因是没有与当前定义情况匹配的构造函数。</p>
</li>
<li><p><code>person(string s1, string s2)</code></p>
<p>如主函数25行，当初始化参数为两个string对象时，会进入该构造函数，该构造函数的作用是将类成员赋值为两个string对象。需要注意：</p>
<ul>
<li><p>大括号内为构造函数的函数体，可以在此完成一系列的初始化</p>
</li>
<li><p>这里也有一种构造初始值列表的初始化方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">person</span>(string s1, string s2): <span class="built_in">name</span>(s1),<span class="built_in">addr</span>(s2) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>两种方式作用完全相同，但是实现的原理有所差异，这点后面会讲到。</p>
</li>
</ul>
</li>
<li><p><code>person(person &amp;item)</code></p>
<p>如主函数26行，类初始化的参数也可以为一个类对象，该构造函数会直接将输入参数用于执行copy函数，相当于通过copy函数间接给类成员赋值。</p>
</li>
<li><p><code>person(istream &amp;in)</code></p>
<p>如27行，输入参数为一个IO类型的引用，需要注意此时read函数第二个参数为*this</p>
</li>
</ul>
<h2 id="构造函数初始值列表和赋值的区别"><a href="#构造函数初始值列表和赋值的区别" class="headerlink" title="构造函数初始值列表和赋值的区别"></a>构造函数初始值列表和赋值的区别</h2><p>之前我们讲到了构造函数对类成员的操作有两种：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">person</span>(string s1, string s2) &#123;name=s1;addr=s2;&#125;</span><br><span class="line"><span class="built_in">person</span>(string s1, string s2): <span class="built_in">name</span>(s1),<span class="built_in">addr</span>(s2) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>两个操作在效果上一样，但是第一种操作根源上为赋值，而第二种操作才是初始化，在大部分情况下二者区别不大但是如果当类成员为引用或者const类型时，此时将不能赋值，但是可以初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">person</span>(<span class="type">int</span> i) &#123;a=i;r=i&#125; <span class="comment">//错误的，不能给引用和常量赋值</span></span><br><span class="line">   <span class="built_in">person</span>(<span class="type">int</span> i): <span class="built_in">a</span>(i),<span class="built_in">r</span>(i) &#123;&#125; <span class="comment">//正确</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> &amp;r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="访问控制和封装"><a href="#访问控制和封装" class="headerlink" title="访问控制和封装"></a>访问控制和封装</h1><p>前面讲到了使用class和struct唯一区别是对类成员默认的访问权限不同，C++中可以使用访问说明符来管理类成员的访问权限以达到更好的封装。如果使用struct，则在第一个访问说明符前的成员默认为public，class则相反。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;	</span><br><span class="line">   <span class="keyword">public</span>: <span class="comment">//以下成员在整个程序中都可以被访问</span></span><br><span class="line">   <span class="built_in">person</span>()=<span class="keyword">default</span>;</span><br><span class="line">   <span class="built_in">person</span>(string s1, string s2) &#123;name=s1;addr=s2;&#125;</span><br><span class="line">   <span class="built_in">person</span>(person &amp;item) &#123;<span class="built_in">copy</span>(item);&#125;</span><br><span class="line">   <span class="built_in">person</span>(istream &amp;in) &#123;<span class="built_in">read</span>(in,*<span class="keyword">this</span>);&#125;  </span><br><span class="line">   <span class="keyword">private</span>: <span class="comment">//以下成员只可以被类的成员函数访问</span></span><br><span class="line">	string name;</span><br><span class="line">	string addr;</span><br><span class="line">   <span class="function">person&amp; <span class="title">copy</span><span class="params">(<span class="type">const</span> person &amp;x)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      name=x.name;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意，private说明符后的成员<strong>只可以被类的成员函数访问，</strong>像前面讲到的read和print函数不属于类的成员函数，因此无法访问private中的成员。</p>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>若想非类成员函数访问private内容,可以在类中<strong>使用friend关键字对其进行友元声明</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> istream &amp;<span class="title">read</span><span class="params">(istream &amp;in, person &amp;item)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">friend</span> ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;out, person &amp;item)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;in, person &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in&gt;&gt;item.name&gt;&gt;item.addr;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;out, person &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    out&lt;&lt;<span class="string">&quot;NAME: &quot;</span>&lt;&lt;item.name&lt;&lt;endl;</span><br><span class="line">    out&lt;&lt;<span class="string">&quot;ADDR: &quot;</span>&lt;&lt;item.addr&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>友元声明也适用于声明其他类及其成员函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">test</span>;</span><br><span class="line">   <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">test::test1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="关于类的静态成员"><a href="#关于类的静态成员" class="headerlink" title="关于类的静态成员"></a>关于类的静态成员</h1><p>在仔细阅读了书籍过后个人觉得用处不是特别大，如果以后用到了相关知识再在这里补充，目前就不写了。</p>
]]></content>
      
        
        <tags>
            
            <tag> C++学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51单片机汇编指令查询]]></title>
      <url>/2022/10/14/51%E5%8D%95%E7%89%87%E6%9C%BA%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
      <content type="html"><![CDATA[<h1 id="1、寻址"><a href="#1、寻址" class="headerlink" title="1、寻址"></a>1、寻址</h1><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p>寻找操作数的地址的各种方式。</p>
<h3 id="1-立即寻址"><a href="#1-立即寻址" class="headerlink" title="1.立即寻址"></a>1.立即寻址</h3><p>直接使用操作数将操作数存入相关地址中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV R0,#26H</span><br><span class="line">MOV DPTR,#2000H</span><br></pre></td></tr></table></figure>

<ul>
<li>立即数可以是8位或16位</li>
<li>立即数前必须加<code>#</code></li>
</ul>
<h3 id="2-直接寻址"><a href="#2-直接寻址" class="headerlink" title="2.直接寻址"></a>2.直接寻址</h3><p>将操作数视为地址，并将该地址存储的数据转递到相关地址中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV A,30H //相当于对30H进行解引用，将30H值传入A中</span><br></pre></td></tr></table></figure>

<h3 id="3-寄存器寻址"><a href="#3-寄存器寻址" class="headerlink" title="3.寄存器寻址"></a>3.寄存器寻址</h3><p>直接使用寄存器名字作为地址并对进行解引用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV A,R1 //*R1</span><br></pre></td></tr></table></figure>

<h3 id="4-寄存器间接寻址"><a href="#4-寄存器间接寻址" class="headerlink" title="4.寄存器间接寻址"></a>4.寄存器间接寻址</h3><p>指定寄存器的内容为操作数的地址，该地址存储的内容才是操作数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV A,@R0 // @R0相当于**R0</span><br></pre></td></tr></table></figure>

<ul>
<li>需使用间址符<code>@</code></li>
<li>对外部RAM进行读取时必须采用该方式</li>
</ul>
<h3 id="5-变址寻址"><a href="#5-变址寻址" class="headerlink" title="5.变址寻址"></a>5.变址寻址</h3><p>通过对基地址进行偏移获得当前操作数地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV A,#06H</span><br><span class="line">MOVC A,@A+PC</span><br></pre></td></tr></table></figure>

<p>由于这里（@A+PC）整体应为一个地址，所以这里要对<strong>A使用间址符取06H作为地址</strong>的偏移量，因此该两行指令的意思为：将（@A+PC）地址中存储的数据传入A中</p>
<h3 id="6-相对寻址"><a href="#6-相对寻址" class="headerlink" title="6.相对寻址"></a>6.相对寻址</h3><p>直接以PC作为基地址，只写出相对偏移量，有两种方式：</p>
<h4 id="无条件转移："><a href="#无条件转移：" class="headerlink" title="无条件转移："></a>无条件转移：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SJMP 08H //使PC转移至当前PC值+08H（当前PC为下一指令地址）</span><br></pre></td></tr></table></figure>

<h4 id="条件转移："><a href="#条件转移：" class="headerlink" title="条件转移："></a>条件转移：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JZ LOP //仅当（A）=0时执行，LOP为标号</span><br></pre></td></tr></table></figure>

<h3 id="7-位寻址"><a href="#7-位寻址" class="headerlink" title="7.位寻址"></a>7.位寻址</h3><h1 id="2、指令系统"><a href="#2、指令系统" class="headerlink" title="2、指令系统"></a>2、指令系统</h1><h2 id="1-数据传送指令"><a href="#1-数据传送指令" class="headerlink" title="1.数据传送指令"></a>1.数据传送指令</h2><ul>
<li>片内数据传送：MOV	访问内部RAM</li>
<li>片外数据传送：MOVX    访问外部RAM</li>
<li>程序存储器数据传送：MOVC    访问内外ROM</li>
</ul>
<h2 id="2-数据交换指令"><a href="#2-数据交换指令" class="headerlink" title="2.数据交换指令"></a>2.数据交换指令</h2><ul>
<li><p>字节交换（全部）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XCH A,Rn</span><br><span class="line">XCH A,@Ri //寄存器区只有R0和R1可用作间接寻址</span><br></pre></td></tr></table></figure>
</li>
<li><p>字节交换（低四位）：XCHD</p>
</li>
<li><p>字节交换（高低互换）：SWAP</p>
</li>
</ul>
<h2 id="3-堆栈操作指令"><a href="#3-堆栈操作指令" class="headerlink" title="3.堆栈操作指令"></a>3.堆栈操作指令</h2><ul>
<li>入栈：PUSH	SP先变化再压栈</li>
<li>出栈：POP      先出栈再变化SP</li>
</ul>
<h2 id="4-算术运算指令"><a href="#4-算术运算指令" class="headerlink" title="4.算术运算指令"></a>4.算术运算指令</h2><ul>
<li>加法<ul>
<li>不带进位： ADD</li>
<li>带进位（Cy）：ADDC</li>
<li>加一：INC</li>
</ul>
</li>
<li>减法<ul>
<li>不带进位：SUB</li>
<li>带进位：SUBB</li>
<li>减一：DEC</li>
</ul>
</li>
<li>乘法：MUL</li>
<li>除法：DIV</li>
</ul>
<h2 id="5-逻辑运算指令"><a href="#5-逻辑运算指令" class="headerlink" title="5.逻辑运算指令"></a>5.逻辑运算指令</h2><ul>
<li>逻辑与：ANL</li>
<li>逻辑或：ORL</li>
<li>逻辑异或：XRL</li>
<li>取反：CPL</li>
<li>清零：CLR</li>
<li>移位<ul>
<li>不带进位：RL&#x2F;RR 左移&#x2F;右移1位</li>
<li>带进位：RLC&#x2F;RRC ~</li>
</ul>
</li>
</ul>
<h2 id="6-位运算"><a href="#6-位运算" class="headerlink" title="6.位运算"></a>6.位运算</h2><p>该运算对象仅针对Cy和bit型对象</p>
<ul>
<li>位传送：MOV</li>
<li>置1：SETB</li>
<li>清0：CLR</li>
<li>取非：CPL</li>
<li>取与：ANL</li>
<li>取或：ORL</li>
</ul>
<h2 id="7-控制转移类指令"><a href="#7-控制转移类指令" class="headerlink" title="7.控制转移类指令"></a>7.控制转移类指令</h2><ul>
<li><p>无条件转移：LJMP  3字节，直接转移至该16位地址</p>
</li>
<li><p>相对转移：SJMP</p>
</li>
<li><p>条件转移：**(条件转移皆为相对PC的转移)**</p>
<ul>
<li><p>累加器<u><strong>判0</strong></u>：JZ&#x2F;JNZ</p>
</li>
<li><p>进位Cy判断：JC&#x2F;JNC</p>
</li>
<li><p>任意位判断：JB&#x2F;JNB&#x2F;JBC</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JB bit,rel</span><br><span class="line">// bit: 判断位  rel：偏移量</span><br></pre></td></tr></table></figure>
</li>
<li><p>比较<strong>不相等</strong>判断（不相等为满足条件）:CJNE</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CJNE A,#data,rel</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>减1<strong>不为0</strong>判断转移：DJNZ</p>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 嵌入式学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++的语句与函数]]></title>
      <url>/2022/10/11/C++-5/</url>
      <content type="html"><![CDATA[<h1 id="try语句与异常处理"><a href="#try语句与异常处理" class="headerlink" title="try语句与异常处理"></a>try语句与异常处理</h1><p>通常的异常处理包括三部分：</p>
<ul>
<li>throw表达式：使用throw表达式表示当前程序遇到了某个问题（异常声明）</li>
<li>try语句块：与catch配合用于处理各类异常声明</li>
<li>一套异常类：用于传递具体的异常信息（异常声明的含义）</li>
</ul>
<h2 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::runtime_error;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a!=b) <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;ERROR!!!&quot;</span>);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;good&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(runtime_error err)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;err.<span class="built_in">what</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="throw表达式"><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a!=b) <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;ERROR!!!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>格式：throw+异常类+初始化异常类对象</p>
<ul>
<li><p>该初始化的对象只用于提供一些关于异常的辅助信息（用户自行定义）</p>
</li>
<li><p>异常类为一系列在库中定义的类型，使用时需要声明其命名空间，以下是几种常用的异常类，在头文件stdexcept中</p>
<table>
<thead>
<tr>
<th align="center">exception</th>
<th align="center">一般错误</th>
</tr>
</thead>
<tbody><tr>
<td align="center">runtime_error</td>
<td align="center">运行时才能检测出的任务</td>
</tr>
<tr>
<td align="center">range_error</td>
<td align="center">运行时：生成结果超出有意义的值域范围的错误</td>
</tr>
<tr>
<td align="center">overflow_error</td>
<td align="center">运行时：计算上溢错误</td>
</tr>
<tr>
<td align="center">underflow_error</td>
<td align="center">运行时：计算下溢错误</td>
</tr>
<tr>
<td align="center">logic_error</td>
<td align="center">程序逻辑错误</td>
</tr>
<tr>
<td align="center">domain_error</td>
<td align="center">逻辑错误：参数对应的结果不存在</td>
</tr>
<tr>
<td align="center">invalid_error</td>
<td align="center">逻辑错误：无效参数</td>
</tr>
<tr>
<td align="center">length_error</td>
<td align="center">逻辑错误：超出对象类型长度</td>
</tr>
<tr>
<td align="center">out_of_range</td>
<td align="center">逻辑错误：超出有效范围</td>
</tr>
</tbody></table>
<ul>
<li><p>除exception外其他类型都<strong>必须</strong>用一个字符串初始化，而exception则不允许这种初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(a!=b) <span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;good&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(exception)</span><br><span class="line">&#123;</span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;ERROR!!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="try语句块"><a href="#try语句块" class="headerlink" title="try语句块"></a>try语句块</h2><p>格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123; &#125;<span class="comment">//程序正常逻辑，异常类在此throw出 </span></span><br><span class="line"><span class="built_in">catch</span>(异常声明)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="built_in">catch</span>(异常声明)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当try内一旦提出异常类时，就不再执行该throw表达式后的内容；反之，若没有throw任何异常，则不会触发任何catch语句，程序正常执行完try语句。</li>
<li>catch括号中需定义一个对象，类型为触发的异常类，这些异常类只有一个子函数what，用于输出初始化时的字符串（不能用于exception类）</li>
</ul>
<p>当有多个try语句块嵌套时，当最内部try提出了一个异常，会由内到外执行catch，若最终都没有对应catch，则程序转到terminate的标准库函数，该函数行为与系统有关，通常执行该函数会导致程序非正常退出。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><ul>
<li>形参实参之间的转递为值拷贝</li>
<li>C++中建议用引用类型的形参代替指针形参，引用类型同样可以达到修改值的内容，并且可以避免拷贝，因为引用是与实参绑定的。</li>
</ul>
<h2 id="数组的传递"><a href="#数组的传递" class="headerlink" title="数组的传递"></a>数组的传递</h2><p>以下三种对形参的定义是等价的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">(<span class="type">const</span> <span class="type">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">b</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">c</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p>编译器在编译时只会检查传入的参数类型是否为const int*型，甚至不会检查传入数组的长度是否超出形参大小。</p>
<h3 id="数组的引用形参"><a href="#数组的引用形参" class="headerlink" title="数组的引用形参"></a>数组的引用形参</h3><p>可以使用数组的引用作为形参：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> (&amp;arr)[<span class="number">10</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">auto</span> elem : arr)</span><br><span class="line">      cout&lt;&lt;elem&lt;&lt;endl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用数组的引用作为形参需要注意：</p>
<ul>
<li>初始化时必须使用括号括起&amp;arr</li>
<li>输入的实参<strong>必须为一个int [10]类型</strong>的对象</li>
</ul>
<h2 id="函数的返回类型"><a href="#函数的返回类型" class="headerlink" title="函数的返回类型"></a>函数的返回类型</h2><h3 id="返回引用"><a href="#返回引用" class="headerlink" title="返回引用"></a>返回引用</h3><p>函数返回引用可以理解为返回的为一个地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> <span class="title">test1</span><span class="params">(string s ,string::size_type num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> s[num];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> &amp;<span class="title">test2</span><span class="params">(string &amp;s ,string::size_type num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> s[num];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">srting <span class="title">s</span><span class="params">(<span class="string">&quot;test&quot;</span>)</span></span>;</span><br><span class="line">   cout&lt;&lt;<span class="built_in">test1</span>(s,<span class="number">0</span>)&lt;&lt;endl; <span class="comment">//t</span></span><br><span class="line">   <span class="built_in">test2</span>(s,<span class="number">0</span>)=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">   cout&lt;&lt;s[<span class="number">0</span>]&lt;&lt;endl;       <span class="comment">//a</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个函数的返回值为引用时，该返回值为左值而非右值，因此可以像使用其他左值一样使用这个返回值</p>
<p>（注：左值≠地址，它仍然是一个值）</p>
<ul>
<li><p><strong>不可返回局部变量的引用</strong>，由于局部变量在函数完成后会被释放，因此在函数完成后引用会找不到它的对象。例如上一个例程，如果把test2()函数改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> &amp;<span class="title">test2</span><span class="params">(string s ,string::size_type num)</span><span class="comment">//此处形参不再是引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> s[num];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">srting <span class="title">s</span><span class="params">(<span class="string">&quot;test&quot;</span>)</span></span>;</span><br><span class="line">   <span class="built_in">test2</span>(s,<span class="number">0</span>)=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">   cout&lt;&lt;s[<span class="number">0</span>]&lt;&lt;endl;      <span class="comment">//t</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的返回值为对s的引用，但s本身为一个局部变量，在函数完成时已经被释放，因此该引用是无效的（但是这样<strong>返回形参的引用</strong>编译器并不会报错，而返回<strong>函数内定义的局部变量</strong>的引用会报错）</p>
<p>但如果形参定义为引用，由于引用本身是不占用存储空间的，所以’a’可以通过引用直接向s[0]赋值</p>
</li>
</ul>
<h3 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a>返回数组指针</h3><ul>
<li><p>尾置返回类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[10]</span></span><br></pre></td></tr></table></figure>

<p>声明函数的返回值为一个含有十个整数的数组的指针</p>
</li>
<li><p>使用decltype</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> test[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(test) *<span class="built_in">func</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;test;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	cout&lt;&lt;*(*func+<span class="number">1</span>); <span class="comment">//输出2</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>decltype(test)的结果是一个数组，因此函数前要用*声明返回值为指针</li>
<li>使用此方法返回的是一个数组的整体地址，而不是首地址，类型为int*[5]，因此一次解引用的结果才是首地址</li>
</ul>
</li>
</ul>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>正常的调用函数一般比等价的表达式要慢（保存寄存器、拷贝等操作），因此对于规模较小的函数可以定义为内联函数类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">fuc</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h2><p>将函数隐式地定义为内联函数，但函数内只能有一条return语句，且返回值必须为字面值</p>
]]></content>
      
        
        <tags>
            
            <tag> C++学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++_表达式]]></title>
      <url>/2022/10/03/C++-4/</url>
      <content type="html"><![CDATA[<h1 id="1、基础内容"><a href="#1、基础内容" class="headerlink" title="1、基础内容"></a>1、基础内容</h1><p>表达式是<strong>由一个或多个运算对象组成</strong>，对表达式求值得到的是一个<strong>结果</strong>，字面值和变量时最简单的表达式。</p>
<h2 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h2><p>当一个对象被用作右值时，使用的是该对象的值；而被用作左值时，使用的时对象的内存。</p>
<ul>
<li>赋值运算符需要一个非常量左值为其左侧运算对象</li>
<li>取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，该指针为右值</li>
<li>解引用求值结果为左值</li>
</ul>
<h2 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h2><p>部分运算符是没有明确指明执行顺序的，例如&lt;&lt;运算符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;i&lt;&lt;<span class="string">&quot;&quot;</span>&lt;&lt;++i;</span><br></pre></td></tr></table></figure>

<p>++i和i没有明确的先后关系，因此编译器可能做出任何行为。</p>
<p>当多个函数会影响同一对象时，当同时调用这些函数时，调用函数的顺序也没有明确的先后关系。</p>
<h1 id="2、算术运算符"><a href="#2、算术运算符" class="headerlink" title="2、算术运算符"></a>2、算术运算符</h1><h2 id="bool类型"><a href="#bool类型" class="headerlink" title="bool类型"></a>bool类型</h2><p>bool类型原则不应参与运算，在运算时会自动转化为int型的1，只要计算结果不为0，都将返回ture</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>C++大部分同优先级运算都满足从左至右的规律，赋值则相反</p>
<h2 id="递增运算"><a href="#递增运算" class="headerlink" title="递增运算"></a>递增运算</h2><p>C++中，<strong>非必要不使用</strong>后置递增&#x2F;减符（i++&#x2F;i–)，因为前置运算为将对象本身作为左值返回，而后置则要额外的空间存储原始值，并将这个额外存储的原始值副本作为右值返回，因此，使用后置操作会消耗更多内存，这在相对复杂的工作中是消耗巨大的。</p>
<h2 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h2><p>关于符号位的处理没有明确规定，因此位运算最好用来处理无符号类型</p>
<h1 id="3、类型转换"><a href="#3、类型转换" class="headerlink" title="3、类型转换"></a>3、类型转换</h1><p>C++的类型转换格式不同于C：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast-name&lt;类型&gt;(表达式)</span><br></pre></td></tr></table></figure>

<p>最常用的cast-name为<code>static_cast</code>和<code>const_cast</code></p>
<h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>任何有明确定义的类型转换（除了底层const）都可以使用static_cast</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *p = &amp;d;<span class="comment">//d不能为常量（底层const）</span></span><br><span class="line"><span class="type">double</span> *dp = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>*&gt;(p);</span><br></pre></td></tr></table></figure>

<h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p><strong>专用</strong>于改变底层const，其作用为改变const性质</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* pc;</span><br><span class="line"><span class="type">char</span> *p=<span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(pc);</span><br></pre></td></tr></table></figure>

<p>需要注意，可以有以下用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* pc;</span><br><span class="line"><span class="type">char</span> *p=<span class="built_in">const_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(pc);</span><br></pre></td></tr></table></figure>

]]></content>
      
        
        <tags>
            
            <tag> C++学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python_2]]></title>
      <url>/2022/09/16/python-2/</url>
      <content type="html"><![CDATA[<h1 id="开始编程"><a href="#开始编程" class="headerlink" title="开始编程"></a>开始编程</h1><h2 id="1、条件控制"><a href="#1、条件控制" class="headerlink" title="1、条件控制"></a>1、条件控制</h2><p>一般形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1:</span><br><span class="line">    statement_block_1</span><br><span class="line"><span class="keyword">elif</span> condition_2:</span><br><span class="line">    statement_block_2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement_block_3</span><br></pre></td></tr></table></figure>

<ul>
<li>记得在条件后加<code>:</code></li>
<li>Python 中用 <strong>elif</strong> 代替了 <strong>else if</strong>，所以if语句的关键字为：<strong>if – elif – else</strong></li>
<li>python中没有switch语句</li>
</ul>
<h2 id="2、循环语句"><a href="#2、循环语句" class="headerlink" title="2、循环语句"></a>2、循环语句</h2><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><p>可以与else配合使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while &lt;expr&gt;:</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line">else:</span><br><span class="line">    &lt;additional_statement(s)&gt;</span><br></pre></td></tr></table></figure>

<h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><p>一般格式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;dhk&#x27;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> a: </span><br><span class="line">	<span class="built_in">print</span>(x,end=<span class="string">&#x27;&#x27;</span>) <span class="comment">#dhk</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;error!!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>不同于C，python的for语句常用来遍历某个可迭代对象，如列表、字符串，如上的循环中，x每次只取遍历对象的<strong>最基本单位并自动递增</strong>。</p>
<h3 id="range函数"><a href="#range函数" class="headerlink" title="range函数"></a>range函数</h3><p>生成一个数字序列，格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>):</span><br><span class="line">   <span class="built_in">print</span>(x,end=<span class="string">&#x27;&#x27;</span>)<span class="comment">#13579</span></span><br></pre></td></tr></table></figure>

<p>range函数的指定区间同样<strong>遵循左闭右开</strong>的原则</p>
<h3 id="pass语句"><a href="#pass语句" class="headerlink" title="pass语句"></a>pass语句</h3><p>空语句，表示空</p>
<h2 id="3、迭代器"><a href="#3、迭代器" class="headerlink" title="3、迭代器"></a>3、迭代器</h2><p>迭代是Python最强大的功能之一，是<strong>访问集合元素的一种方式</strong>。</p>
<p>迭代器是一个<strong>可以记住遍历的位置</strong>的对象。</p>
<p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    it = <span class="built_in">iter</span>(<span class="built_in">list</span>)  <span class="comment"># 创建迭代器对象</span></span><br><span class="line">    it2 = <span class="built_in">iter</span>(<span class="built_in">list</span>)  <span class="comment"># 创建迭代器对象</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">        <span class="keyword">if</span> x != <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">print</span>(x, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(x)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(it2))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(it2))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(it2))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(it2))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1 2 3 4</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="把一个类作为迭代器使用："><a href="#把一个类作为迭代器使用：" class="headerlink" title="把一个类作为迭代器使用："></a>把一个类作为迭代器使用：</h3><p>若想把一个类作为迭代器使用，需要在类中实现两个方法：</p>
<ul>
<li><p><code>__iter__()</code>:返回一个特殊的迭代器对象， 这个迭代器对象实现了 <strong>next</strong>() 方法并通过 StopIteration 异常标识迭代的完成。</p>
</li>
<li><p><code>__next__()</code>:返回下一个迭代器对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">class</span> <span class="title class_">MyNumbers</span>:</span><br><span class="line">       <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">           self.a = <span class="number">1</span></span><br><span class="line">           <span class="keyword">return</span> self</span><br><span class="line">  </span><br><span class="line">       <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">           <span class="keyword">if</span> self.a &lt;= <span class="number">20</span>:</span><br><span class="line">               x = self.a</span><br><span class="line">               self.a += <span class="number">1</span></span><br><span class="line">               <span class="keyword">return</span> x</span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               <span class="keyword">raise</span> StopIteration <span class="comment">#挂起StopIteration标志迭代完成，不能用return</span></span><br><span class="line">   a = MyNumbers()</span><br><span class="line">   i = <span class="built_in">iter</span>(a)</span><br><span class="line">   <span class="keyword">for</span> x <span class="keyword">in</span> i:</span><br><span class="line">       <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="comment">#1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 </span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4、生成器"><a href="#4、生成器" class="headerlink" title="4、生成器"></a>4、生成器</h2><p> 在 Python 中，使用了 yield 的函数被称为生成器（generator）。</p>
<p>在调用生成器运行的过程中，<strong>每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值</strong>, 并在下一次执行 next() 方法时从当前位置继续运行。</p>
<ul>
<li>生成器函数返回的是一个<strong>迭代器对象</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>): <span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n): </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">f = fibonacci(<span class="number">10</span>) <span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(f), end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure>

<h2 id="5、函数"><a href="#5、函数" class="headerlink" title="5、函数"></a>5、函数</h2><p>规则：</p>
<ul>
<li>函数代码块以 <strong>def</strong> 关键词开头，后接函数标识符名称和圆括号 **()**。</li>
<li>函数内容以冒号 <strong>:</strong> 起始，并且缩进。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def 函数名（参数列表）:</span><br><span class="line">    函数体</span><br></pre></td></tr></table></figure>

<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>在调用函数时，实参可以是key&#x3D;value的形式，称为关键字参数。</p>
<p>凡是按照这种形式定义的实参，可以不按照从左到右的顺序定义，但仍能为指定的形参赋值。</p>
<ul>
<li><p><strong>关键字参数在位置参数后面</strong>，因为python函数在解析参数时，是按照顺序来的，<strong>位置参数</strong>是必须先满足，才考虑其他可变参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params">age, name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;名字: &quot;</span>, name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;年龄: &quot;</span>, age)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  </span><br><span class="line">printinfo(<span class="number">50</span>, name=<span class="string">&quot;runoob&quot;</span>) <span class="comment">#age为位置参数，name为关键字参数</span></span><br></pre></td></tr></table></figure>

<p>需要注意：</p>
<ul>
<li><strong>位置参数的输入必须和定义时的位置相同</strong></li>
<li><strong>关键字参数的输入必须在位置参数之后</strong></li>
</ul>
</li>
</ul>
<h3 id="当参数不定长时"><a href="#当参数不定长时" class="headerlink" title="当参数不定长时"></a>当参数不定长时</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> arg1, *vartuple </span>):</span><br></pre></td></tr></table></figure>

<p>加了星号 ***** 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数</p>
<p>当参数添加双星号******时，传入的参数将以字典的形式保存</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">**dic</span>)</span><br><span class="line">	<span class="built_in">print</span>(dic)</span><br><span class="line">func(**&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment">#or</span></span><br><span class="line">func(a=<span class="number">1</span>,b=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>Python 使用 <strong>lambda</strong> 来创建匿名函数</p>
<ul>
<li>lambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="built_in">sum</span> = <span class="keyword">lambda</span> arg1, arg2: arg1 + arg2</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用sum函数</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;相加后的值为 : &quot;</span>, <span class="built_in">sum</span>( <span class="number">10</span>, <span class="number">20</span> ))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;相加后的值为 : &quot;</span>, <span class="built_in">sum</span>( <span class="number">20</span>, <span class="number">20</span> ))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">30</span></span><br><span class="line"><span class="string">40</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="强制位置参数＆命名关键字参数"><a href="#强制位置参数＆命名关键字参数" class="headerlink" title="强制位置参数＆命名关键字参数"></a>强制位置参数＆命名关键字参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a, b, c成为限定位置形参</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b, c, /, d</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这时参数kw1, kw2必须传入关键字参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">其他形参, *, kw1, kw2</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="6、类"><a href="#6、类" class="headerlink" title="6、类"></a>6、类</h2><p>Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。</p>
<p>定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    i = <span class="number">12345</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):<span class="comment">#类中的函数称作类的方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br></pre></td></tr></table></figure>

<p>类的初始化（构造方法）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>:</span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n, a</span>): <span class="comment">#类的方法必须包含self，且其必须为第一个参数</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br></pre></td></tr></table></figure>

<p>创建一个类的实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = MyClass()</span><br></pre></td></tr></table></figure>

<p>访问类的属性、方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;MyClass 类的属性 i 为：&quot;</span>, x.i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;MyClass 类的方法 f 输出为：&quot;</span>, x.f())</span><br></pre></td></tr></table></figure>

<h4 id="类的继承："><a href="#类的继承：" class="headerlink" title="类的继承："></a>类的继承：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span>:</span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,a,w</span>):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>(<span class="title class_ inherited__">people</span>):</span><br><span class="line">    grade = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,a,w,g</span>):</span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(self.name,self.age,self.grade))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">s = student(<span class="string">&#x27;ken&#x27;</span>,<span class="number">10</span>,<span class="number">60</span>,<span class="number">3</span>)</span><br><span class="line">s.speak()</span><br></pre></td></tr></table></figure>

<ul>
<li>子类中若出现了父类同名的方法，则在调用该子类方法时使用的内容也是子类中定义的内容</li>
</ul>
<p>私有属性与方法：</p>
<p>在方法或属性的开头加两个下划线，<strong>声明</strong>（不包含在变量名中）该属性为私有，不能在类的外部被使用或直接访问</p>
<h1 id="文件间的引用"><a href="#文件间的引用" class="headerlink" title="文件间的引用"></a>文件间的引用</h1><h2 id="1、import语句"><a href="#1、import语句" class="headerlink" title="1、import语句"></a>1、import语句</h2><p>想使用一个 Python 源文件，只需在另一个源文件里执行 import 语句导入该模块</p>
<ul>
<li>一个模块只会被导入一次，不管你执行了多少次 <strong>import</strong>。这样可以防止导入模块被一遍又一遍地执行。</li>
</ul>
<h2 id="2、from-import语句"><a href="#2、from-import语句" class="headerlink" title="2、from..import语句"></a>2、from..import语句</h2><p>从模块中导入指定的部分，例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> test_file <span class="keyword">import</span> test_fuction1,test_fuction2</span><br><span class="line"><span class="comment">#从test_file.py中导入两个函数</span></span><br></pre></td></tr></table></figure>

<h2 id="3、使用模块中的变量、函数"><a href="#3、使用模块中的变量、函数" class="headerlink" title="3、使用模块中的变量、函数"></a>3、使用模块中的变量、函数</h2><p>通过 modname.itemname 这样的表示法来访问模块内的函数</p>
]]></content>
      
        
        <tags>
            
            <tag> python学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++字符串、向量和数组]]></title>
      <url>/2022/09/15/C++-3/</url>
      <content type="html"><![CDATA[<h1 id="字符串、向量和数组"><a href="#字符串、向量和数组" class="headerlink" title="字符串、向量和数组"></a>字符串、向量和数组</h1><h2 id="1、using声明"><a href="#1、using声明" class="headerlink" title="1、using声明"></a>1、using声明</h2><p>作用：使用using声明命名空间的相关成员后，后续不需再声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">cin&gt;&gt;i;</span><br></pre></td></tr></table></figure>

<ul>
<li>每个名字都需要独立的using声明</li>
</ul>
<h2 id="2、string类型"><a href="#2、string类型" class="headerlink" title="2、string类型"></a>2、string类型</h2><ul>
<li>使用前需包含头文件<code>&lt;string&gt;</code>(没有.h)，且需声明string定义于命名空间中</li>
</ul>
<h3 id="初始化string类型的方法"><a href="#初始化string类型的方法" class="headerlink" title="初始化string类型的方法"></a>初始化string类型的方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s1;</span><br><span class="line">string s2=s1;</span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(<span class="string">&quot;value&quot;</span>)</span></span>;</span><br><span class="line">string s3 =<span class="string">&quot;value&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(n,<span class="string">&#x27;c&#x27;</span>)</span></span>;<span class="comment">//此处只能为字符</span></span><br></pre></td></tr></table></figure>

<h3 id="读写string对象"><a href="#读写string对象" class="headerlink" title="读写string对象"></a>读写string对象</h3><p>当要将标准输入内容读取到一个string对象时，string对象会自动忽略开头的空白（空格、换行等），从第一个真正的字符开始，直到遇到遇到下一个空白（但读取结束的标准是换行）</p>
<h3 id="使用getline函数读取一整行"><a href="#使用getline函数读取一整行" class="headerlink" title="使用getline函数读取一整行"></a>使用getline函数读取一整行</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(cin,s);</span><br></pre></td></tr></table></figure>

<p>getline只有当读取到换行符时才会结束，并且这个换行符会被丢弃。</p>
<h3 id="相加问题"><a href="#相加问题" class="headerlink" title="相加问题"></a>相加问题</h3><p>string对象可以相加，string对象也可以与字面值相加，<strong>但字面值不能与字面值相加！</strong></p>
<h3 id="单独处理字符"><a href="#单独处理字符" class="headerlink" title="单独处理字符"></a>单独处理字符</h3><p>C++11提供了一种语句：范围for</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string <span class="built_in">str</span>(<span class="string">&quot;something&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(auto c:<span class="built_in">str</span>)	cout&lt;&lt;c&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<ul>
<li>每次循环中，都会把序列中的<strong>基础元素</strong>存入c中</li>
</ul>
<p>还可以通过引用等方式单独改变字符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;something&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:str)	c=<span class="built_in">toupper</span>(c);<span class="comment">//大写转换函数</span></span><br></pre></td></tr></table></figure>

<h3 id="下标问题"><a href="#下标问题" class="headerlink" title="下标问题"></a>下标问题</h3><p>C++支持对字符串使用下标运算符<code>[]</code>访问字符串的单个字符，规则同python，但貌似C++不支持截取。</p>
<h2 id="3、vector类型"><a href="#3、vector类型" class="headerlink" title="3、vector类型"></a>3、vector类型</h2><p>要想使用vector，需包含<code>&lt;vector&gt;</code>头文件。<strong>类型vector表示对象的集合</strong></p>
<p>实例化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; b;</span><br></pre></td></tr></table></figure>

<h3 id="定义与初始化"><a href="#定义与初始化" class="headerlink" title="定义与初始化"></a>定义与初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(b)</span></span>; <span class="comment">//a包含b中所有元素的副本 a和b的类型需相同</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a=b;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n,val)</span></span>; <span class="comment">//a中有n个重复的val</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>; <span class="comment">//包含n个对象</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a&#123;A,B,C&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a=&#123;A,B,C&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="向vector对象尾部添加元素"><a href="#向vector对象尾部添加元素" class="headerlink" title="向vector对象尾部添加元素"></a>向vector对象尾部添加元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">a.<span class="built_in">push_back</span>(<span class="number">1</span>);<span class="comment">//a=&#123;1&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">empty</span>(); <span class="comment">//如果a不含元素则返回真</span></span><br><span class="line">a.<span class="built_in">size</span>(); <span class="comment">//返回元素个数</span></span><br></pre></td></tr></table></figure>

<p>其他的类函数参考书p91</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>vector对象同样支持使用下标运算符进行单个元素的索引，但不能通过下标添加元素。</p>
<h2 id="4、迭代器"><a href="#4、迭代器" class="headerlink" title="4、迭代器"></a>4、迭代器</h2><p>迭代器（iterator）是一种可以遍历容器元素的数据类型。迭代器是一个变量，相当于容器和操纵容器的算法之间的中介。<strong>C++更趋向于使用迭代器而不是数组下标操作</strong>，因为标准库为每一种标准容器（如vector、map和list等）定义了一种迭代器类型，而只有少数容器（如vector）支持数组下标操作访问容器元素。可以通过迭代器指向你想访问容器的元素地址，通过*x打印出元素值。这和我们所熟知的指针极其类似。</p>
<p>C语言有指针，指针用起来十分灵活高效。<br>C++语言有迭代器，迭代器相对于指针而言功能更为丰富。</p>
<h3 id="迭代器的使用"><a href="#迭代器的使用" class="headerlink" title="迭代器的使用"></a>迭代器的使用</h3><p>可以看出，迭代器的基本使用和指针极其相似</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;string&gt; v&#123;<span class="string">&quot;aaaa&quot;</span>,<span class="string">&quot;bbbb&quot;</span>&#125;;</span><br><span class="line">	<span class="keyword">auto</span> i=v.<span class="built_in">begin</span>();</span><br><span class="line">	cout&lt;&lt;*(i+<span class="number">1</span>); <span class="comment">//bbbb</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器运算符"><a href="#迭代器运算符" class="headerlink" title="迭代器运算符"></a>迭代器运算符</h3><ul>
<li><p>获得迭代器所指元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*iter  <span class="keyword">or</span>  iter-&gt;mem</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取迭代器长度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i.<span class="built_in">end</span>()-i.<span class="built_in">begin</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v&#123;<span class="string">&quot;aaaa&quot;</span>,<span class="string">&quot;bbbb&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> i=v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//vector&lt;string&gt;::iterator i; 类型</span></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;12345&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> i=str.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//string::iterator i; 类型</span></span><br><span class="line"></span><br><span class="line">对应的只读类型</span><br><span class="line"><span class="comment">//vector&lt;string&gt;::const_iterator v;</span></span><br><span class="line"><span class="comment">//string::const_iterator str;</span></span><br></pre></td></tr></table></figure>

<h3 id="当需要对迭代器进行遍历时，需注意for循环的条件3："><a href="#当需要对迭代器进行遍历时，需注意for循环的条件3：" class="headerlink" title="当需要对迭代器进行遍历时，需注意for循环的条件3："></a>当需要对迭代器进行遍历时，需注意for循环的条件3：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> i=v.<span class="built_in">begin</span>(); i !=v.<span class="built_in">end</span>(); ++i)<span class="comment">//应使用++i，这是因为end为元素10之后的位置	</span></span><br><span class="line">	&#123;</span><br><span class="line">		*i=*i*<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> a:v) cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、数组"><a href="#5、数组" class="headerlink" title="5、数组"></a>5、数组</h2><p>大部分规定与C相同。</p>
<ul>
<li><p>定义数组时不允许用auto关键字由初始值推断类型。</p>
</li>
<li><p>可使用decltype(数组名)定义数组类型。</p>
</li>
<li><p><strong>数组不是类类型，因此没有成员函数。</strong></p>
<p>因此C++11引入了begin、end函数来查询数组相关元素的<strong>地址</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p=<span class="built_in">begin</span>(a);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意：end()和vector类型的子函数.end()不同，end()函数返回的是数组最后一个元素的地址，而vector类型的end子函数返回的是最后一个元素的后一位地址</p>
<h3 id="单个元素类型"><a href="#单个元素类型" class="headerlink" title="单个元素类型"></a>单个元素类型</h3><p>通常对数组的单个类型定义为size_t型，该类型为一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小</p>
<p><strong>要使用该类型，应包含cstddef头文件</strong></p>
<h3 id="C与C-的字符串风格"><a href="#C与C-的字符串风格" class="headerlink" title="C与C++的字符串风格"></a>C与C++的字符串风格</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">10</span>]=<span class="string">&quot;dhk&quot;</span>; <span class="comment">//C风格</span></span><br><span class="line"><span class="function">string <span class="title">a</span><span class="params">(<span class="string">&quot;dhk&quot;</span>)</span></span>;	<span class="comment">//C++风格</span></span><br></pre></td></tr></table></figure>

<p>在C中，通常我们要对字符串进行一些例如比较、拷贝、连接等的操作时，通常使用的是标准库中的相关字符串长度，相较于C++中string类型的变量可以对存放字符串的变量直接进行运算等操作，C的字符串风格更加繁琐，且极容易在数组的内存方面引发严重问题</p>
<h4 id="混用规则："><a href="#混用规则：" class="headerlink" title="混用规则："></a>混用规则：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">a</span><span class="params">(<span class="string">&quot;dhk&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">char</span> *str=a;<span class="comment">//错误，a的类型为string，而str类型为char*，冲突</span></span><br><span class="line"><span class="type">char</span> *str=a.<span class="built_in">c_str</span>();<span class="comment">//正确。c_str()函数返回的是C风格字符串（一个地址）</span></span><br></pre></td></tr></table></figure>

<p>上述用法相当于是<strong>又</strong>在内存中创建了一个”dhk”字符串，而用于找到该字符串的指针一旦改变，该字符串就将不能再被找到，因此通常对存放该类型的指针进行const操作。其规则类似C中的<code>char *str=&quot;dhk&quot;</code>所遵循的规则。</p>
<h3 id="使用数组初始化vector类型"><a href="#使用数组初始化vector类型" class="headerlink" title="使用数组初始化vector类型"></a>使用数组初始化vector类型</h3><p>C++不允许用一个数组为另一个数组赋初值，也不允许通过vector类型对象为一个数组初始化，但是允许通过数组为vector对象初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(begin(a),end(a))</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="6、多维数组"><a href="#6、多维数组" class="headerlink" title="6、多维数组"></a>6、多维数组</h2><p>一些基础内容同C，详见<u>二维数组复习 | 小董的BLOG (gitee.io)</u></p>
<p>多维数组可以理解为数组的数组例如<code>int a[3][4]</code>可以理解为a数组包含三个元素，而这三个元素都为大小为4的数组</p>
<h3 id="下标引用"><a href="#下标引用" class="headerlink" title="下标引用"></a>下标引用</h3><h3 id="使用范围for语句和下标引用处理多维数组"><a href="#使用范围for语句和下标引用处理多维数组" class="headerlink" title="使用范围for语句和下标引用处理多维数组"></a>使用范围for语句和下标引用处理多维数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">size_t</span> x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;row : a)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;col : row)</span><br><span class="line">	&#123;</span><br><span class="line">		col=x;</span><br><span class="line">		x++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        
        <tags>
            
            <tag> C++学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python_1]]></title>
      <url>/2022/09/14/python-1/</url>
      <content type="html"><![CDATA[<h1 id="1、基本数据类型"><a href="#1、基本数据类型" class="headerlink" title="1、基本数据类型"></a>1、基本数据类型</h1><ul>
<li>变量不需要声明，也没有类型。</li>
<li>python允许同时给多个变量赋值</li>
</ul>
<h2 id="标准数据类型："><a href="#标准数据类型：" class="headerlink" title="标准数据类型："></a>标准数据类型：</h2><ul>
<li>Number</li>
<li>String</li>
<li>List</li>
<li>Tuple（元组）</li>
<li>Set（集合）</li>
<li>Dictionary（字典）</li>
</ul>
<h3 id="1、Number（数字）"><a href="#1、Number（数字）" class="headerlink" title="1、Number（数字）"></a>1、Number（数字）</h3><p>Python3 支持 int、float、bool、<strong>complex（复数）</strong>。</p>
<ul>
<li>可使用type(<em>变量</em> )函数查询变量类型</li>
<li>可用isinstance(<em>变量，类型</em> )判断变量是否为想要的类型，为真返回Ture</li>
</ul>
<p>del 语句可用删除对对象的引用</p>
<p>在数值的计算中，<code>/</code>返回浮点数，<code>//</code>返回整数，在混合计算时会把整数转化为浮点数</p>
<ul>
<li><code>//</code>返回的不一定是整型的数，这与分母分子的类型有关</li>
</ul>
<p>python可以使用<code>**</code>来进行幂运算，如5的平方：<code>5**2</code></p>
<ul>
<li><strong>number为不可变类型，</strong>例如变量赋值 <strong>a&#x3D;5</strong> 后再赋值 <strong>a&#x3D;10</strong>，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a</li>
</ul>
<h3 id="2、String（字符串）"><a href="#2、String（字符串）" class="headerlink" title="2、String（字符串）"></a>2、String（字符串）</h3><p>python中的字符串可用单引号或双引号括起来</p>
<p>字符串的截取：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#变量[头下标:尾下标:截取步长]</span></span><br><span class="line"><span class="comment">#若截取步长为负数则逆向读取</span></span><br><span class="line"><span class="comment">#第一个字符索引值为0，末尾字符为-1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;dhk&quot;</span>*<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;dhk&quot;</span>+<span class="string">&quot;dhk&quot;</span>)</span><br><span class="line"><span class="comment">#dhkdhk</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字符串的截取遵循<strong>左闭右开</strong>的原则</li>
<li>字符索引：变量[索引下标]</li>
<li>屏蔽转义字符：在字符串前（引号外）添加一个r</li>
<li><strong>python字符串不能被改变，也就是说不能给单个索引位置赋值</strong></li>
</ul>
<p>字符串的格式化：<code>print(&quot;%s %d&quot; % (&#39;abc&#39;, 10))</code></p>
<h4 id="f-string"><a href="#f-string" class="headerlink" title="f-string"></a>f-string</h4><p> 格式化字符串以 <strong>f</strong> 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">&#x27;Runoob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;Hello <span class="subst">&#123;name&#125;</span>&#x27;</span>  <span class="comment"># 替换变量</span></span><br><span class="line"><span class="string">&#x27;Hello Runoob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;<span class="subst">&#123;<span class="number">1</span>+<span class="number">2</span>&#125;</span>&#x27;</span>         <span class="comment"># 使用表达式</span></span><br><span class="line"><span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;<span class="subst">&#123;w[<span class="string">&quot;name&quot;</span>]&#125;</span>: <span class="subst">&#123;w[<span class="string">&quot;url&quot;</span>]&#125;</span>&#x27;</span></span><br><span class="line"><span class="string">&#x27;Runoob: www.runoob.com&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="3、List（列表）"><a href="#3、List（列表）" class="headerlink" title="3、List（列表）"></a>3、List（列表）</h3><p>定义方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">10.1</span>,<span class="string">&#x27;abcd&#x27;</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>基本使用同字符串，也可以索引、截取，使用步长截取（包括逆向）等。</li>
<li><strong>列表内的元素可改变！</strong></li>
<li>逆向读取不会将元素内容逆向</li>
</ul>
<h4 id="更新列表："><a href="#更新列表：" class="headerlink" title="更新列表："></a>更新列表：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br><span class="line">list1.append(<span class="string">&#x27;Baidu&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;更新后的列表 : &quot;</span>, list1)	<span class="comment">#更新后的列表 :  [&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;, &#x27;Baidu&#x27;]</span></span><br></pre></td></tr></table></figure>

<h4 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> <span class="built_in">list</span>[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h3 id="4、Tuple（元组）"><a href="#4、Tuple（元组）" class="headerlink" title="4、Tuple（元组）"></a>4、Tuple（元组）</h3><p>定义方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=(<span class="number">1</span>,<span class="number">10.1</span>,<span class="string">&#x27;abcd&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>基本使用同字符串，也可以索引、截取，使用步长截取（包括逆向）等。</p>
</li>
<li><p>元组在输入时可能没有括号，例如<code>t = 12345, 54321, &#39;hello!&#39;</code></p>
</li>
<li><p><strong>元组内元素不可改变，但可以包含可变的对象，比如列表</strong></p>
</li>
<li><p>包含0和1个的元组有额外的语法规则：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tup1 = ()    <span class="comment"># 空元组</span></span><br><span class="line">tup2 = (<span class="number">20</span>,) <span class="comment"># 一个元素，需要在元素后添加逗号,否则括号会被当作运算符使用</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5、Set（集合）"><a href="#5、Set（集合）" class="headerlink" title="5、Set（集合）"></a>5、Set（集合）</h3><p>定义方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=() <span class="comment">#空集合需用小括号</span></span><br><span class="line">b=&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">c=<span class="built_in">set</span>(<span class="string">&#x27;abcde&#x27;</span>) <span class="comment">#使用set函数</span></span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li><p><strong>输出时会自动去掉重复的元素（从第二次重复的元素开始删除）</strong></p>
</li>
<li><p>可以进行集合运算</p>
</li>
<li><p><strong>不可像前面几个类型一样进行索引</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(a-b) <span class="comment">#将a中与b相同的元素去掉后输出a</span></span><br><span class="line"><span class="built_in">print</span>(a|b) <span class="comment"># 并集</span></span><br><span class="line"><span class="built_in">print</span>(a&amp;b) <span class="comment">#交集</span></span><br><span class="line"><span class="built_in">print</span>(a^b) <span class="comment">#非交集</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6、Dictionary（字典）"><a href="#6、Dictionary（字典）" class="headerlink" title="6、Dictionary（字典）"></a>6、Dictionary（字典）</h3><p>字典是一种映射类型，它是一个无序的 <strong>键(key) : 值(value)</strong> 的集合。</p>
<p>定义方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;a&#x27;</span> : <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span> :<span class="number">3</span>&#125;  <span class="comment">#&#x27;:&#x27;前为“键”，后为“值”</span></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line">a= &#123;&#125;</span><br><span class="line">a[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span></span><br><span class="line">a[<span class="string">&#x27;b&#x27;</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment">#&#123;&#x27;a&#x27;: &#x27;abcd&#x27;, &#x27;b&#x27;: &#x27;123&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(a.keys()) <span class="comment">#dict_keys([&#x27;a&#x27;, &#x27;b&#x27;])</span></span><br><span class="line"><span class="built_in">print</span>(a.values()) <span class="comment">#dict_values([&#x27;abcd&#x27;, &#x27;123&#x27;])</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&#x27;b&#x27;</span>])	<span class="comment">#2    访问字典里的值</span></span><br></pre></td></tr></table></figure>

<p>键的特性：</p>
<ul>
<li>同一个键出现两次时只有后一个值会被记住</li>
<li>键必须是不可变的，因此可以是数字、字符串、元组，而不能是列表等可以改变的变量</li>
</ul>
<p>同时遍历多个序列和用单个字典表示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">questions = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;lancelot&#x27;</span>, <span class="string">&#x27;quest&#x27;</span>:<span class="string">&#x27;the holy grail&#x27;</span>, <span class="string">&#x27;favorite color&#x27;</span>:<span class="string">&#x27;blue&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> q, a <span class="keyword">in</span> questions.items():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">f&#x27;What is your <span class="subst">&#123;q&#125;</span>?  It is <span class="subst">&#123;a&#125;</span>.&#x27;</span>)</span><br><span class="line"><span class="comment">###############################or#########################################</span></span><br><span class="line">questions = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;quest&#x27;</span>, <span class="string">&#x27;favorite color&#x27;</span>]</span><br><span class="line">answers = [<span class="string">&#x27;lancelot&#x27;</span>, <span class="string">&#x27;the holy grail&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> q, a <span class="keyword">in</span> <span class="built_in">zip</span>(questions, answers): <span class="comment">#索引多个序列</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">f&#x27;What is your <span class="subst">&#123;q&#125;</span>?  It is <span class="subst">&#123;a&#125;</span>.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">What is your name?  It is lancelot.</span></span><br><span class="line"><span class="string">What is your quest?  It is the holy grail.</span></span><br><span class="line"><span class="string">What is your favorite color?  It is blue.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="综上"><a href="#综上" class="headerlink" title="综上"></a>综上</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">10.1</span>,<span class="string">&#x27;abcd&#x27;</span>]  <span class="comment">#列表</span></span><br><span class="line">a=(<span class="number">1</span>,<span class="number">10.1</span>,<span class="string">&#x27;abcd&#x27;</span>)	<span class="comment">#元组</span></span><br><span class="line">a=&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;	<span class="comment">#集合</span></span><br><span class="line">a = &#123;<span class="string">&#x27;a&#x27;</span> : <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span> :<span class="number">3</span>&#125; <span class="comment">#字典</span></span><br></pre></td></tr></table></figure>

<h1 id="2、推导式"><a href="#2、推导式" class="headerlink" title="2、推导式"></a>2、推导式</h1><p>Python 推导式是一种独特的数据处理方式，<strong>可以从一个数据序列构建另一个新的数据序列的结构体</strong>。</p>
<p>Python 支持各种数据结构的推导式：</p>
<ul>
<li>列表(list)推导式</li>
<li>字典(dict)推导式</li>
<li>集合(set)推导式</li>
<li>元组(tuple)推导式</li>
</ul>
<h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><p>格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表 <span class="keyword">if</span> 条件]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>表达式：新构建的列表的元素，可以是有返回值的函数</p>
</li>
<li><p>变量＆列表：我的理解是定义一个新变量，通过这个新变量将现有列表元素传入<strong>表达式</strong>中</p>
</li>
<li><p>条件：对变量进行筛选</p>
</li>
</ul>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">b = [i/<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="comment">#定义变量i，i来自列表a中的可以整除2的元素，最后返回i/2的值作为新列表b的元素</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment">#[1.0, 2.0, 3.0, 4.0, 5.0]</span></span><br></pre></td></tr></table></figure>

<p>同时定义多个变量存放值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vec1 = [2, 4, 6]</span><br><span class="line">vec2 = [4, 3, -9]</span><br><span class="line">[x*y for x in vec1 for y in vec2] </span><br><span class="line">[x+y for x in vec1 for y in vec2]</span><br><span class="line">[vec1[i]*vec2[i] for i in range(len(vec1))]</span><br></pre></td></tr></table></figure>

<p>在矩阵列表中使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [[1, 2, 3], [4, 5, 6]]</span><br><span class="line">b = [row[0] for row in a]</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>

<h2 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h2><p>格式与列表推导式几乎相同，只是将表达式换成了<code>key:value</code>的格式，具体见下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>] <span class="comment"># 传入推导式的为一个列表</span></span><br><span class="line">b = &#123;k: <span class="built_in">chr</span>(k) <span class="keyword">for</span> k <span class="keyword">in</span> a.keys()&#125;</span><br><span class="line"><span class="built_in">print</span>(b)	<span class="comment">#&#123;97: &#x27;a&#x27;, 98: &#x27;b&#x27;, 99: &#x27;c&#x27;, 100: &#x27;d&#x27;, 101: &#x27;e&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">97</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">98</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">99</span>: <span class="string">&#x27;c&#x27;</span>, <span class="number">100</span>: <span class="string">&#x27;d&#x27;</span>, <span class="number">101</span>: <span class="string">&#x27;e&#x27;</span>&#125;<span class="comment"># 传入推导式的为一个字典</span></span><br><span class="line">b = &#123;k: <span class="built_in">chr</span>(k) <span class="keyword">for</span> k <span class="keyword">in</span> a.keys()&#125;</span><br><span class="line"><span class="built_in">print</span>(b)	<span class="comment">#&#123;97: &#x27;a&#x27;, 98: &#x27;b&#x27;, 99: &#x27;c&#x27;, 100: &#x27;d&#x27;, 101: &#x27;e&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>但如果如下操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">97</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">98</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">99</span>: <span class="string">&#x27;c&#x27;</span>, <span class="number">100</span>: <span class="string">&#x27;d&#x27;</span>, <span class="number">101</span>: <span class="string">&#x27;e&#x27;</span>&#125;</span><br><span class="line">b = &#123;k: i <span class="keyword">for</span> i <span class="keyword">in</span> a.values() <span class="keyword">for</span> k <span class="keyword">in</span> a.keys()&#125;</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment">#&#123;97: &#x27;e&#x27;, 98: &#x27;e&#x27;, 99: &#x27;e&#x27;, 100: &#x27;e&#x27;, 101: &#x27;e&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>目前还不知道原因。</p>
<h2 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h2><p>规则格式与列表推导式相同</p>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;abracadabra&#x27;</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>&#125; <span class="comment">#判断不是abc的字母</span></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment">#&#123;&#x27;d&#x27;, &#x27;r&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a)) <span class="comment">#&lt;class &#x27;set&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="元组推导式（生成器表达式）"><a href="#元组推导式（生成器表达式）" class="headerlink" title="元组推导式（生成器表达式）"></a>元组推导式（生成器表达式）</h2><p>元组推导式和列表推导式的用法也完全相同，但元组推导式返回的结果是一个生成器对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x7faf6ee20a50</span>&gt;  <span class="comment"># 返回的是生成器对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">tuple</span>(a)       <span class="comment"># 使用 tuple() 函数，可以直接将生成器对象转换成元组</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure>

<h1 id="3、运算符"><a href="#3、运算符" class="headerlink" title="3、运算符"></a>3、运算符</h1><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><ul>
<li><p><code>:=</code>   海象运算符，在表达式内部为变量赋值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n := <span class="built_in">len</span>(a)) &gt; <span class="number">10</span>  <span class="comment">#可以避免调用两次len函数</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="python逻辑运算符"><a href="#python逻辑运算符" class="headerlink" title="python逻辑运算符"></a>python逻辑运算符</h2><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">表达式</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">and</td>
<td align="center">x and y</td>
<td align="center">x为<strong>假</strong>则返回x，x为<strong>真</strong>则返回y</td>
</tr>
<tr>
<td align="center">or</td>
<td align="center">a or y</td>
<td align="center">x为<strong>真</strong>则返回x，x为<strong>假</strong>则返回y</td>
</tr>
<tr>
<td align="center">not</td>
<td align="center">not x</td>
<td align="center">x为真返回假，为假返回真</td>
</tr>
</tbody></table>
<h2 id="python成员运算符"><a href="#python成员运算符" class="headerlink" title="python成员运算符"></a>python成员运算符</h2><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">表达式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">in</td>
<td align="center">x in list</td>
</tr>
<tr>
<td align="center">not in</td>
<td align="center">x not in list</td>
</tr>
</tbody></table>
<h2 id="python身份运算符"><a href="#python身份运算符" class="headerlink" title="python身份运算符"></a>python身份运算符</h2><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">表达式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">is</td>
<td align="center">a is b</td>
</tr>
<tr>
<td align="center">is not</td>
<td align="center">a is not b</td>
</tr>
</tbody></table>
<h1 id="4、其他"><a href="#4、其他" class="headerlink" title="4、其他"></a>4、其他</h1><ul>
<li><p>end关键字，用于将结果输出到同一行，同时将end&#x3D;的内容添加在每次输出的末尾</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> b&lt;<span class="number">10</span>：</span><br><span class="line">	<span class="built_in">print</span>(b,end=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">	b+=<span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> python学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++变量和基本类型]]></title>
      <url>/2022/09/09/C++-2/</url>
      <content type="html"><![CDATA[<h1 id="第二章——变量和基本类型"><a href="#第二章——变量和基本类型" class="headerlink" title="第二章——变量和基本类型"></a>第二章——变量和基本类型</h1><h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>C++这个板块是我在学习了C之后才学的，因此我只会记录一些重要的或者在C中没有的东西</p>
<p><em>C++板块是基于C++primer的方案学习的</em></p>
<h2 id="1、基本内置类型"><a href="#1、基本内置类型" class="headerlink" title="1、基本内置类型"></a>1、基本内置类型</h2><ul>
<li><p>bool类型取值只为真（1）和假（0）</p>
</li>
<li><p>当一个算术表达式中既有无符号数（unsigned）又有int型时，int型的值会转换成无符号数。且值大于0时会正常显示，小于零时会异常显示（当int为4字节时，值为2^32 + 计算结果（负数））也就是4294967295加上</p>
<p>(-n)。</p>
</li>
</ul>
<h3 id="指定字面值类型："><a href="#指定字面值类型：" class="headerlink" title="指定字面值类型："></a>指定字面值类型：</h3><ul>
<li>字符和字符串字面值</li>
</ul>
<table>
<thead>
<tr>
<th align="center">前缀</th>
<th align="center">含义</th>
<th align="center">代表类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u</td>
<td align="center">Unicode16字符</td>
<td align="center">char16_t</td>
</tr>
<tr>
<td align="center">U</td>
<td align="center">Unicode32字符</td>
<td align="center">char32_t</td>
</tr>
<tr>
<td align="center">L</td>
<td align="center">宽字符（2字节）</td>
<td align="center">wchar_t</td>
</tr>
<tr>
<td align="center">u8</td>
<td align="center">Unicode8字符</td>
<td align="center">char</td>
</tr>
</tbody></table>
<ul>
<li>整型字面值</li>
</ul>
<table>
<thead>
<tr>
<th align="center">后缀</th>
<th align="center">最小匹配类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u or U</td>
<td align="center">unsigned</td>
</tr>
<tr>
<td align="center">l or L</td>
<td align="center">long</td>
</tr>
<tr>
<td align="center">ll or LL</td>
<td align="center">long long</td>
</tr>
</tbody></table>
<ul>
<li>浮点型</li>
</ul>
<table>
<thead>
<tr>
<th align="center">后缀</th>
<th align="center">代表的类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">f or F</td>
<td align="center">float</td>
</tr>
<tr>
<td align="center">l or L</td>
<td align="center">long double</td>
</tr>
</tbody></table>
<h2 id="2、变量"><a href="#2、变量" class="headerlink" title="2、变量"></a>2、变量</h2><ul>
<li><p>一种初始化字符串的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">a</span><span class="params">(<span class="string">&quot;test&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>字符串变量名a，内容为test</p>
</li>
</ul>
<h2 id="3、对象"><a href="#3、对象" class="headerlink" title="3、对象"></a>3、对象</h2><p>通常情况下，对象是指<strong>一块能存储数据并具有某种类型的内存空间</strong></p>
<h3 id="关于初始化的问题"><a href="#关于初始化的问题" class="headerlink" title="关于初始化的问题"></a>关于初始化的问题</h3><p>在学C的时候我自己也是一直把初始化理解成赋值，但是也一直感觉怪怪的，特别是对于指针变量的初始化，感觉明显是不符合“赋值”这一操作的，今天在阅读书籍时书中也指出了初始化≠赋值，但是具体的区别目前我也不能讲的很明白，学到后面如果搞懂了再说吧。</p>
<ul>
<li>定义在函数体内部的变量将不被初始化。</li>
</ul>
<h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3><p>用花括号来初始化变量，在C++中以下四种初始化都是正确的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a =<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> a =&#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> a&#123;<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4、标识符"><a href="#4、标识符" class="headerlink" title="4、标识符"></a>4、标识符</h2><p>虽然感觉很怪异，但是<code>int _=1;</code>是合法的。</p>
<h2 id="5、复合类型变量"><a href="#5、复合类型变量" class="headerlink" title="5、复合类型变量"></a>5、复合类型变量</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>为对象起另外一个名字，<strong>同时引用必须被初始化。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> &amp;b=a;</span><br><span class="line">b=<span class="number">2</span>;<span class="comment">//等同于 a=2;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>引用并非对象，可以只是理解为一个已存在变量的别名。</li>
<li>一旦使用引用，引用对象将和引用的初始化变量绑定，无法更改，因此引用必须初始化。</li>
<li><strong>引用只能绑定在对象上，而不能与某个字面值或某个计算结果绑定</strong>。</li>
</ul>
<p><strong>指向指针的引用：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> *&amp;r=p; <span class="comment">//注意这里是*&amp;r</span></span><br><span class="line">r=&amp;i;</span><br><span class="line">*r=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>规则与C基本一样，不再赘述。</p>
<h2 id="6、const-限定符"><a href="#6、const-限定符" class="headerlink" title="6、const 限定符"></a>6、const 限定符</h2><ul>
<li><p>作用：定义一个变量后，它的值不能再被改变</p>
<p>因此，const的对象必须初始化。</p>
</li>
<li><p>当多个文件出现了同名的const变量时，视作分别定义了独立的变量，也就是说默认情况下const对象只在本文件内有效。（当然也可以使用extern关键字，具体可见<a href="https://dhkkk.gitee.io/2022/08/03/C-%E5%85%B3%E9%94%AE%E5%AD%97/">一些关键字 | 小董的BLOG (gitee.io)</a>）</p>
<p><strong>对于使用extern，如果要在多个文件之间共享const对象，则在定义该对象时也必须添加extern</strong></p>
</li>
</ul>
<h3 id="对const对象的引用"><a href="#对const对象的引用" class="headerlink" title="对const对象的引用"></a>对const对象的引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b1=a;<span class="comment">//对</span></span><br><span class="line"><span class="type">int</span> &amp;b2=a;<span class="comment">//错，引用的类型必须与引用对象类型一致</span></span><br></pre></td></tr></table></figure>

<p>假设第三行操作合法，则可以通过b2改变a的值，这显然是不正确的</p>
<ul>
<li><p>若初始化引用的对象为表达式，<strong>只要该表达式的结果能转化成引用的类型即可</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b=a;</span><br><span class="line"><span class="comment">//允许将const int型引用绑定到普通的int对象上（其他普通变量也可以视情况转化）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因此，可以有以下操作</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b1=a;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b2=a;</span><br><span class="line"><span class="comment">//可以通过b1改变a的值，但不允许通过b2改变a的值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="指向const对象的指针和const指针"><a href="#指向const对象的指针和const指针" class="headerlink" title="指向const对象的指针和const指针"></a>指向const对象的指针和const指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指向const对象的指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> *p=&amp;a;</span><br><span class="line">*p=b; <span class="comment">//错误，不可修改p指向的对象的值</span></span><br><span class="line">p=&amp;b; <span class="comment">//合法，并没有更改a的值，只是更改了一般指针p的值</span></span><br></pre></td></tr></table></figure>

<p>说明一下，上述中的<code>int *p=&amp;a;</code>也可以改为<code>const int *p=&amp;a;</code><strong>且二者完全一致</strong>，原因与后文中的顶&#x2F;底层const有关</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const指针</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p=&amp;a;</span><br><span class="line">p=&amp;b; <span class="comment">//错误，const指针一旦初始化便会一直指向初始化时的对象</span></span><br><span class="line">*p=b; <span class="comment">//正确，因为指针指向的值为普通int型，可以改变</span></span><br></pre></td></tr></table></figure>

<p>将指针本身定义为const型（不太好用语言描述感觉），即一旦初始化完成，该指针便无法再指向其他对象。</p>
<p>下面还是一个const指针的说明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p=&amp;a;</span><br><span class="line"><span class="comment">//此时p和*p都是无法改变的</span></span><br></pre></td></tr></table></figure>

<p>当使用const指针指向的值也是const类型时，const指针本身必须再次使用一次const，因为要保持类型的一致</p>
<h3 id="顶-x2F-底层const"><a href="#顶-x2F-底层const" class="headerlink" title="顶&#x2F;底层const"></a>顶&#x2F;底层const</h3><p>对于指针，指针本身是一个对象，而它也指向了另一个对象，<strong>因此用顶层const表示指针本身是个const类型，用底层const表示指针所指的对象时一个const型</strong>。一般来说，顶层const可以表示任意对象。</p>
<ul>
<li><p>当const + 类型 时，意为使这个类型的值为常量，如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p;</span><br></pre></td></tr></table></figure>

<p>定义一个指针变量，该变量所指的值为int型，因此该值（*p）不可被修改，但是p可以被修改。</p>
</li>
<li><p>当const + 变量 时，意为使该变量为常量，如：</p>
</li>
<li><p>&#96;&#96;&#96;c++<br>int* const p;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  指针变量p为常量，因此其指向的地址无法被改变，但是地址中的值(*p)可以被改变。</span><br><span class="line"></span><br><span class="line">## 7、constexpr类型</span><br><span class="line"></span><br><span class="line">* 常量表达式：指值不会改变**并且在编译过程就能得到结果的表达式**；字面值、用常量表达式初始化的const对象也是常量表达式。</span><br><span class="line"></span><br><span class="line">  ```c</span><br><span class="line">  const int i = 10;			//字面值是常量表达式</span><br><span class="line">  const int j = i+1;			//j是常量表达式</span><br><span class="line">  int k = i;					//k不是const对象，所以k不是是常量表达式</span><br><span class="line">  const int m = get_val(); 	//m的值直到运行时才能获得，所以m不是常量表达是</span><br></pre></td></tr></table></figure>

<p>从上面我们可以看出，使用const进行声明时，我们需要<strong>人为的验证</strong>赋给const对象的初始值是不是常量表达是，在复杂系统中，有时候很难分辨，而使用constexpr进行声明时，可以由<strong>编译器来验证</strong>变量是不是常量表达式</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="number">10</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> m=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">constexpr</span> <span class="type">int</span> i = <span class="built_in">func1</span>(<span class="number">10</span>);<span class="comment">//正确，i是一个常量表达式</span></span><br><span class="line">	<span class="keyword">constexpr</span> <span class="type">int</span> j = <span class="built_in">func1</span>(n);<span class="comment">//错误,n为变量，不是字面值</span></span><br><span class="line">	<span class="keyword">constexpr</span> <span class="type">int</span> k = <span class="built_in">func1</span>(m+<span class="number">1</span>);<span class="comment">//正确，k是一个常量表达式</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="const和constexpr的区别"><a href="#const和constexpr的区别" class="headerlink" title="const和constexpr的区别"></a>const和constexpr的区别</h3><ul>
<li>对于修饰对象来说，const并未区分出编译期常量和运行期常量，constexpr限定在了编译期常量</li>
<li>在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。</li>
<li>constexpr将它所定义的对象置为顶层const</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>*p1=<span class="literal">nullptr</span>;  			<span class="comment">//p1是一个指向常量的指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span>*p2=<span class="literal">nullptr</span>;		<span class="comment">//p2是一个指向整数的常量指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span>*p3=<span class="literal">nullptr</span>; </span><br><span class="line"><span class="comment">//p3是一个指向常量的常量指针，由于constexpr只对指针有效，需要再加一个底层const才可以限制指针指向的对象</span></span><br></pre></td></tr></table></figure>

<h2 id="8、处理类型"><a href="#8、处理类型" class="headerlink" title="8、处理类型"></a>8、处理类型</h2><h3 id="（1）类型别名"><a href="#（1）类型别名" class="headerlink" title="（1）类型别名"></a>（1）类型别名</h3><p>类型别名是一个<strong>名字</strong>，<strong>是某种类型的同义词</strong>。有两种办法可用于定义类型别名：</p>
<ul>
<li><p>使用关键字typedef，详见<u>一些关键字 | 小董的BLOG</u> </p>
</li>
<li><p>使用别名声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> INT =<span class="type">int</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="类型别名与指针、常量"><a href="#类型别名与指针、常量" class="headerlink" title="类型别名与指针、常量"></a>类型别名与指针、常量</h4><p>有以下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> abc=<span class="type">char</span>*;</span><br><span class="line"><span class="type">char</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> abc p=&amp;a;<span class="comment">//此处等同于char *const p=&amp;a;而不是 const char *p=&amp;a;</span></span><br><span class="line"><span class="comment">//也就是说此处是常量指针，而不是指向常量的指针，因此：</span></span><br><span class="line">*p=<span class="number">20</span>;<span class="comment">//合法</span></span><br></pre></td></tr></table></figure>

<p>感觉可以直接理解为这里的const为顶层const型</p>
<h3 id="（2）auto类型说明符"><a href="#（2）auto类型说明符" class="headerlink" title="（2）auto类型说明符"></a>（2）auto类型说明符</h3><p>这里auto和C中用法有所出入，在C++11新标准中，auto用于让编译器通过初始值来推算变量的类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">auto</span> c=a+b;</span><br></pre></td></tr></table></figure>

<p>此时c的类型就为int</p>
<ul>
<li>auto定义的变量必须有初始值</li>
<li>参与初始化的各对象类型必须相同，否则会报错</li>
</ul>
<h4 id="在复合类型与常量参与的情况下："><a href="#在复合类型与常量参与的情况下：" class="headerlink" title="在复合类型与常量参与的情况下："></a>在复合类型与常量参与的情况下：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a=<span class="number">1</span>; &amp;a1=a;</span><br><span class="line"><span class="keyword">auto</span> b=a; <span class="comment">//b为int型</span></span><br><span class="line"><span class="keyword">auto</span> c=a1;<span class="comment">//c为int型</span></span><br><span class="line"><span class="keyword">auto</span> d=&amp;a;<span class="comment">//d为指向常量的指针</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> e=a; <span class="comment">//顶层const需专门声明</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>auto一般会忽略顶层const</p>
</li>
<li><p>对一个常量对象取地址是一种底层const</p>
</li>
</ul>
<h3 id="（3）decltype类型指示符"><a href="#（3）decltype类型指示符" class="headerlink" title="（3）decltype类型指示符"></a>（3）decltype类型指示符</h3><p>当我们定义一个变量时希望用一个表达式返回的类型定义该变量，但是又不想用该表达式的结果的值初始化变量，为满足这一要求，C++11新标准引入了decltype，它的作用是选择并返回操作数的数据类型，在此过程中，编译器分析表达式的类型，却不实际计算它的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>decltype()内的参数可以为变量、函数、甚至引用</p>
<h4 id="decltype和引用："><a href="#decltype和引用：" class="headerlink" title="decltype和引用："></a>decltype和引用：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">1</span>,&amp;a1=a,*p=&amp;a;</span><br><span class="line"><span class="type">int</span> b=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a1) c=b;<span class="comment">//c为int&amp;，也就是引用类型</span></span><br><span class="line"><span class="keyword">decltype</span>(a1+<span class="number">0</span>) d=<span class="number">1</span>; <span class="comment">//d为int型，原因是a1+0的结果为int型</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) e=b; <span class="comment">//*p的值按道理来说是1，书上讲这里讲为int&amp;型，也就是与c一样</span></span><br></pre></td></tr></table></figure>

<p>当decltype传入的参数添加上一对以上的括号后，例如decltype((a))，<strong>结果永远为引用</strong></p>
]]></content>
      
        
        <tags>
            
            <tag> C++学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用说明]]></title>
      <url>/2022/09/08/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      <content type="html"><![CDATA[<h1 id="欢迎访问DHK的个人博客！以下是一些使用说明："><a href="#欢迎访问DHK的个人博客！以下是一些使用说明：" class="headerlink" title="欢迎访问DHK的个人博客！以下是一些使用说明："></a>欢迎访问DHK的个人博客！以下是一些使用说明：</h1><h2 id="1-写的目的"><a href="#1-写的目的" class="headerlink" title="1.写的目的"></a>1.写的目的</h2><p>主要是为了记录自己在一些学习中的笔记和感想，方便日后回忆与查阅，仅供内部学习，未经同意请勿转载！</p>
<p>由于大部分是将自己的理解总结出来，所以有些地方不一定正确，也欢迎读者随时给予斧正，一些联系方式也已经放在侧边栏。</p>
<h2 id="2-如何查找需要内容"><a href="#2-如何查找需要内容" class="headerlink" title="2.如何查找需要内容"></a>2.如何查找需要内容</h2><ul>
<li>左侧目录有相关分类tag，以供查找</li>
<li>也可以通过左侧搜索功能搜索想要的内容</li>
<li>左侧我的GitHub仓库中也上传过之前使用过的一些例程模板</li>
</ul>
<h2 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h2><ul>
<li><u>如果你曾经打开过此博客网站，<strong>请务必在阅读相关博客之前先Ctrl+F5</strong>强制清理之前的缓存，不然你可能会看不到最新更新的内容！！！</u><em>（感觉是gitee的问题，之前部署到GitHub时并未遇见此问题）</em></li>
<li>如果想定位到想查找的内容的具体位置，建议先用博客的搜索功能定位到文章，再通过ctrl F搜索关键字即可。</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识c++]]></title>
      <url>/2022/09/07/C++-1/</url>
      <content type="html"><![CDATA[<h1 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h1><ul>
<li><p><strong>iostream库</strong></p>
<p>在C++中没有专门定义的输入输出（IO）语句，而是使用了一个全面的<strong>标准库</strong>来提供IO机制等功能，也就是iostream库。而在iostream库中包含了两个基础<strong>类型</strong>：</p>
<ul>
<li>istream(in stream)：输入流</li>
<li>ostream(out stream)：输出流</li>
</ul>
</li>
<li><p>流的</p>
</li>
<li><p><strong>IO对象</strong></p>
<p>在标准库中定义了4个IO对象，分别为1个istream型，3个ostream型：</p>
<ul>
<li>instream型：<ul>
<li>cin(发音see in)：标准输入对象</li>
</ul>
</li>
<li>ostream型：<ul>
<li>cout：标准输出对象</li>
<li>cerr：输出警告和错误信息</li>
<li>clog：输出程序运行时的一般性消息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="输入输出例程："><a href="#输入输出例程：" class="headerlink" title="输入输出例程："></a>输入输出例程：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b;</span><br><span class="line">	std::cin&gt;&gt;a&gt;&gt;b;<span class="comment">//输入</span></span><br><span class="line">	std::cout&lt;&lt;a+b&lt;&lt;std::endl;<span class="comment">//输出</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面针对这个例程讲解：</p>
<ul>
<li><p>前缀std::</p>
<p>这个前缀指出cin、cout、endl都是定义在名为std的命名空间中的。使用命名空间可以避免与用户定义的名字冲突。且标准库的所有名字都是定义在std中的。</p>
</li>
<li><h3 id="从输入流读取数据："><a href="#从输入流读取数据：" class="headerlink" title="从输入流读取数据："></a>从输入流<strong>读取</strong>数据：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">std::cin&gt;&gt;a&gt;&gt;b;<span class="comment">//输入</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>输入运算符（&gt;&gt;)</strong></p>
<p>该运算符接收两个运算对象：</p>
<ul>
<li><p>左侧：必须为一个ostream型的对象</p>
</li>
<li><p>右侧：存放输入的值的变量</p>
</li>
</ul>
<p>返回值（计算结果）： ostream型的对象（左侧运算对象）</p>
<p>也就是说下面几种写法是一个意思：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">/****************************/</span><br><span class="line">(std::cin&gt;&gt;a)&gt;&gt;b;</span><br><span class="line">/****************************/</span><br><span class="line">std:cin&gt;&gt;a;</span><br><span class="line">std:cin&gt;&gt;b;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h3 id="向输出流写入数据："><a href="#向输出流写入数据：" class="headerlink" title="向输出流写入数据："></a>向输出流<strong>写入</strong>数据：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout&lt;&lt;a+b&lt;&lt;std::endl;<span class="comment">//输出</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>输出运算符（&lt;&lt;)</strong></p>
<p>该运算符接收两个运算对象：</p>
<ul>
<li>左侧：必须为一个istream型的对象</li>
<li>右侧：要打印的值</li>
</ul>
<p>返回值（计算结果）： 写入给定值的ostream型的对象</p>
<p>也就是说下面几种写法是一个意思：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::cout&lt;&lt;a+b&lt;&lt;std::endl;</span><br><span class="line"><span class="comment">/****************************/</span></span><br><span class="line">(std::cout&lt;&lt;a+b)&lt;&lt;std::endl;</span><br><span class="line"><span class="comment">/****************************/</span></span><br><span class="line">std::cout&lt;&lt;a+b;</span><br><span class="line">std::cout&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>endl操纵符</strong> <em>(小写L,不是1)</em></p>
<p>endl也是被定义在std中的一个特殊值，写入endl的效果是结束当前行（类似c中的\n)，并将与设备相关联的缓冲区中的内容刷到设备中。</p>
<p>缓冲刷新操作可以保证目前为止程序中所产生的所有输出都真正的写入到了输出流中，而不仅停留在内存中等待写入流。</p>
</li>
<li><p><strong>关于数据缓冲区</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b=<span class="number">1</span>,c;</span><br><span class="line">	<span class="keyword">while</span>(std::cin&gt;&gt;a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//while (getchar()!= &#x27;\n&#x27;);</span></span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;times:&quot;</span>&lt;&lt;b++&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用一个istream对象为<strong>条件</strong>时，其效果就是检测输入流当前的状态，如果流是有效的，此时istream对象使条件为真，当遇到以下情况时为假：</p>
<ul>
<li>无效输入：例如上方输入不为int型（与a类型不符合）</li>
<li>当输入流遇到文件结束符，对于window系统，<strong>输入文件结束符的方法是ctrl+z+\n</strong></li>
</ul>
<p>在上方程序中（当注释掉第七行时），当输入4 ‘\0’ 5时，time也会对应输出2次，即1 ‘\n’ 2 。这是因为当输入一次性输入两个数时，第一个数存进a，第二个数会被存在数据缓冲区中等待下一次读取输入流的操作；若想清除缓冲区（或者说是清零），只需添加第7行即可。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> C++学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[FreeRTOS任务间的交互方法]]></title>
      <url>/2022/08/30/freertos%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
      <content type="html"><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><p>本来是打算在<a href="https://www.dhksblog.top/2022/08/25/FreeRTOS-3/">FreeRTOS在CubeMX中的使用</a>就把这些内容给讲了的，但是学习的过程中发现网络上很多教程都存在着一些差异，所以为了更系统地学习，同时也方便日后查阅，就单独开一篇文章总结一下相关内容</p>
<p><strong>注：本文所有例程均经过测试且可以正常运行</strong></p>
<h1 id="1、队列"><a href="#1、队列" class="headerlink" title="1、队列"></a>1、队列</h1><p>FreeRTOS中的队列<strong>是一种用于实现【任务与任务】，【任务与中断】以及【中断与任务】之间的通信机制。</strong>此外，任务从队列读数据或者写入数据到队列时，都可能被阻塞。这个特性使得任务可以被设计成基于事件驱动的运行模式，大大提高了CPU的执行效率。队列是实现FreeRTOS中其他特性的基础组件，像软件定时器，信号量，互斥锁都是基于队列而实现的。</p>
<p>在操作系统里面，直接使用全局变量传输数据十分危险，看似正常运行，但不知道啥时候就会因为寄存器或者内存等等原因引起崩溃，所以引入消息，队列的概念。</p>
<h2 id="队列的基本特性"><a href="#队列的基本特性" class="headerlink" title="队列的基本特性"></a>队列的基本特性</h2><p>队列是一种FIFO操作的数据结构，入队操作就是把一个新的元素放进队尾(tail)，出队操作就是从队头(front)取出一个元素。FreeRTOS中也支持把一个元素放到队头的操作，这个操作会<strong>覆盖</strong>之前队头的元素。</p>
<h2 id="入队策略"><a href="#入队策略" class="headerlink" title="入队策略"></a>入队策略</h2><p>队列在设计的时候，主要有两种元素入队存储策略：Queue by copy 和 Queue by reference。FreeRTOS的队列使用的是Queue by copy存储策略，考虑到这种策略实现起来更加简单，灵活，且安全。</p>
<ul>
<li>Queue by copy：数据入队的时候，队列中存储的是此数据的一份拷贝</li>
<li>Queue by reference：数据队列的时候，队列中存储的是数据的指针，而非数据本身</li>
</ul>
<h2 id="入队堵塞"><a href="#入队堵塞" class="headerlink" title="入队堵塞"></a>入队堵塞</h2><p>一个任务在尝试写入数据到队列时，可以指定一个阻塞时间，即任务在<strong>等待队列有空余空间（非满）可写前最长等待阻塞时间</strong>。当队列中有空间可写入时，任务会自动从阻塞态转换为就绪态。如果在等待时间内队列一直是满的，则等待时间到期后，任务也会自动从阻塞态转换为就绪态，但是它会返回一个写入失败的结果。</p>
<p>队列可能有多个writerTask，所以在等待队列有空闲空间时，可能会有多个任务阻塞。<strong>当队列有空闲空间可写时，调度器会从所有阻塞的任务中选取优先级最高的那个任务让其进入到就绪态</strong>。<strong>如果最高优先级的不止一个，则让等待最久的那个进入到就绪态。</strong></p>
<h2 id="出队堵塞"><a href="#出队堵塞" class="headerlink" title="出队堵塞"></a><strong>出队堵塞</strong></h2><p>一个任务在尝试从队列中读取数据时，可以指定一个阻塞时间，即任务在等待队列有元素可读前最长等待阻塞时间。当队列中有元素可读时，任务会自动从阻塞态转换为就绪态。<strong>如果在等待时间内队列一直没有数据可读，则等待时间到期后，任务也会自动从阻塞态转换为就绪态，但是它会返回一个读取失败的结果</strong>。</p>
<p>队列可能有多个reader Task，所以在等待队列有数据可读时，可能会有多个任务阻塞。<strong>当队列有数据可读时，调度器会从所有阻塞的任务中选取优先级最高的那个任务让其进入到就绪态。如果最高优先级的不止一个，则让等待最久的那个进入到就绪态。</strong></p>
<h2 id="相关API函数"><a href="#相关API函数" class="headerlink" title="相关API函数"></a>相关API函数</h2><ul>
<li><p>队列创建（若使用cubemx则只用点点点，不用再用函数创建，所有创建类函数同理）</p>
<p>使用xQueueCreate()内核函数来创建一个队列。队列的1存储空间从FreeRTOS heap中分配。在使用xQueueCreate()创建队列时，如果FreeRTOS heap中没有足够的存储空间分配给当前队列，则函数返回NULL。如果创建成功，则返回队列的句柄(QueueHandle_t类型)</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize );</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center"><strong>uxQueueLength</strong>：指定队列的长度，即最多可以存放的元素个数<br><strong>uxItemSize</strong>：队列中存储的元素的大小（占用的字节数）</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">返回NULL代表创建失败，没有足够的堆空间来创建当前队列；创建成功则返回队列的句柄</td>
</tr>
</tbody></table>
<ul>
<li><p>元素入队</p>
<p>使用xQueueSendToBack()函数来向队尾存放一个元素，使用xQueueSend()函数来向队首存放一个元素，两个函数用法一样</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">BaseType_t xQueueSendToBack( QueueHandle_t xQueue,<br>                                                                        const void * pvItemToQueue,<br>                                                       TickType_t xTicksToWait );</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center"><strong>xQueue</strong>：目标队列的句柄<br><strong>pvItemToQueue</strong>：入队元素的指针。队列将存储此指针指向的数据的备份<br><strong>xTicksToWait</strong>：指定等待队列有空间可以容纳新元素入队的最长等待（阻塞）时间</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">当元素成功入队时返回pdPASS，因为队列满而无法入队时返回errQUEUE_FULL（超时后）</td>
</tr>
</tbody></table>
<ul>
<li><p>查询队列元素个数</p>
<p>使用内核函数uxQueueMessagesWaiting()来获取队列中有多少个元素</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">UBaseType_t uxQueueMessagesWaiting( QueueHandle_t xQueue );</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center"><strong>xQueue</strong>：队列的句柄</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">队列中的元素个数，返回0代表队列为空</td>
</tr>
</tbody></table>
<p>按键例程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span> <span class="comment">//低优先级任务</span></span><br><span class="line">&#123;</span><br><span class="line">  BaseType_t result; </span><br><span class="line">  <span class="type">uint8_t</span> dat[]=<span class="string">&quot;666\r\n&quot;</span>;</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">	<span class="keyword">if</span>(HAL_GPIO_ReadPin(key_1_GPIO_Port,key_1_Pin == GPIO_PIN_SET)) <span class="comment">//检测按键</span></span><br><span class="line">	&#123;</span><br><span class="line">		result= xQueueSendToBack(myQueue01Handle,dat,portMAX_DELAY); <span class="comment">//将元素dat放至队尾</span></span><br><span class="line">		<span class="keyword">if</span>(result==pdPASS) <span class="comment">//放置成功返回pdPASS</span></span><br><span class="line">		&#123;</span><br><span class="line">			HAL_GPIO_WritePin(led_g_GPIO_Port,led_g_Pin,GPIO_PIN_RESET);<span class="comment">//点亮绿灯</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">   	osDelay(<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span> <span class="comment">//高优先级任务</span></span><br><span class="line">&#123;</span><br><span class="line">  BaseType_t result;</span><br><span class="line">  <span class="type">uint8_t</span> datbuf[<span class="number">10</span>]; <span class="comment">//随便定义个缓冲区就可以，用于存放取出的元素</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">	result=xQueueReceive(myQueue01Handle,datbuf,portMAX_DELAY);<span class="comment">//取出元素放入datbuf中</span></span><br><span class="line">	<span class="keyword">if</span>(result==pdPASS)<span class="comment">//读取成功返回pdPASS</span></span><br><span class="line">	&#123;</span><br><span class="line">		HAL_GPIO_WritePin(led_r_GPIO_Port,led_r_Pin,GPIO_PIN_RESET);<span class="comment">//点亮红灯</span></span><br><span class="line">	&#125;</span><br><span class="line">	osDelay(<span class="number">10</span>);</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2、任务通知"><a href="#2、任务通知" class="headerlink" title="2、任务通知"></a>2、任务通知</h1><p><em>在网上找了很多博客对于任务通知介绍的函数都不一样，我自己也实验了很多，就把我试验过的可行的函数都总结一遍，可以根据具体的需要选择相关函数（其实函数功能基本差不多，但是原理不一样）</em></p>
<p>每个RTOS任务都有一个32位的通知值，任务创建时，这个值被初始化为0。RTOS任务通知相当于直接向任务发送一个事件，接收到通知的任务可以解除阻塞状态，<strong>前提是这个阻塞事件是因等待通知而引起的</strong>。发送通知的同时，也可以可选的改变接收任务的通知值。</p>
<p>相对于用前必须分别创建队列、二进制信号量、计数信号量或事件组的情况，使用任务通知显然更灵活。更好的是，相比于使用信号量解除任务阻塞，使用任务通知可以快45%、使用更少的RAM。</p>
<p><strong>下面介绍的函数大类都可以实现任务通知的功能，可以根据需要选择</strong></p>
<h2 id="一、xTask函数"><a href="#一、xTask函数" class="headerlink" title="一、xTask函数"></a>一、xTask函数</h2><h3 id="发送函数（1）"><a href="#发送函数（1）" class="headerlink" title="发送函数（1）"></a>发送函数（1）</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">BaseType_t xTaskNotify( TaskHandle_txTaskToNotify,<br>                          uint32_t ulValue,<br>                           eNotifyAction eAction);</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center">xTaskToNotify：被通知的任务句柄<br>ulValue： 通知更新值<br> eAction:枚举类型，指明更新通知值的方法</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">成功则返回pdPASS</td>
</tr>
</tbody></table>
<p>eAction具体说明：</p>
<table>
<thead>
<tr>
<th align="center">枚举成员</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">eNoAction</td>
<td align="center">发送通知但不更新通知值，意味着ulValue未使用</td>
</tr>
<tr>
<td align="center">eSetBits</td>
<td align="center">被通知任务值赋值按位或赋值ulValue</td>
</tr>
<tr>
<td align="center">elncrement</td>
<td align="center">被通知任务的通知值++</td>
</tr>
<tr>
<td align="center">eSetValueWithOverwrite</td>
<td align="center">被通知任务值赋值为ulValue</td>
</tr>
<tr>
<td align="center">eSetValueWithoutOverwrite</td>
<td align="center">如果被通知的任务还没取走上一个通知的情况下，又向被通知任务发送一个新的通知，则新通知值被丢弃，且xTaskNotify()会返回pdFALSE</td>
</tr>
</tbody></table>
<img src="/images/loading.png" data-original="/2022/08/30/freertos%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F/eaction.jpg" class title="This is an image"> 

<h3 id="发送函数（2）"><a href="#发送函数（2）" class="headerlink" title="发送函数（2）"></a>发送函数（2）</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">BaseType_t xTaskNotifyGive(TaskHandle_t xTaskToNotify );</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center">xTaskToNotify：被通知的任务句柄</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">成功则返回pdPASS</td>
</tr>
</tbody></table>
<p>其实这是一个宏，本质上相当于xTaskNotify( ( xTaskToNotify ), ( 0 ), <strong>eIncrement</strong> )在这种情况下，应该使用API函数ulTaskNotifyTake()来等待通知，而不应该使用API函数xTaskNotifyWait()</p>
<p>此函数不可以在中断服务例程中调用，中断保护等价函数为vTaskNotifyGiveFromISR()</p>
<h3 id="接收函数（1）"><a href="#接收函数（1）" class="headerlink" title="接收函数（1）"></a>接收函数（1）</h3><p><u><strong>注意，此处讲到的接收函数应与上面讲到的发送函数配对，例如：使用发送函数（1），接收通知也要使用接收函数（1）</strong></u></p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">BaseType_t xTaskNotifyWait( uint32_tulBits  ToClearOnEntry,<br>                                                      uint32_tulBits  ToClearOnExit,<br>                                                          uint32_t*  pulNotificationValue,<br>                                    TickType_t  xTicksToWait );</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center">见下方</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">成功则返回pdPASS</td>
</tr>
</tbody></table>
<p>关于参数：</p>
<ul>
<li>ulBitsToClearOnEntry：在使用通知之前，先将任务的通知值与参数ulBitsToClearOnEntry的按位取反值按位与操作。设置参数ulBitsToClearOnEntry为0xFFFFFFFF(ULONG_MAX)，表示清零任务通知值。<ul>
<li><strong>但是在实际调试过程中感觉给0x00和0xFFFFFFFF在使用上没有区别，所以就给0xFFFFFFFF就可以</strong></li>
</ul>
</li>
</ul>
<img src="/images/loading.png" data-original="/2022/08/30/freertos%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F/qufan1.jpg" class title="This is an image"> 

<ul>
<li>*ulBitsToClearOnExit：在函数xTaskNotifyWait()退出前，将任务的通知值与参数ulBitsToClearOnExit的按位取反值按位与操作。设置参数ulBitsToClearOnExit为0xFFFFFFFF(ULONG_MAX)，表示清零任务通知值。<ul>
<li><strong>使用同上，默认0xFFFFFFFF就可以</strong></li>
</ul>
</li>
</ul>
<img src="/images/loading.png" data-original="/2022/08/30/freertos%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F/qufan2.jpg" class title="This is an image"> 

<ul>
<li>pulNotificationValue：用于向外回传任务的通知值。这个通知值在参数ulBitsToClearOnExit起作用前将通知值拷贝到*pulNotificationValue中（<strong>需额外定义一个缓冲区</strong>）。如果不需要返回任务的通知值，这里设置成NULL。</li>
<li>xTicksToWait：因等待通知而进入阻塞状态的最大时间。时间单位为系统节拍周期。宏pdMS_TO_TICKS用于将指定的毫秒时间转化为相应的系统节拍数。</li>
</ul>
<h3 id="接收函数（2）"><a href="#接收函数（2）" class="headerlink" title="接收函数（2）"></a>接收函数（2）</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">uint32_t ulTaskNotifyTake( BaseType_t  xClearCountOnExit,<br>                                TickType_t   xTicksToWait );</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center">xClearCountOnExit：如果该参数为pdFALSE，则API函数xTaskNotifyTake()退出前，将任务的通知值减1；如果该参数设置为pdTRUE，则API函数xTaskNotifyTake()退出前，将任务通知值清零。<br>xTicksToWait：因等待通知而进入阻塞状态的最大时间</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">成功则返回pdPASS</td>
</tr>
</tbody></table>
<h3 id="上例程！老规矩按键-led"><a href="#上例程！老规矩按键-led" class="headerlink" title="上例程！老规矩按键+led"></a>上例程！老规矩按键+led</h3><p>发送函数（1）+接收函数（1）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> event1 0x0001&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> event2 0x0001&lt;&lt;2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span> <span class="comment">//低优先级</span></span><br><span class="line">&#123;</span><br><span class="line">	BaseType_t result;</span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">		<span class="keyword">if</span>(HAL_GPIO_ReadPin(key_1_GPIO_Port,key_1_Pin) == GPIO_PIN_SET)<span class="comment">//按键检测</span></span><br><span class="line">		&#123;</span><br><span class="line">			result=  xTaskNotify(task2Handle,event1,<span class="number">4</span>);<span class="comment">//直接数字代替枚举成员</span></span><br><span class="line">			<span class="keyword">if</span>(result==pdPASS)</span><br><span class="line">			&#123;</span><br><span class="line">				HAL_GPIO_WritePin(led_g_GPIO_Port,led_g_Pin,GPIO_PIN_RESET);<span class="comment">//绿灯</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(HAL_GPIO_ReadPin(key_2_GPIO_Port,key_2_Pin) == GPIO_PIN_SET)<span class="comment">//按键检测</span></span><br><span class="line">		&#123;</span><br><span class="line">			result=  xTaskNotify(task2Handle,event2,<span class="number">4</span>);<span class="comment">//直接数字代替枚举成员</span></span><br><span class="line">			<span class="keyword">if</span>(result==pdPASS)</span><br><span class="line">			&#123;</span><br><span class="line">				HAL_GPIO_WritePin(led_b_GPIO_Port,led_b_Pin,GPIO_PIN_RESET);<span class="comment">//蓝灯</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		osDelay(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span><span class="comment">//高优先级</span></span><br><span class="line">&#123;</span><br><span class="line">	BaseType_t result;</span><br><span class="line">	<span class="type">uint32_t</span> ulNotifiedValue; <span class="comment">//存放任务通知值的缓冲区</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">		result=xTaskNotifyWait(<span class="number">0xFFFFFFFF</span>, <span class="number">0xFFFFFFFF</span>,&amp;ulNotifiedValue, portMAX_DELAY);</span><br><span class="line">		<span class="keyword">if</span>(result==pdPASS)</span><br><span class="line">		&#123;</span><br><span class="line">			HAL_GPIO_WritePin(led_r_GPIO_Port,led_r_Pin,GPIO_PIN_RESET);<span class="comment">//红灯</span></span><br><span class="line">		&#125;</span><br><span class="line">      	<span class="keyword">if</span>(ulNotifiedValue&amp;event1)</span><br><span class="line">		&#123;</span><br><span class="line">			HAL_GPIO_WritePin(led_r_GPIO_Port,led_r_Pin,GPIO_PIN_SET);</span><br><span class="line">			HAL_GPIO_WritePin(led_b_GPIO_Port,led_b_Pin,GPIO_PIN_SET);</span><br><span class="line">			HAL_GPIO_WritePin(led_g_GPIO_Port,led_g_Pin,GPIO_PIN_SET);<span class="comment">//全灭</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">if</span>(ulNotifiedValue&amp;event2)</span><br><span class="line">		&#123;</span><br><span class="line">			HAL_GPIO_WritePin(led_r_GPIO_Port,led_r_Pin,GPIO_PIN_RESET);</span><br><span class="line">			HAL_GPIO_WritePin(led_b_GPIO_Port,led_b_Pin,GPIO_PIN_RESET);</span><br><span class="line">			HAL_GPIO_WritePin(led_g_GPIO_Port,led_g_Pin,GPIO_PIN_RESET);<span class="comment">//全亮</span></span><br><span class="line">		&#125;</span><br><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment"> 整体逻辑：</span></span><br><span class="line"><span class="comment"> 按键1按下-&gt;绿灯亮-&gt;红灯亮-&gt;全灭</span></span><br><span class="line"><span class="comment"> 按键2按下-&gt;蓝灯亮-&gt;红灯亮-&gt;全灭</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 这里对于通知值的判断可以让用户知道是哪个任务通知函数触发了这次任务接收，感觉非常好用！！！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">		osDelay(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>发送函数（2）+接收函数（2）就不单独写了，基本同理，只是接收函数（2）无法对通知值进行判断，但是整体更方便快捷</p>
<h2 id="二、os函数"><a href="#二、os函数" class="headerlink" title="二、os函数"></a>二、os函数</h2><h3 id="向指定任务发送任务通知"><a href="#向指定任务发送任务通知" class="headerlink" title="向指定任务发送任务通知"></a>向指定任务发送任务通知</h3><table>
<thead>
<tr>
<th align="center"><strong>函数</strong></th>
<th align="center"><strong>int32_t osSignalSet (osThreadId thread_id, int32_t signal)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center"><strong>thread_id：</strong> 接收通知的任务ID<br><strong>signal：</strong>任务通知值（按位操作数字）</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">错误码</td>
</tr>
</tbody></table>
<h3 id="等待任务通知"><a href="#等待任务通知" class="headerlink" title="等待任务通知"></a>等待任务通知</h3><table>
<thead>
<tr>
<th align="center"><strong>函数</strong></th>
<th align="center"><strong>osEvent osSignalWait (int32_t signals, uint32_t millisec)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center">signals： 接收完成后等待被清零的数据位(0x0001|0x0002&#x3D;0x003)<br><strong>millisec：</strong> 等待超时时间，单位为系统节拍周期</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">错误码</td>
</tr>
</tbody></table>
<h3 id="例程，按键-led"><a href="#例程，按键-led" class="headerlink" title="例程，按键+led"></a>例程，按键+led</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> event1 0x0001</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span> <span class="comment">//低优先级任务</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN led_G */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">		<span class="keyword">if</span>(HAL_GPIO_ReadPin(key_1_GPIO_Port,key_1_Pin == GPIO_PIN_SET))</span><br><span class="line">		&#123;</span><br><span class="line">			osSignalSet(task2Handle,event1);</span><br><span class="line">		&#125;	</span><br><span class="line">		osDelay(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END led_G */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span> <span class="comment">//高优先级任务</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN led_B */</span></span><br><span class="line">	osEvent event;	</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">	event = osSignalWait(event1,osWaitForever);  </span><br><span class="line">	<span class="keyword">if</span>(event.status == osEventSignal)  </span><br><span class="line">	&#123;</span><br><span class="line">		HAL_GPIO_WritePin(led_g_GPIO_Port,led_g_Pin,GPIO_PIN_RESET);</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里task2可以不用额外在循环中添加堵塞，因为wait函数本身自带堵塞，<strong>其堵塞的解除是在osSignalSet函数的作用之后的瞬间，也就是说在执行完osSignalSet(task2Handle,event1)后task2会直接抢占task1</strong></p>
<p><strong>而xTask函数不同于os函数，xTask函数是在task1执行完后才会进入task2，这点请务必记住，二者通知原理不同，所以根据使用情况选择使用xTask函数还是os函数</strong></p>
<h1 id="3、信号量"><a href="#3、信号量" class="headerlink" title="3、信号量"></a>3、信号量</h1><p>信号量同样是一种任务之间交互的函数，但是就我按照网上教程使用过后感觉。。。不如队列和任务通知，可能是我目前的一些工程量还没到使用到信号量的程度？而且在使用过程中也遇到了一些迷惑的地方，所以目前不准备深究，等到实在要用的时候再说吧😋，感兴趣的同学可以去<a href="https://freertos.blog.csdn.net/article/details/50835613">(19条消息) FreeRTOS系列第19篇—FreeRTOS信号量_研究是为了理解的博客-CSDN博客_freertos 信号</a>看看，讲的很详细了可以说，我大部分内容也是跟着这个学的。</p>
]]></content>
      
        
        <tags>
            
            <tag> 嵌入式学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C语言二级查漏补缺（自用）]]></title>
      <url>/2022/08/28/C%E8%AF%AD%E8%A8%80%E4%BA%8C%E7%BA%A7%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<ul>
<li>一个Ｃ语言的源程序（扩展名为．ｃ）在经过编译器编译后，首先生成一个汇编语言程序，然后由编译程序再将汇编语言程序翻译成机器指令程序，即目标程序（扩展名为．ｏｂｊ）。目标程序不可以直接运行，它要和库函数或其他目标程序连接成可执行文件（扩展名为．ｅｘｅ）后方可运行</li>
</ul>
<p>.obj文件不可直接运行</p>
<ul>
<li><p>算法的５个特性为：</p>
<ul>
<li>有穷性</li>
<li>确定性</li>
<li>可行性</li>
<li>有零个或多个输入（可以无输入）</li>
<li>有１个或多个输出（必须有输出）</li>
</ul>
</li>
<li><p>逗号运算符</p>
<p>在C语言中逗号“,”也是一种运算符，称为逗号运算符。 其功能是把两个表达式连接起来组成一个表达式， 称为逗号表达式。其一般形式为：<br>  表达式1, 表达式2<br>其求值过程是分别求两个表达式的值，并以表达式**2(即最右边的一个表达式)**的值作为整个逗号表达式的值。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(x++,<span class="number">2</span>*x)); <span class="number">6</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,x); <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>​		<strong>逗号仅计算结果，并不具有赋值作用</strong>（但是x++有赋值作用）</p>
<ul>
<li><p>算术运算符优先级</p>
<p>优先级的次序如下（由高到低）：（）、++、–、＊、／、％、＋、－</p>
<p>以上所列的运算符，<strong>只有单目运算符正“＋”和负“－”的结合性是从右到左，其余运算符的结合性都是从左到右</strong></p>
<ul>
<li>%对象必须为整型</li>
</ul>
</li>
<li><p>运算库函数</p>
<ul>
<li>abs：绝对值</li>
<li>fabs：双字节型绝对值</li>
<li>pow：x的y次方</li>
<li>exp：求10的x次方</li>
<li>sqrt：x的平方根</li>
</ul>
</li>
</ul>
<p>BCCAA <strong>A</strong>DBB<strong>D</strong> DAC</p>
<ul>
<li>数字的默认类型为整型</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>,<span class="number">1</span>/<span class="number">2</span>); <span class="comment">//0.000000</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>c的基本数据类型：单精度型、双精度型、字符型、整型、枚举型</p>
</li>
<li><p>c负整数补码：所得反码还要+1</p>
</li>
</ul>
<h1 id="三、顺序结构"><a href="#三、顺序结构" class="headerlink" title="三、顺序结构"></a>三、顺序结构</h1><ul>
<li><p>格式字符：</p>
<ul>
<li>%i同%d</li>
<li>%o 八进制</li>
<li>%g&#x2F;G 系统决定采用什么格式（f或e）使输出宽度最小</li>
<li>%p 输出变量地址</li>
</ul>
<p>%m.ns，输出占ｍ列，但只取字符串中左边ｎ个字符。这ｎ个字符输出在ｍ列的右边，<strong>左边补空格</strong></p>
<p>%-m.ns，ｎ个字符<strong>输出在ｍ列范围的左边，右边补空格</strong>。若ｎ＞ｍ，则ｍ自动取ｎ值，即保证ｎ个字符正常输出。</p>
</li>
</ul>
<p>B<strong>BA</strong>BD DACD<strong>D</strong> <strong>C</strong>C<strong>A</strong></p>
<p>BDCBD DACDB DCB    34页</p>
<ul>
<li><p>八进制格式输出开头不带0</p>
</li>
<li><p>逗号优先级低于赋值</p>
</li>
</ul>
<h1 id="四、选择结构"><a href="#四、选择结构" class="headerlink" title="四、选择结构"></a>四、选择结构</h1><ul>
<li><p>逻辑或运算的短路性</p>
<p>如果||前的表达式为真，则不会进行||后的表达式运算(&amp;&amp;以此类推)</p>
</li>
</ul>
<p>DBADD <strong>A</strong>A<strong>A</strong>A<strong>A</strong> AC</p>
<p>DBADD DACAB AC    54页</p>
<h1 id="五、循环结构"><a href="#五、循环结构" class="headerlink" title="五、循环结构"></a>五、循环结构</h1><ul>
<li>while((ch&#x3D;getchar())!&#x3D;’\n’);符合语法</li>
</ul>
<p>AA<strong>AD</strong>C DBBC<strong>C</strong> B<strong>CA</strong></p>
<p>AACBC DBBCB BBC    75页</p>
<h1 id="六、字符型数据"><a href="#六、字符型数据" class="headerlink" title="六、字符型数据"></a>六、字符型数据</h1><ul>
<li><p>转义字符</p>
<p>\f:换页</p>
<p>\ddd: 1~3位八进制数对应字符例如’\123’</p>
<p>\xhh: 1~2位16进制数对应字符例如’\x12’</p>
</li>
</ul>
<p>BA*<u>A</u>*DD DBCB</p>
<p>BA<u><em>C</em></u>DD D<strong>C</strong>CB    85页</p>
<p>3忽略</p>
<ul>
<li>default后无break也会执行（？）</li>
</ul>
<h1 id="七、函数"><a href="#七、函数" class="headerlink" title="七、函数"></a>七、函数</h1><p><strong>C</strong>DD<strong>CB</strong> D<strong>D</strong>D<strong>A</strong>D C</p>
<p>BDDDC DADCD C    102页</p>
<ul>
<li>简单变量作实参时与形参数据的传输方式为单向值传递</li>
<li>return语句中带有++时，返回之后并且作用之后才会++</li>
</ul>
<h1 id="八、指针"><a href="#八、指针" class="headerlink" title="八、指针"></a>八、指针</h1><ul>
<li><p>有<code>int a,*p1=&amp;a;</code>由于&amp;和*运算优先级相同，&amp; *p1则从右至左运算，则&amp; *p1等同于&amp;a</p>
<p>*&amp;a则是等同于 *p1等同于a</p>
</li>
<li><p><strong><code>*</code>的优先级高于+、-,因此<code> *p1</code>&#x3D;<code> *p1</code>+1是将a+1的值存进p内存储的地址所指向的内容中，也就是相当于a&#x3D;a+1；但是a的地址是不变的。</strong></p>
</li>
</ul>
<p>具体对指针的一些理解已添加在<a href="https://dhkkk.gitee.io/2022/07/31/C-%E6%8C%87%E9%92%88/">指针相关复习 | 小董的BLOG (gitee.io)</a>中</p>
<p>DADBB A<u><em>D</em></u>BDB BCC</p>
<p>DADDB A<u><em><strong>C</strong></em></u>BDB BCC  116页</p>
<p>7忽略（第一次全对捏）</p>
<h1 id="九、数组"><a href="#九、数组" class="headerlink" title="九、数组"></a>九、数组</h1><p>CDDBC CBBCD ACA<strong>B</strong></p>
<p>CDDBC CBBCD ACAC   146页</p>
<h1 id="十、字符串"><a href="#十、字符串" class="headerlink" title="十、字符串"></a>十、字符串</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span> *x, <span class="type">char</span> *y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(*x==<span class="string">&#x27;*&#x27;</span>) x++;</span><br><span class="line">	<span class="keyword">while</span>(*y=*x) <span class="comment">//将x所指向的字符赋值给y，直到遇到&#x27;/0&#x27;为止，这样写是正确的</span></span><br><span class="line">	&#123;</span><br><span class="line">		x++;y++;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> s[<span class="number">30</span>]=<span class="string">&quot;******a*b***&quot;</span>,t[<span class="number">30</span>];</span><br><span class="line">	swap(s,t);</span><br><span class="line">	<span class="built_in">puts</span>(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AADCC <strong>DA</strong>BB<strong>D</strong> C<strong>A</strong></p>
<p>AADCC CBBBA CB              173页  6、10、12</p>
<p><strong>strcpy会覆盖原来的整个字符串，而strncpy只会覆盖n个字节原来的字符串，剩下的保留</strong></p>
<h1 id="十一、对函数的进一步讨论"><a href="#十一、对函数的进一步讨论" class="headerlink" title="十一、对函数的进一步讨论"></a>十一、对函数的进一步讨论</h1><ul>
<li><p>传入main的参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span><br></pre></td></tr></table></figure></li>
</ul>
<p>当我们对一个名为test的c文件进行编译时，在终端输入： test  ok  good后：</p>
<ul>
<li><p>argc值为3，即存入argv的字符串个数</p>
</li>
<li><p>argv[0]存放</p>
</li>
<li><p>对指向函数的指针变量进行加减法无意义</p>
</li>
</ul>
<p>CDCD<strong>D</strong> BBCB</p>
<p>CDCDC BBCB 184页</p>
<h1 id="十二、用户标识符的作用域和存储类"><a href="#十二、用户标识符的作用域和存储类" class="headerlink" title="十二、用户标识符的作用域和存储类"></a>十二、用户标识符的作用域和存储类</h1><p>ACDB<strong>A</strong> A<strong>C</strong>CC**<u>D</u>** <strong>C</strong></p>
<p>ACDBB ADCCA D  195页</p>
<ul>
<li>若全局变量和某一函数中局部变量同名，则在函数内全局变量被屏蔽</li>
</ul>
<h1 id="十三、编译预处理和动态存储分配"><a href="#十三、编译预处理和动态存储分配" class="headerlink" title="十三、编译预处理和动态存储分配"></a>十三、编译预处理和动态存储分配</h1><p>详见<a href="https://dhkkk.gitee.io/2022/08/03/C-%E5%85%B3%E9%94%AE%E5%AD%97/">一些关键字 | 小董的BLOG (gitee.io)</a></p>
<p><strong>AACD</strong>C A<strong>D</strong>AA</p>
<p>DBBBC ACAA</p>
<p>define只作替换！！！！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> D1(a) (2*a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> D2(a) (2*(a))</span></span><br><span class="line"><span class="comment">//计算结果最好也用括号括起来,小型计算不括问题应该不大</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="type">int</span> b = D1(<span class="number">3</span>+<span class="number">4</span>);</span><br><span class="line">     <span class="type">int</span> c = D2(<span class="number">3</span>+<span class="number">4</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, b);  <span class="comment">//输出等价于2*3+4=10 ※※※※※※※※※※※※※</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, c);  <span class="comment">//2*(3+4)=14</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="十四、结构体、共用体和用户自定义型"><a href="#十四、结构体、共用体和用户自定义型" class="headerlink" title="十四、结构体、共用体和用户自定义型"></a>十四、结构体、共用体和用户自定义型</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="type">int</span> a;<span class="type">int</span> b;&#125;a;<span class="comment">//合法</span></span><br></pre></td></tr></table></figure>

<p>关于动态链表详见<a href="https://dhkkk.gitee.io/2022/08/01/C-%E7%BB%93%E6%9E%84%E4%BD%93/">结构体复习 | 小董的BLOG (gitee.io)</a></p>
<p>AABB×	<strong>C</strong>CBDD	BC</p>
<p>ADBBA	DCBCD	BD    6题看题不仔细捏</p>
<h1 id="十五、位运算"><a href="#十五、位运算" class="headerlink" title="十五、位运算"></a>十五、位运算</h1><p>长度不同的数据进行位运算时先将最低位对齐，然后将短的一方扩充</p>
<p>D<strong>C</strong>DAA	BCD</p>
<p>DADAA	BCD</p>
<p>看清楚输出的格式声明</p>
<p>240</p>
]]></content>
      
        
        <tags>
            
            <tag> C语言学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[FreeRTOS在CubeMX中的使用]]></title>
      <url>/2022/08/25/FreeRTOS-3/</url>
      <content type="html"><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><p><strong>此篇所有有关函数均为CubeMX 提供的os函数（特殊地方会专门说明），freertos相关用户调用函数也分类似标准库和hal库的区别！但大体用法也与</strong><a href="https://dhkkk.gitee.io/2022/08/23/FreeRTOS-2/">FreeRTOS的任务相关 | 小董的BLOG (gitee.io)</a><strong>中介绍的相似，可以参考</strong></p>
<p><strong>2022.8.26： 阅读了os函数内容并验证后，发现os函数与vtask函数兼容，（其实os函数也是调用的vtask函数）所以理论来说两边的函数可以混用，但是为了可读性等方面尽量还是不要混用</strong></p>
<p><strong>2022.8.28：在自己用了很多功能后，越发觉得库函数比os函数好用，大家自己取舍吧，反正二者是可以混用的，先用cubemx配置，再用库函数编写具体内容也是完全🆗的。</strong></p>
<h1 id="1、配置界面"><a href="#1、配置界面" class="headerlink" title="1、配置界面"></a>1、配置界面</h1><table>
<thead>
<tr>
<th align="center">配置项</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Tasks and Queues</strong></td>
<td align="center">任务与队列，用于配置任务体以及消息队列</td>
</tr>
<tr>
<td align="center"><strong>Timers and Semaphores</strong></td>
<td align="center">软件定时器与信号量，用于配置内核对象 （软件定时器和信号量）</td>
</tr>
<tr>
<td align="center"><strong>Mutexes</strong></td>
<td align="center">互斥量，用于配置内核对象（互斥量）</td>
</tr>
<tr>
<td align="center"><strong>Events</strong></td>
<td align="center">事件，配置内核对象（事件）</td>
</tr>
<tr>
<td align="center"><strong>FreeRTOS Heap Usage</strong></td>
<td align="center">查看用户任务和系统任务的堆占用</td>
</tr>
<tr>
<td align="center"><strong>Config Parameters</strong></td>
<td align="center">系统的参数配置</td>
</tr>
<tr>
<td align="center"><strong>Include Parameters</strong></td>
<td align="center">系统的功能裁剪</td>
</tr>
<tr>
<td align="center"><strong>Advanced Settings</strong></td>
<td align="center">CubeMX 生成代码预配置项</td>
</tr>
<tr>
<td align="center"><strong>User Constants</strong></td>
<td align="center">用户常量定义</td>
</tr>
</tbody></table>
<h2 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h2><img src="/images/loading.png" data-original="/2022/08/25/FreeRTOS-3/%E7%89%88%E6%9C%AC.jpg" class title="This is an image"> 

<p>CMSIS是一种接口标准，目的是屏蔽软硬件差异以提高软件的兼容性。RTOS v1使得软件能够在不同的实时操作系统下运行（屏蔽不同RTOS提供的API的差别），而RTOS v2则是拓展了RTOS v1，兼容更多的CPU架构和实时操作系统。因此我们在使用时可以根据实际情况选择，如果学习过程中使用STM32F1、F4等单片机时没必要选择RTOS v2，更高的兼容性背后时更加冗余的代码，理解起来比较困难。</p>
<h1 id="2、各配置详细设置"><a href="#2、各配置详细设置" class="headerlink" title="2、各配置详细设置"></a>2、各配置详细设置</h1><h2 id="一、Config-Parameters——系统的参数配置"><a href="#一、Config-Parameters——系统的参数配置" class="headerlink" title="一、Config Parameters——系统的参数配置"></a><strong>一、Config Parameters——系统的参数配置</strong></h2><h3 id="1-Kernel-Setting——FreeRTOS-调度内核设置"><a href="#1-Kernel-Setting——FreeRTOS-调度内核设置" class="headerlink" title="1.Kernel Setting——FreeRTOS 调度内核设置"></a>1.Kernel Setting——FreeRTOS 调度内核设置</h3><p>由于一些重要配置已在<a href="https://dhkkk.gitee.io/2022/08/18/FreeRTOS-1/">FreeRTOS_基本框架 | 小董的BLOG (gitee.io)</a>中讲到，因此本文只会记录一些容易搞混的地方</p>
<ul>
<li><p><strong>USE_PREEMPTION</strong></p>
<p>USE_PREEMPTION 是 RTOS 的调度方式选择，为 1 时使用抢占式调度器，为 0 时使用协程。</p>
<p>当使用协程的话会在如下地方进行任务切换：</p>
<ol>
<li>一个任务调用了函数 taskYIELD()。</li>
<li>一个任务调用了可以使任务进入阻塞态的 API 函数。</li>
<li>应用程序明确定义了在中断中执行上下文切换。</li>
</ol>
</li>
</ul>
<ul>
<li><p><strong>USE_MUTEXES、USE_RECURSIVE_MUTEXES、USE_COUNTING_SEMAPHORES</strong></p>
<p>为 1 则开启系统构建过程中的互斥量、递归互斥量和信号量,默认开启就可。</p>
</li>
<li><p><strong>QUEUE_REGISTRY_SIZE</strong></p>
<p>队列注册表的大小，可以用于管理队列名称和队列实体，方便运行中进行查看与管理，默认为8</p>
</li>
<li><p><strong>ENABLE_BACKWARD_COMPATIBILITY</strong></p>
<p>一个兼容性使能，使能后， FreeRTOS 8.0.0 之后的版本可以通过宏定义使用 8.0.0 版本之前的函数接口，默认使能</p>
</li>
<li><p><strong>USE_TASK_NOTIFICATIONS</strong></p>
<p>任务通知使能，每个RTOS任务都有一个32位的通知值，RTOS任务通知是一个直接发送给任务的事件，它可以解除接收任务的阻塞，并可选地更新接收任务的通知值，为1开启，为0关闭，关闭可以为每个任务节省8个字节的内存空间</p>
</li>
<li><p><strong>RECORD_STACK_HIGH_ADDRESS</strong></p>
<p>记录任务的堆栈入口地址到TCB，为1使能，为0关闭</p>
</li>
</ul>
<h3 id="2-Memory-management-setting——内存管理设置"><a href="#2-Memory-management-setting——内存管理设置" class="headerlink" title="2.Memory management setting——内存管理设置"></a><strong>2.Memory management setting</strong>——内存管理设置</h3><p>视情况调整即可，内存分配方式默认heap_4，方便完善。</p>
<h3 id="3-Hook-function-relateed-difinitions——钩子函数配置"><a href="#3-Hook-function-relateed-difinitions——钩子函数配置" class="headerlink" title="3.Hook function relateed difinitions——钩子函数配置"></a>3.Hook function relateed difinitions——钩子函数配置</h3><p><strong>钩子函数是一种回调函数，用于在任务执行一次之后或者某些事件发生后执行的函数</strong>，该配置项里面有五个选项，控制5种不同功能的钩子函数开启，当然用户也可以在代码中自己定义</p>
<ul>
<li><p><strong>USE_IDLE_HOOK</strong></p>
<p>每当空闲任务执行一次，钩子函数都会被执行一次</p>
</li>
</ul>
<ul>
<li><p><strong>USE_TICK_HOOK</strong></p>
<p>每个TICK周期，钩子函数都会执行一次</p>
</li>
<li><p><strong>USE_MALLOC_FAILED_HOOK</strong></p>
<p>当申请动态内存失败时，钩子函数会执行一次(需要额外配置申请动态内存失败的相关事项)</p>
</li>
</ul>
<ul>
<li><p><strong>USE_DAEMON_TASK_STARTUP_HOOK</strong></p>
<p>任务刚启动时，钩子函数会执行一次</p>
</li>
<li><p><strong>CHECK_FOR_STACK_OVERFLOW</strong></p>
<p>任务栈溢出时，钩子函数会执行一次，传入任务 TCB 和任务名称（也需要额外配置）</p>
</li>
</ul>
<h3 id="4-Run-time-and-task-stats…-——任务运行追踪配置"><a href="#4-Run-time-and-task-stats…-——任务运行追踪配置" class="headerlink" title="4.Run time and task stats… ——任务运行追踪配置"></a>4.Run time and task stats… ——任务运行追踪配置</h3><ul>
<li><p><strong>GENERATE_RUN_TIME_STATS</strong></p>
<p>开启时间统计功能，在调用 vTaskGetRunTimeStats() 函数时，<strong>将任务运行时间信息保存到可读列表中</strong></p>
</li>
<li><p><strong>USE_TRACE_FACILITY</strong></p>
<p>使能后会包含额外的结构成员和函数以帮助执行可视化和跟踪，<strong>默认开启，方便 MDK 软件工具调试使用</strong></p>
</li>
<li><p><strong>USE_STATS_FORMATTING_FUNCTIONS</strong></p>
<p>使能后会<strong>生成 vTaskList() 和 vTaskGetRunTimeStats() 函数用于获取任务运行状态</strong></p>
</li>
</ul>
<h3 id="5-Co-routine-ralated-definitions——协程配置"><a href="#5-Co-routine-ralated-definitions——协程配置" class="headerlink" title="5.Co-routine ralated definitions——协程配置"></a>5.Co-routine ralated definitions——协程配置</h3><p>默认不开启，协程现在几乎很少使用且FreeRTOS不再更新和维护协程。</p>
<h3 id="6-Software-timer-definitions——软件定时器配置"><a href="#6-Software-timer-definitions——软件定时器配置" class="headerlink" title="6.Software timer definitions——软件定时器配置"></a>6.Software timer definitions——软件定时器配置</h3><p>默认即可。</p>
<h3 id="7-Interrupt-nesting-behavior-configuration——优先级配置"><a href="#7-Interrupt-nesting-behavior-configuration——优先级配置" class="headerlink" title="7.Interrupt nesting behavior configuration——优先级配置"></a>7.Interrupt nesting behavior configuration——优先级配置</h3><p>具体参数在<a href="https://dhkkk.gitee.io/2022/08/18/FreeRTOS-1/">FreeRTOS_基本框架 | 小董的BLOG (gitee.io)</a>已有详细描述，不再赘述。</p>
<h2 id="二、Include-Parameters——系统的功能裁剪"><a href="#二、Include-Parameters——系统的功能裁剪" class="headerlink" title="二、Include Parameters——系统的功能裁剪"></a><strong>二、Include Parameters</strong>——系统的功能裁剪</h2><p>Include Parameters 下的选项应用于内核裁剪，裁剪不必要的功能，精简系统功能，减少资源占用</p>
<table>
<thead>
<tr>
<th align="center"><strong>选项</strong></th>
<th align="center"><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">vTaskPrioritySet</td>
<td align="center">改变某个任务的任务优先级</td>
</tr>
<tr>
<td align="center">uxTaskPriorityGet</td>
<td align="center">查询某个任务的优先级</td>
</tr>
<tr>
<td align="center">vTaskDelete</td>
<td align="center">删除任务</td>
</tr>
<tr>
<td align="center">vTaskCleanUpResources</td>
<td align="center">回收任务删除后的资源如RAM等等</td>
</tr>
<tr>
<td align="center">vTaskSuspend</td>
<td align="center">挂起任务</td>
</tr>
<tr>
<td align="center">vTaskDelayUntil</td>
<td align="center">阻塞延时一段绝对时间</td>
</tr>
<tr>
<td align="center">vTaskDelay</td>
<td align="center">阻塞延时一段相对时间</td>
</tr>
<tr>
<td align="center">xTaskGetSchedulerState</td>
<td align="center">获取任务调度器的状态，开启或未开启</td>
</tr>
<tr>
<td align="center">xTaskResumeFromISR</td>
<td align="center">在中断服务函数中恢复一个任务的运行</td>
</tr>
<tr>
<td align="center">xQueueGetMutexHolder</td>
<td align="center">获取信号量的队列拥有者，返回拥有此信号量的队列</td>
</tr>
<tr>
<td align="center">xSemaphoreGetMutexHolder</td>
<td align="center">查询拥有互斥锁的任务，返回任务控制块</td>
</tr>
<tr>
<td align="center">pcTaskGetTaskName</td>
<td align="center">获取任务名称</td>
</tr>
<tr>
<td align="center">uxTaskGetStackHighWaterMark</td>
<td align="center">获取任务的堆栈的历史剩余最小值</td>
</tr>
<tr>
<td align="center">xTaskGetCurrentTaskHandle</td>
<td align="center">此函数用于获取当前任务的任务句柄</td>
</tr>
<tr>
<td align="center">eTaskGetState</td>
<td align="center">此函数用于查询某个任务的运行壮态</td>
</tr>
<tr>
<td align="center">xEventGroupSetBitFromISR</td>
<td align="center">在中断服务函数中将指定的事件位清零</td>
</tr>
<tr>
<td align="center">xTimerPendFunctionCall</td>
<td align="center">定时器守护任务的回调函数（定时器守护任务使用到一个命令队列，只要向队列发送信号就可以执行相应代码，可以实现“中断推迟处理”功能）</td>
</tr>
<tr>
<td align="center">xTaskAbortDelay</td>
<td align="center">中止延时函数，该函数能立即解除任务的阻塞状态，将任务插入就绪列表中</td>
</tr>
<tr>
<td align="center">xTaskGetHandle</td>
<td align="center">此函数根据任务名字获取的任务句柄</td>
</tr>
</tbody></table>
<h2 id="三、Tasks-and-Queues——创建任务与队列"><a href="#三、Tasks-and-Queues——创建任务与队列" class="headerlink" title="三、Tasks and Queues——创建任务与队列"></a><strong>三、Tasks and Queues</strong>——创建任务与队列</h2><h3 id="1-任务创建"><a href="#1-任务创建" class="headerlink" title="1.任务创建"></a>1.任务创建</h3><img src="/images/loading.png" data-original="/2022/08/25/FreeRTOS-3/freertos_taskadd.jpg" class title="This is an image"> 

<p>具体内容已在<a href="https://dhkkk.gitee.io/2022/08/23/FreeRTOS-2/">FreeRTOS的任务相关 | 小董的BLOG (gitee.io)</a>中讲到，需要注意的是：</p>
<ul>
<li><p>Task Name为任务<strong>名称</strong>，Entry Function才是任务实体，即运行的<strong>任务函数入口</strong>（函数名）</p>
</li>
<li><p>任务的优先级细分有各等级优先级，详见文章最后对于优先级问题的理解</p>
</li>
<li><p>Code Generation为代码生成模式，细分为</p>
<ul>
<li>As weak： 产生一个用 __weak 修饰的弱定义任务函数，用户可自己再进行定义</li>
<li>As external： 产生一个外部引用的任务函数，用户需要自己定义该函数</li>
<li>Default： 产生一个默认格式的任务函数，用户需要在该函数内实现自己的功能</li>
</ul>
<p>一般使用默认格式即可</p>
</li>
<li><p>Allocation为定义内存分配方式，分为静态与动态，与c语言中static用法类似</p>
</li>
</ul>
<h4 id="CubeMX-提供的一些用户调用函数"><a href="#CubeMX-提供的一些用户调用函数" class="headerlink" title="CubeMX 提供的一些用户调用函数"></a>CubeMX 提供的一些用户调用函数</h4><table>
<thead>
<tr>
<th align="center"><strong>函数</strong></th>
<th align="center"><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">osThreadNew</td>
<td align="center">创建新任务</td>
</tr>
<tr>
<td align="center">osThreadGetName</td>
<td align="center">获取任务名称</td>
</tr>
<tr>
<td align="center">osThreadGetId</td>
<td align="center">获取当前任务的控制块（TCB）</td>
</tr>
<tr>
<td align="center">osThreadGetState</td>
<td align="center">获取当前任务的运行状态</td>
</tr>
<tr>
<td align="center">osThreadGetStackSize</td>
<td align="center">获取任务的堆栈大小</td>
</tr>
<tr>
<td align="center">osThreadGetStackSpace</td>
<td align="center">获取任务剩余的堆栈大小</td>
</tr>
<tr>
<td align="center">osThreadSetPriority</td>
<td align="center">设定任务优先级</td>
</tr>
<tr>
<td align="center">osThreadGetPriority</td>
<td align="center">获取任务优先级</td>
</tr>
<tr>
<td align="center">osThreadYield</td>
<td align="center">切换控制权给下一个任务</td>
</tr>
<tr>
<td align="center">osThreadSuspend</td>
<td align="center">挂起任务</td>
</tr>
<tr>
<td align="center">osThreadResume</td>
<td align="center">恢复任务（挂起多少次恢复多少次）</td>
</tr>
<tr>
<td align="center">osThreadDetach</td>
<td align="center">分离任务，方便任务结束进行回收</td>
</tr>
<tr>
<td align="center">osThreadJoin</td>
<td align="center">等待指定的任务停止</td>
</tr>
<tr>
<td align="center">osThreadExit</td>
<td align="center">停止当前任务</td>
</tr>
<tr>
<td align="center">osThreadTerminate</td>
<td align="center">停止指定任务</td>
</tr>
<tr>
<td align="center">osThreadGetCount</td>
<td align="center">获取激活的任务数量</td>
</tr>
<tr>
<td align="center">osThreadEnumerate</td>
<td align="center">列举激活的任务</td>
</tr>
</tbody></table>
<h3 id="2-队列创建"><a href="#2-队列创建" class="headerlink" title="2.队列创建"></a>2.队列创建</h3><p>FreeRTOS中的队列是一种用于实现【任务与任务】，【任务与中断】以及【中断与任务】之间的通信机制。此外，任务从队列读数据或者写入数据到队列时，都可能被阻塞。这个特性使得任务可以被设计成基于事件驱动的运行模式，大大提高了CPU的执行效率。队列是实现FreeRTOS中其他特性的基础组件，像软件定时器，信号量，互斥锁都是基于队列而实现的。</p>
<p>在操作系统里面，直接使用全局变量传输数据十分危险，看似正常运行，但不知道啥时候就会因为寄存器或者内存等等原因引起崩溃，所以引入消息，队列的概念。</p>
<h4 id="队列的基本特性"><a href="#队列的基本特性" class="headerlink" title="队列的基本特性"></a>队列的基本特性</h4><p>队列是一种FIFO操作的数据结构，入队操作就是把一个新的元素放进队尾(tail)，出队操作就是从队头(front)取出一个元素。FreeRTOS中也支持把一个元素放到队头的操作，这个操作会<strong>覆盖</strong>之前队头的元素。</p>
<h4 id="入队策略"><a href="#入队策略" class="headerlink" title="入队策略"></a>入队策略</h4><p>队列在设计的时候，主要有两种元素入队存储策略：Queue by copy 和 Queue by reference。FreeRTOS的队列使用的是Queue by copy存储策略，考虑到这种策略实现起来更加简单，灵活，且安全。</p>
<ul>
<li>Queue by copy：数据入队的时候，队列中存储的是此数据的一份拷贝</li>
<li>Queue by reference：数据队列的时候，队列中存储的是数据的指针，而非数据本身</li>
</ul>
<h4 id="入队堵塞"><a href="#入队堵塞" class="headerlink" title="入队堵塞"></a>入队堵塞</h4><p>一个任务在尝试写入数据到队列时，可以指定一个阻塞时间，即任务在<strong>等待队列有空余空间（非满）可写前最长等待阻塞时间</strong>。当队列中有空间可写入时，任务会自动从阻塞态转换为就绪态。如果在等待时间内队列一直是满的，则等待时间到期后，任务也会自动从阻塞态转换为就绪态，但是它会返回一个写入失败的结果。</p>
<p>队列可能有多个writerTask，所以在等待队列有空闲空间时，可能会有多个任务阻塞。<strong>当队列有空闲空间可写时，调度器会从所有阻塞的任务中选取优先级最高的那个任务让其进入到就绪态</strong>。<strong>如果最高优先级的不止一个，则让等待最久的那个进入到就绪态。</strong></p>
<h4 id="出队堵塞"><a href="#出队堵塞" class="headerlink" title="出队堵塞"></a><strong>出队堵塞</strong></h4><p>一个任务在尝试从队列中读取数据时，可以指定一个阻塞时间，即任务在等待队列有元素可读前最长等待阻塞时间。当队列中有元素可读时，任务会自动从阻塞态转换为就绪态。如果在等待时间内队列一直没有数据可读，则等待时间到期后，任务也会自动从阻塞态转换为就绪态，但是它会返回一个读取失败的结果。</p>
<p>队列可能有多个reader Task，所以在等待队列有数据可读时，可能会有多个任务阻塞。<strong>当队列有数据可读时，调度器会从所有阻塞的任务中选取优先级最高的那个任务让其进入到就绪态。如果最高优先级的不止一个，则让等待最久的那个进入到就绪态。</strong></p>
<h4 id="相关API函数（非os函数，原博客中提供的os函数不适用于v1版本）（已测试，可用）"><a href="#相关API函数（非os函数，原博客中提供的os函数不适用于v1版本）（已测试，可用）" class="headerlink" title="相关API函数（非os函数，原博客中提供的os函数不适用于v1版本）（已测试，可用）"></a>相关API函数（非os函数，原博客中提供的os函数不适用于v1版本）（已测试，可用）</h4><ul>
<li><p>队列创建</p>
<p>使用xQueueCreate()内核函数来创建一个队列。队列的1存储空间从FreeRTOS heap中分配。在使用xQueueCreate()创建队列时，如果FreeRTOS heap中没有足够的存储空间分配给当前队列，则函数返回NULL。如果创建成功，则返回队列的句柄(QueueHandle_t类型)</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize );</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center"><strong>uxQueueLength</strong>：指定队列的长度，即最多可以存放的元素个数<br><strong>uxItemSize</strong>：队列中存储的元素的大小（占用的字节数）</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">返回NULL代表创建失败，没有足够的堆空间来创建当前队列；创建成功则返回队列的句柄</td>
</tr>
</tbody></table>
<ul>
<li><p>元素入队</p>
<p>使用xQueueSendToBack()函数来向队尾存放一个元素，使用xQueueSend()函数来向队首存放一个元素，两个函数用法一样</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">BaseType_t xQueueSendToBack( QueueHandle_t xQueue,<br>                                                                        const void * pvItemToQueue,<br>                                                       TickType_t xTicksToWait );</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center"><strong>xQueue</strong>：目标队列的句柄<br><strong>pvItemToQueue</strong>：入队元素的指针。队列将存储此指针指向的数据的备份<br><strong>xTicksToWait</strong>：指定等待队列有空间可以容纳新元素入队的最长等待（阻塞）时间</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">当元素成功入队时返回pdPASS，因为队列满而无法入队时返回errQUEUE_FULL（超时后）</td>
</tr>
</tbody></table>
<ul>
<li><p>元素出队</p>
<p>使用xQueueReceive()内核函数来从队列中读取队头元素，<strong>读取成功后队列将删除这个元素</strong>，实现元素出队操作。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">BaseType_t xQueueReceive( QueueHandle_t xQueue,<br>                                                  void * const pvBuffer,<br>                                              TickType_t xTicksToWait );</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center"><strong>xQueue</strong>：目标队列的句柄<br><strong>pvBuffer</strong>：用于存放读取到的队列元素的缓冲区，队列将把出队的元素拷贝到此缓冲区中<br><strong>xTicksToWait</strong>：指定等待队列有数据可读的最长等待（阻塞）时间</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">当成功从队列读取到元素时返回pdPASS，因为队列空而无法出队时返回errQUEUE_EMPTY</td>
</tr>
</tbody></table>
<ul>
<li><p>查询队列元素个数</p>
<p>使用内核函数uxQueueMessagesWaiting()来获取队列中有多少个元素</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">UBaseType_t uxQueueMessagesWaiting( QueueHandle_t xQueue );</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center"><strong>xQueue</strong>：队列的句柄</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">队列中的元素个数，返回0代表队列为空</td>
</tr>
</tbody></table>
<p>老规矩，来个按键例程（可以正常运行）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span> <span class="comment">//低优先级任务</span></span><br><span class="line">&#123;</span><br><span class="line">  BaseType_t result; </span><br><span class="line">  <span class="type">uint8_t</span> dat[]=<span class="string">&quot;666\r\n&quot;</span>;</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">	<span class="keyword">if</span>(HAL_GPIO_ReadPin(key_1_GPIO_Port,key_1_Pin == GPIO_PIN_SET))</span><br><span class="line">	&#123;</span><br><span class="line">		result= xQueueSendToBack(myQueue01Handle,dat,portMAX_DELAY);</span><br><span class="line">		<span class="keyword">if</span>(result==pdPASS)</span><br><span class="line">		&#123;</span><br><span class="line">			HAL_GPIO_WritePin(led_g_GPIO_Port,led_g_Pin,GPIO_PIN_RESET);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">   	osDelay(<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span> <span class="comment">//高优先级任务</span></span><br><span class="line">&#123;</span><br><span class="line">  BaseType_t result;</span><br><span class="line">  <span class="type">uint8_t</span> datbuf[<span class="number">10</span>]; <span class="comment">//随便定义个缓冲区就可以</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">	result=xQueueReceive(myQueue01Handle,datbuf,portMAX_DELAY);</span><br><span class="line">	<span class="keyword">if</span>(result==pdPASS)</span><br><span class="line">	&#123;</span><br><span class="line">		HAL_GPIO_WritePin(led_r_GPIO_Port,led_r_Pin,GPIO_PIN_RESET);</span><br><span class="line">	&#125;</span><br><span class="line">	osDelay(<span class="number">10</span>);</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>懒得去找os函数了，库函数挺好用的是吧😋</p>
<h2 id="四、事件-组"><a href="#四、事件-组" class="headerlink" title="四、事件(组)"></a>四、事件(组)</h2><h3 id="写在前面2022-8-27"><a href="#写在前面2022-8-27" class="headerlink" title="写在前面2022.8.27"></a>写在前面2022.8.27</h3><p><strong>目前网上对于os函数的使用教程很少，而且大部分都有问题，本小节讲到的os函数使用方法感觉BUG是真的多，搞了整整两天也无法完全实现想要的功能，而且总是一些莫名其妙的问题，感觉是与任务调度有关，但是始终没找到真正原因，人都麻了QAQ。所以本小节（事件）仅提供思路，无法保证能正常运行。（新手建议直接跳过，高手可以找找原因）</strong></p>
<p><strong>在尝试两天发现效果极差后，果断换任务通知的方法，使用起来可以说很丝滑了，第一次用就可以正常实现功能（从未如此美妙的开局！！）也基本能代替事件通知的功能，建议直接使用任务通知（见下文）</strong></p>
<p><strong>没有试过库函数，因为发现任务通知够用了，感兴趣的同学可以试一下</strong></p>
<p><em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>分割线</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>***********************</p>
<ul>
<li>先列出cubemx提供的事件组函数：</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>函数</strong></th>
<th align="center"><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">osEventFlagsNew</td>
<td align="center">创建事件标志组</td>
</tr>
<tr>
<td align="center">*osEventFlagsGetName</td>
<td align="center">获取事件标志组名称</td>
</tr>
<tr>
<td align="center">osEventFlagsSet</td>
<td align="center">设置事件标志组</td>
</tr>
<tr>
<td align="center">osEventFlagsClear</td>
<td align="center">清除事件标志组</td>
</tr>
<tr>
<td align="center">osEventFlagsGet</td>
<td align="center">获取当前事件组标志信息</td>
</tr>
<tr>
<td align="center">osEventFlagsWait</td>
<td align="center">等待事件标志组触发</td>
</tr>
<tr>
<td align="center">osEventFlagsDelete</td>
<td align="center">删除事件标志组</td>
</tr>
</tbody></table>
<h3 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h3><p><em>对于网络上的解释感觉有点晦涩难懂，自己总结了容易理解的方法，仅供参考</em></p>
<p>事件的作用主要是实现任务间通信的机制，主要用于实现多任务间的同步，但是事件类型通信只能是<strong>事件类型的通信</strong>，<strong>没有数据传输</strong></p>
<p>使用流程：</p>
<ul>
<li>在cubemx中配置相关事件句柄等</li>
<li>在程序中定义触发事件位</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> event1 1&lt;&lt;1 	<span class="comment">//事件1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> event2 1&lt;&lt;2 	<span class="comment">//事件2</span></span></span><br></pre></td></tr></table></figure>

<p>事件标志组中的所有事件位都存储在一个无符号的 EventBits_t 类型的变量（<strong>事件组</strong>）中（例如下文中的result），当 configUSE_16_BIT_TICKS 为 1 的时候事件标志组可以存储 8 个事件位，当 configUSE_16_BIT_TICKS 为 0 的时候事件标志组存储 24个事件位，每个事件位其实就是一个0或者1数字</p>
<ul>
<li>定义事件组（在触发任务和使用到等待事件函数的任务中均需定义，定义成局部变量感觉方便点）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osStatus_t result;<span class="comment">//也可以用 EventBits_t 不过过程会麻烦一点</span></span><br></pre></td></tr></table></figure>

<p>以下是对osStatus_t的定义，方便查阅</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  osOK                      =  <span class="number">0</span>,         <span class="comment">///&lt; Operation completed successfully.</span></span><br><span class="line">  osError                   = <span class="number">-1</span>,         <span class="comment">///&lt; Unspecified RTOS error: run-time error but no other error message fits.</span></span><br><span class="line">  osErrorTimeout            = <span class="number">-2</span>,         <span class="comment">///&lt; Operation not completed within the timeout period.</span></span><br><span class="line">  osErrorResource           = <span class="number">-3</span>,         <span class="comment">///&lt; Resource not available.</span></span><br><span class="line">  osErrorParameter          = <span class="number">-4</span>,         <span class="comment">///&lt; Parameter error.</span></span><br><span class="line">  osErrorNoMemory           = <span class="number">-5</span>,         <span class="comment">///&lt; System is out of memory: it was impossible to allocate or reserve memory for the operation.</span></span><br><span class="line">  osErrorISR                = <span class="number">-6</span>,         <span class="comment">///&lt; Not allowed in ISR context: the function cannot be called from interrupt service routines.</span></span><br><span class="line">  osStatusReserved          = <span class="number">0x7FFFFFFF</span>  <span class="comment">///&lt; Prevents enum down-size compiler optimization.</span></span><br><span class="line">&#125; osStatus_t;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>设置事件标志（触发条件）</p>
<p>以按键触发为例：（可以正常运行）</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">event</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">	osStatus_t result;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(key_1_GPIO_Port,key_1_Pin)!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result = osEventFlagsSet(key_pHandle,event1);</span><br><span class="line">            <span class="keyword">if</span>(result == osOK)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;事件1触发成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;事件1触发失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(key_2_GPIO_Port,key_2_Pin)!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result = osEventFlagsSet(key_pHandle,event2);</span><br><span class="line">            <span class="keyword">if</span>(result == osOK)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;事件2触发成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;事件2触发失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>等待事件标志</li>
</ul>
<p>等待函数参数介绍：</p>
<p><code>uint32_t osEventFlagsWait (osEventFlagsId_t ef_id, uint32_t flags, uint32_t options, uint32_t timeout);</code></p>
<table>
<thead>
<tr>
<th align="center"><strong>参数</strong></th>
<th align="center"><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">ef_id</td>
<td align="center">事件标志组控制句柄</td>
</tr>
<tr>
<td align="center">flags</td>
<td align="center">等待的事件位</td>
</tr>
<tr>
<td align="center">options</td>
<td align="center">等待事件位的操作<br>osFlagsWaitAny ：等待的事件位有任意一个等到就恢复任务<br>osFlagsWaitAll：等待的事件位全部等到才恢复任务<br>osFlagsNoClear：等待成功后不清楚所等待的标志位（默认清除）</td>
</tr>
<tr>
<td align="center">timeout</td>
<td align="center">等待事件组的等待时间（等待期间任务挂起在内核对象的挂起队列）</td>
</tr>
</tbody></table>
<p>使用例子：同时等待事件1和事件2，且等待到不清除</p>
<p><strong>（该任务由于未知原因不能正常运行，仅提供思路）</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait_task</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">	osStatus_t result;</span><br><span class="line">	<span class="keyword">for</span>(;;)</span><br><span class="line">	&#123;</span><br><span class="line">		result = osEventFlagsWait(myEvent01Handle,</span><br><span class="line">								  event1|event2,</span><br><span class="line">								  osFlagsWaitAll,</span><br><span class="line">								  <span class="number">10</span>);</span><br><span class="line">		<span class="keyword">if</span>(result == osOK)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="comment">//可使用阻塞、挂起等方式进入其他任务或直接在此处进行其他操作</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">		<span class="comment">//未触发等待</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、任务通知"><a href="#五、任务通知" class="headerlink" title="五、任务通知"></a>五、任务通知</h2><h3 id="写在前面-2022-8-27"><a href="#写在前面-2022-8-27" class="headerlink" title="写在前面 2022.8.27"></a>写在前面 2022.8.27</h3><p><strong>本文最开始参考的是<a href="https://blog.csdn.net/qq_45396672/article/details/120877303?ops_request_misc=%7B%22request_id%22:%22166155998716782395375007%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166155998716782395375007&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-120877303-null-null.142%5Ev42%5Econtrol,185%5Ev2%5Etag_show&utm_term=freertos"> CubeMX使用FreeRTOS编程指南_Top嵌入式的博客-CSDN博客_cubemx freertos</a>但是在实际使用的过程中可以说有很多漏洞甚至错误，本小节在参考博客中所提供的flag函数好像根本不是任务通知的函数（？）并且其所说的使用方法中连函数的入口参数都写错了，（不晓得他自己跑过自己写的程序没有😅）所以关于flag相关函数在这里仅提供函数内容，用法就不探索了，后面会讲到我实际跑过并可以使用的任务通知函数。</strong></p>
<h3 id="flag相关函数介绍"><a href="#flag相关函数介绍" class="headerlink" title="flag相关函数介绍"></a>flag相关函数介绍</h3><p>FreeRTOS 的每个任务都有一个 32 位的通知值，任务控制块中的成员变量 ulNotifiedValue 就是这个通知值。任务通知是一个事件，假如某个任务通知的接收任务因为等待任务通知而阻塞的话，向这个接收任务发送任务通知以后就会解除这个任务的阻塞状态，CubeMX内没有提供相关的配置项，但在其生成的 FreeRTOS 接口里面有相关函数进行配置。</p>
<table>
<thead>
<tr>
<th align="center"><strong>函数</strong></th>
<th align="center"><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">osThreadFlagsSet</td>
<td align="center">设置任务的通知标志</td>
</tr>
<tr>
<td align="center">osThreadFlagsClear</td>
<td align="center">清除任务通知</td>
</tr>
<tr>
<td align="center">osThreadFlagsGet</td>
<td align="center">获取任务标志</td>
</tr>
<tr>
<td align="center">osThreadFlagsWait</td>
<td align="center">等待特定的任务标志</td>
</tr>
</tbody></table>
<p><strong>常用osThreadFlagsSet，osThreadFlagsWait，使用方式与事件触发相同</strong>，不再细说，仅介绍一下函数参数</p>
<p><code>uint32_t osThreadFlagsWait (uint32_t flags, uint32_t options, uint32_t timeout);</code></p>
<p>其中options的参数：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td>osFlagsWaitAny</td>
<td>等待32位通知值任意一位触发后恢复任务（默认）</td>
</tr>
<tr>
<td>osFlagsWaitAll</td>
<td>等待指定的任务通知值全部触发后再恢复任务</td>
</tr>
<tr>
<td>osFlagsNoClear</td>
<td>恢复任务后不清除任务标志（默认清除）</td>
</tr>
</tbody></table>
<p><strong>任务通知其实个任务事件标志组使用上没有多大的区别，但他们两个的实现原理不同，同时任务通知对资源的占用更少</strong></p>
<p><strong>根据 FreeRTOS 官方的统计，使用任务通知替代二值信号量的时候任务解除阻 塞的时间要快 45%，并且需要的 RAM 也更少</strong></p>
<h3 id="可以实际使用的任务通知"><a href="#可以实际使用的任务通知" class="headerlink" title="可以实际使用的任务通知"></a>可以实际使用的任务通知</h3><p>使用前记得在cubemx配置中开启<code>USE_TASK_NOTIFICATIONS</code>和在include parameters里开启<code>eTaskGetState</code></p>
<p>FreeRTOS 提供以下几种方式发送通知给任务 ：</p>
<ul>
<li>发送通知给任务， 如果有通知未读，不覆盖通知值。</li>
<li>发送通知给任务，直接覆盖通知值。</li>
<li>发送通知给任务，设置通知值的一个或者多个位 ，可以当做事件组来使用。</li>
<li>发送通知给任务，递增通知值，可以当做计数信号量使用。</li>
</ul>
<p>通过对以上任务通知方式的合理使用，可以在一定场合下替代 FreeRTOS 的信号量，队列、事件组等。</p>
<h4 id="相关api函数："><a href="#相关api函数：" class="headerlink" title="相关api函数："></a>相关api函数：</h4><ul>
<li>向指定任务发送任务通知</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>函数</strong></th>
<th align="center"><strong>int32_t osSignalSet (osThreadId thread_id, int32_t signal)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center"><strong>thread_id：</strong> 接收通知的任务ID<br><strong>signal：</strong>任务通知值（按位操作数字）</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">错误码</td>
</tr>
</tbody></table>
<ul>
<li>等待任务通知</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>函数</strong></th>
<th align="center"><strong>osEvent osSignalWait (int32_t signals, uint32_t millisec)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center">signals： 接收完成后等待被清零的数据位(0x0001|0x0002&#x3D;0x003)<br><strong>millisec：</strong> 等待超时时间，单位为系统节拍周期</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">错误码</td>
</tr>
</tbody></table>
<h4 id="实例（按键触发任务通知，已经过验证）"><a href="#实例（按键触发任务通知，已经过验证）" class="headerlink" title="实例（按键触发任务通知，已经过验证）"></a>实例（按键触发任务通知，已经过验证）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> event1 0x0001</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span> <span class="comment">//低优先级任务</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN led_G */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">		<span class="keyword">if</span>(HAL_GPIO_ReadPin(key_1_GPIO_Port,key_1_Pin == GPIO_PIN_SET))</span><br><span class="line">		&#123;</span><br><span class="line">			osSignalSet(task2Handle,event1);</span><br><span class="line">		&#125;	</span><br><span class="line">		osDelay(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END led_G */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span> <span class="comment">//高优先级任务</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN led_B */</span></span><br><span class="line">	osEvent event;	</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">	event = osSignalWait(event1,osWaitForever);  </span><br><span class="line">	<span class="keyword">if</span>(event.status == osEventSignal)  </span><br><span class="line">	&#123;</span><br><span class="line">		HAL_GPIO_WritePin(led_g_GPIO_Port,led_g_Pin,GPIO_PIN_RESET);</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里task2可以不用额外在循环中添加堵塞，因为wait函数本身自带堵塞，<strong>其堵塞的解除是在osSignalSet函数的作用之后的瞬间，也就是说在执行完osSignalSet(task2Handle,event1)后task2会直接抢占task1</strong></p>
<p><strong>而xTask函数则是在task1执行完后才会进入task2，这点请务必记住，二者通知原理不同，使用方法因此也不同</strong></p>
<h2 id="其他的内容以后再来探索吧（指还没学到）XD"><a href="#其他的内容以后再来探索吧（指还没学到）XD" class="headerlink" title="其他的内容以后再来探索吧（指还没学到）XD"></a>其他的内容以后再来探索吧（指还没学到）XD</h2><h1 id="遇见的一些问题"><a href="#遇见的一些问题" class="headerlink" title="遇见的一些问题"></a>遇见的一些问题</h1><h2 id="一、FreeRTOS的时钟源配置"><a href="#一、FreeRTOS的时钟源配置" class="headerlink" title="一、FreeRTOS的时钟源配置"></a>一、FreeRTOS的时钟源配置</h2><p>当使用了FreeRtos的时候，建议HAL库使用除了Systick以外的时钟源。也就是说当不使用FreeRtos的时候，HAL使用的是systick作为时钟源，现在使用了rtos，不建议hal库和rtos一起使用systick作为时钟源</p>
<h2 id="二、优先级问题"><a href="#二、优先级问题" class="headerlink" title="二、优先级问题"></a>二、优先级问题</h2><img src="/images/loading.png" data-original="/2022/08/25/FreeRTOS-3/2.jpg" class title="This is an image"> 

<p>这里我自己也没太搞懂，姑且谈谈自己的理解：</p>
<p>按道理来说cortex内核对于优先级数值是越小其逻辑上的优先度就越高，其在cubemx上的大部分配置也同样符合这一原则，但是在对于任务优先级的分配上cubemx采用了上图这种low、normal等的分配方式，并且在程序中的定义数值则是优先级数值越大，逻辑优先度越高；这可能是cubemx为了方便理解做出的优化(？)</p>
<h2 id="三、阻塞问题"><a href="#三、阻塞问题" class="headerlink" title="三、阻塞问题"></a>三、阻塞问题</h2><p><strong>在程序中的阻塞函数≠正常的延时函数</strong>！！！</p>
<p>当程序执行到vTaskDelay或osdelay后会将当前任务添加到延时任务列表里，并强行切换任务。<strong>也就是说，在这段阻塞期内，只要有任务处于就绪态，就会进入该任务，若多个任务就绪，则按照优先级进行抢占。当堵塞态的任务延时到期过后会重新进入就绪态等待。</strong>并且在重新进入就绪态后任务会从阻塞之后的位置开始。</p>
<ul>
<li>任务函数内可以正常调用延时函数</li>
<li>挂起规律与阻塞规律基本一致</li>
</ul>
<h2 id="四、任务抢占问题"><a href="#四、任务抢占问题" class="headerlink" title="四、任务抢占问题"></a>四、任务抢占问题</h2><p>原先一直以为抢占式工作流程为：先运行优先级最高的任务，直至其被阻塞、挂起等；这期间运行优先级第二高的任务，直到其被阻塞、挂起等；若最高优先级此时已处于就绪态，则会在第二优先级任务进入阻塞等非运行态时进入运行态，<strong>但其实这是不对的</strong></p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">(<span class="type">void</span> *argument)</span><span class="comment">//低优先级</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN led_R */</span></span><br><span class="line">	HAL_GPIO_WritePin(led_r_GPIO_Port,led_r_Pin,GPIO_PIN_SET);</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">	HAL_GPIO_TogglePin(led_b_GPIO_Port,led_b_Pin);</span><br><span class="line">	HAL_Delay(<span class="number">5000</span>);</span><br><span class="line">    osDelay(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END led_R */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">(<span class="type">void</span> *argument)</span><span class="comment">//高优先级</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN led_B */</span></span><br><span class="line">	osStatus_t result;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">		result=osEventFlagsSet(key1_pHandle,event1);</span><br><span class="line">		<span class="keyword">if</span>(result == osOK)</span><br><span class="line">		&#123;</span><br><span class="line">			HAL_GPIO_WritePin(led_r_GPIO_Port,led_r_Pin,GPIO_PIN_RESET);</span><br><span class="line">			HAL_GPIO_WritePin(led_b_GPIO_Port,led_b_Pin,GPIO_PIN_SET);</span><br><span class="line">			HAL_GPIO_WritePin(led_g_GPIO_Port,led_g_Pin,GPIO_PIN_SET);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			HAL_GPIO_WritePin(led_b_GPIO_Port,led_b_Pin,GPIO_PIN_RESET);</span><br><span class="line">			HAL_GPIO_WritePin(led_g_GPIO_Port,led_g_Pin,GPIO_PIN_RESET);</span><br><span class="line">		&#125;</span><br><span class="line">		osDelay(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照原先的思路，程序开始，task2会优先运行，若事件设定正常，此时红灯会亮起；然后task2进入阻塞态5ms，task1进入运行态，此时按道理红灯会熄灭，蓝灯亮起5秒后，task1进入阻塞态，task2重新运行，此时红灯再亮，蓝灯灭。</p>
<p><strong>但是现实是：红灯亮起后，蓝灯只会极快地闪烁一下后红灯继续亮起，并且蓝灯闪烁的频率大概为5s左右。</strong></p>
<p>所以，真正的抢占流程应该是：程序开始，task2会优先运行，若事件设定正常，此时红灯会亮起；然后task2进入阻塞态5ms，<strong>task1进入运行态，当task1运行5ms后，task2的阻塞结束，进入就绪态，此时task1刚刚开始运行HAL_Delay(5000)，由于task2优先级更高且已经就绪，task2直接抢占并运行（此时蓝灯就会熄灭，因此蓝灯一次只亮了5ms），而不是等到task1运行osDelay(10)才会抢占</strong>；当task2再一次进入堵塞时，task1从上次被抢占的位置继续运行5ms然后被task2抢占，这样一直循环，直到HAL_Delay(5000)结束，蓝灯才会再次闪烁一次。</p>
<p>总结：高优先级的任务<strong>一旦就绪后会立刻抢占</strong>优先级低的任务,哪怕当前低优先级正在运行，而不是等到优先级低的任务进入非运行态时才抢占。</p>
]]></content>
      
        
        <tags>
            
            <tag> 嵌入式学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[FreeRTOS的任务相关]]></title>
      <url>/2022/08/23/FreeRTOS-2/</url>
      <content type="html"><![CDATA[<h1 id="任务相关"><a href="#任务相关" class="headerlink" title="任务相关"></a>任务相关</h1><h2 id="1、RTOS调度器"><a href="#1、RTOS调度器" class="headerlink" title="1、RTOS调度器"></a>1、RTOS调度器</h2><p>在任何时刻，只有一个任务得到运行，RTOS调度器决定运行哪个任务。调度器会不断的启动、停止每一个任务，宏观看上去就像整个应用程序都在执行。作为任务，不需要对调度器的活动有所了解，在任务切入切出时保存上下文环境（寄存器值、堆栈内容）是调度器主要的职责。为了实现这点，每个任务都需要有自己的堆栈。当任务切出时，它的执行环境会被保存在该任务的堆栈中，这样当再次运行时，就能从堆栈中正确的恢复上次的运行环境。</p>
<h2 id="2、任务状态"><a href="#2、任务状态" class="headerlink" title="2、任务状态"></a>2、任务状态</h2><img src="/images/loading.png" data-original="/2022/08/23/FreeRTOS-2/%E4%BB%BB%E5%8A%A1.jpg" class title="This is an image"> 

<h2 id="3、任务例子（用户）"><a href="#3、任务例子（用户）" class="headerlink" title="3、任务例子（用户）"></a>3、任务例子（用户）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vATaskFunction</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*-- 应用程序代码放在这里. --*/</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 任务不可以从这个函数返回或退出。在较新的FreeRTOS移植包中，如果</span></span><br><span class="line"><span class="comment">    试图从一个任务中返回，将会调用configASSERT()（如果定义的话）。</span></span><br><span class="line"><span class="comment">    如果一个任务确实要退出函数，那么这个任务应调用vTaskDelete(NULL)</span></span><br><span class="line"><span class="comment">    函数，以便处理一些清理工作。*/</span></span><br><span class="line">    vTaskDelete( <span class="literal">NULL</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如步兵v2.6中底盘任务</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">chassis_task</span><span class="params">(<span class="type">void</span> *pvParameters)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//空闲一段时间</span></span><br><span class="line">    vTaskDelay(CHASSIS_TASK_INIT_TIME);</span><br><span class="line">    <span class="comment">//底盘初始化</span></span><br><span class="line">    chassis_init(&amp;chassis_move);</span><br><span class="line">	<span class="comment">//判断遥控器在线状态</span></span><br><span class="line">    <span class="keyword">while</span> (toe_is_error(DBUSTOE))</span><br><span class="line">	&#123;</span><br><span class="line">      vTaskDelay(CHASSIS_CONTROL_TIME_MS);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//底盘循环代码</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">	  <span class="comment">//底盘模式设置</span></span><br><span class="line">      chassis_set_mode(&amp;chassis_move);</span><br><span class="line">      <span class="comment">//状态切换数据保存与处理</span></span><br><span class="line">      chassis_mode_change_control_transit(&amp;chassis_move);</span><br><span class="line">      <span class="comment">//底盘相关反馈数据更新</span></span><br><span class="line">      chassis_feedback_update(&amp;chassis_move);</span><br><span class="line">        。。。。。。。。</span><br><span class="line">	  <span class="comment">//系统延时</span></span><br><span class="line">	  vTaskDelay(CHASSIS_CONTROL_TIME_MS);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<ul>
<li><p>任务函数决不应该返回，因此通常任务函数都是一个死循环。</p>
</li>
<li><p>任务由xTaskCreate()函数创建，由vTaskDelete()函数删除。（后面会详细讲到）</p>
</li>
</ul>
<h2 id="4、空闲任务"><a href="#4、空闲任务" class="headerlink" title="4、空闲任务"></a>4、空闲任务</h2><p> 空闲任务是启动RTOS调度器时由内核自动创建的任务，这样可以确保至少有一个任务在运行。空闲任务具有最低任务优先级，这样如果有其它更高优先级的任务进入就绪态就可以立刻让出CPU。</p>
<h3 id="空闲任务钩子函数"><a href="#空闲任务钩子函数" class="headerlink" title="空闲任务钩子函数"></a>空闲任务钩子函数</h3><p>空闲任务钩子是一个函数，每一个空闲任务周期被调用一次。</p>
<ul>
<li><strong>因为FreeRTOS必须至少有一个任务处于就绪或运行状态，因此钩子函数不可以调用可能引起空闲任务阻塞的API函数（比如vTaskDelay()或者带有超时事件的队列或信号量函数）。</strong></li>
</ul>
<p>创建一个空闲钩子步骤如下：</p>
<ul>
<li><p>在FreeRTOSConfig.h头文件中设置configUSE_IDLE_HOOK为1；</p>
</li>
<li><p>定义一个函数，名字和参数原型如下所示：</p>
</li>
</ul>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vApplicationIdleHook</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure>

<p>  通常，<strong>使用这个空闲钩子函数设置CPU进入低功耗模式</strong>。</p>
<h2 id="5、任务的创建"><a href="#5、任务的创建" class="headerlink" title="5、任务的创建"></a>5、任务的创建</h2><p>任务创建和删除API函数位于文件task.c中，需要包含task.h头文件</p>
<p>具体函数定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t xTaskCreate(</span><br><span class="line">           TaskFunction_t pvTaskCode,</span><br><span class="line">           const char * const pcName,</span><br><span class="line">           unsigned short usStackDepth,</span><br><span class="line">           void *pvParameters,</span><br><span class="line">           UBaseType_t uxPriority,</span><br><span class="line">           TaskHandle_t * pvCreatedTask</span><br><span class="line">            );</span><br><span class="line">  例：          </span><br><span class="line">    xTaskCreate( (TaskFunction_t)chassis_task,//底盘任务</span><br><span class="line">                 (const char *)&quot;chassis_task&quot;,</span><br><span class="line">                 (uint16_t)CHASSIS_STK_SIZE,</span><br><span class="line">                 (void *)NULL,</span><br><span class="line">                 (UBaseType_t)CHASSIS_TASK_PRIO,</span><br><span class="line">                 (TaskHandle_t *)&amp;CHASSISTask_Handler</span><br><span class="line">               );</span><br></pre></td></tr></table></figure>

<h3 id="参数描述"><a href="#参数描述" class="headerlink" title="参数描述"></a>参数描述</h3><ul>
<li><p>pvTaskCode：指针，指向任务函数的入口。</p>
<p>追溯到TaskFunction_t的定义可以找到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*TaskFunction_t)</span><span class="params">( <span class="type">void</span> * )</span>;</span><br></pre></td></tr></table></figure>

<p>此处涉及C语言中typedef的一个使用方法</p>
<p>​	void (<em>TaskFunction_t)( void * )意为定义了一个名为TaskFunction_t，入口参数类型为void</em>型，返回值为void型的函数指针变量；而在使用typedef后再进行TaskFunction_t  pvTaskCode的操作，则意为TaskFunction_t在这里作为类的别名，而 pvTaskCode作为类的变量。也就是说，在使用typedef后，可以将此处的TaskFunction_t理解为一个类似于int，void之类的类型</p>
<p>做个总结：此处</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*TaskFunction_t)</span><span class="params">( <span class="type">void</span> * )</span>;</span><br><span class="line">TaskFunction_t pvTaskCode;</span><br></pre></td></tr></table></figure>

<p>等同于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void (*pvTaskCode)( void * );</span><br></pre></td></tr></table></figure>

<p><strong>也就是说，pvTaskCode其实就是一个函数指针</strong></p>
<p>（此用法同步收录于“C语言学习-一些关键字-typedef-指针”一栏）</p>
</li>
<li><p>pcName：任务描述，名字。字符串的最大长度由宏configMAX_TASK_NAME_LEN指定</p>
</li>
<li><p>usStackDepth：指定任务堆栈大小，能够支持的堆栈变量数量，而<strong>不是字节数</strong>。</p>
</li>
</ul>
<ul>
<li>pvParameters：指针，当任务创建时，作为一个参数传递给任务。</li>
</ul>
<ul>
<li><p>uxPriority：任务的优先级。</p>
</li>
<li><p>pvCreatedTask：用于回传一个句柄（ID），创建任务后可以使用这个句柄引用任务</p>
</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p> 如果任务成功创建并加入就绪列表函数返回pdPASS，否则函数返回错误码，具体参见projdefs.h。</p>
<h3 id="用法（个人）"><a href="#用法（个人）" class="headerlink" title="用法（个人）"></a>用法（个人）</h3><ul>
<li>创建任务具体内容，例如上面的chassis_task</li>
<li>创建针对freertos的任务（xTaskCreate）</li>
<li>使用freertos调度任务</li>
</ul>
<h2 id="6-任务的删除"><a href="#6-任务的删除" class="headerlink" title="6.任务的删除"></a>6.任务的删除</h2><p>函数定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">( TaskHandle_t xTask )</span>;</span><br></pre></td></tr></table></figure>

<p>从RTOS内核管理器中删除一个任务。任务删除后将会从就绪、阻塞、暂停和事件列表中移除。在配置头文件中，必须定义宏INCLUDE_vTaskDelete 为1，本函数才有效。被删除的任务，其在任务创建时由内核分配的存储空间，会由空闲任务释放。如果有应用程序调用xTaskDelete()，必须保证空闲任务获取一定的微控制器处理时间。任务代码自己分配的内存是不会自动释放的，因此删除任务前，应该将这些内存释放。</p>
<h1 id="任务控制"><a href="#任务控制" class="headerlink" title="任务控制"></a>任务控制</h1><h2 id="延时（阻塞）"><a href="#延时（阻塞）" class="headerlink" title="延时（阻塞）"></a>延时（阻塞）</h2><h3 id="1-相对延时"><a href="#1-相对延时" class="headerlink" title="1.相对延时"></a>1.相对延时</h3><ul>
<li><p>void vTaskDelay( portTickType xTicksToDelay )；</p>
<p>参数描述：xTicksToDelay：延时时间总数，单位是系统时钟节拍周期</p>
</li>
</ul>
<p>vTaskDelay()指定的延时时间是从调用vTaskDelay()后开始计算的相对时间。比如vTaskDelay(100)，那么从调用vTaskDelay()后，任务进入阻塞状态，经过100个系统时钟节拍周期，任务解除阻塞。因此，vTaskDelay()并不适用与周期性执行任务的场合。因为调用vTaskDelay()到任务解除阻塞的时间不总是固定的并且该任务下一次调用vTaskDelay()函数的时间也不总是固定的（两次执行同一任务的时间间隔本身就不固定，中断或高优先级任务抢占也可能会改变每一次执行时间）。</p>
<p>在文件FreeRTOSConfig.h中，宏INCLUDE_vTaskDelay 必须设置成1，此函数才能有效。</p>
<h3 id="2-绝对延时"><a href="#2-绝对延时" class="headerlink" title="2.绝对延时"></a>2.绝对延时</h3><ul>
<li>void vTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_tx TimeIncrement );</li>
</ul>
<p>  参数描述：</p>
<ul>
<li>pxPreviousWakeTime：指针，指向一个变量，该变量保存任务最后一次解除阻塞的时间。第一次使用前，<strong>该变量必须初始化为当前时间</strong>。之后这个变量会在vTaskDelayUntil()函数内<strong>自动更新</strong>。</li>
<li>xTimeIncrement：周期循环时间。当<strong>当前时间</strong>等于pxPreviousWakeTime+xTimeIncrement时任务会解除阻塞。</li>
</ul>
<p>应当指出的是，如果指定的唤醒时间已经达到，vTaskDelayUntil()立刻返回（不会有阻塞）。因此，使用vTaskDelayUntil()周期性执行的任务，无论任何原因（比如，任务临时进入挂起状态）停止了周期性执行，使得任务少运行了一个或多个执行周期，<strong>那么需要重新计算所需要的唤醒时间</strong>。（例如任务挂起态结束后，当前的绝对时间已经超过指定的唤醒时间，vTaskDelayUntil()会立刻返回，且此时需要重新获得当前时间）这可以通过传递给函数的指针参数pxPreviousWake指向的值与当前系统时钟计数值比较来检测。<br>例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每10次系统节拍执行一次</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">vTaskFunction</span><span class="params">( <span class="type">void</span> * pvParameters )</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">static</span> portTickType xLastWakeTime;</span><br><span class="line">     <span class="type">const</span> portTickType xFrequency = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 使用当前时间初始化变量xLastWakeTime</span></span><br><span class="line">     xLastWakeTime = xTaskGetTickCount();</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">     	<span class="comment">// 需要周期性执行代码放在这里</span></span><br><span class="line">     	.........</span><br><span class="line">     	<span class="comment">//等待下一个周期</span></span><br><span class="line">         vTaskDelayUntil( &amp;xLastWakeTime,xFrequency ); </span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在文件FreeRTOSConfig.h中，宏INCLUDE_vTaskDelayUntil 必须设置成1，此函数才有效。</p>
<h2 id="获取优先级"><a href="#获取优先级" class="headerlink" title="获取优先级"></a>获取优先级</h2><ul>
<li><p>UBaseType_t uxTaskPriorityGet(TaskHandle_t xTask )；</p>
<p>参数描述：</p>
<ul>
<li>xTask：任务句柄。NULL表示获取当前任务的优先级。</li>
</ul>
</li>
</ul>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vAFunction</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line"> &#123;</span><br><span class="line">    xTaskHandle xHandle;</span><br><span class="line">    <span class="comment">// 创建另一个任务，并保存任务句柄</span></span><br><span class="line">    xTaskCreate( vTaskCode, <span class="string">&quot;NAME&quot;</span>,STACK_SIZE, <span class="literal">NULL</span>, tskIDLE_PRIORITY, &amp;xHandle );</span><br><span class="line">    <span class="comment">// 当前任务优先级比新创建的任务优先级高？</span></span><br><span class="line">    <span class="keyword">if</span>( uxTaskPriorityGet( xHandle ) &lt;uxTaskPriorityGet( <span class="literal">NULL</span> ) )</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">// 当前优先级较高</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在文件FreeRTOSConfig.h中，宏INCLUDE_vTaskPrioritySet 必须设置成1，此函数才有效。</p>
<h2 id="任务挂起"><a href="#任务挂起" class="headerlink" title="任务挂起"></a>任务挂起</h2><ul>
<li><p>void vTaskSuspend( TaskHandle_txTaskToSuspend );</p>
<p><strong>被挂起的任务绝不会得到处理器时间，不管该任务具有什么优先级。</strong></p>
<p>参数描述：</p>
<ul>
<li>xTask：任务句柄。NULL表示表示挂起当前任务。</li>
</ul>
</li>
</ul>
<p>在文件FreeRTOSConfig.h中，宏INCLUDE_vTaskSuspend必须设置成1，此函数才有效。</p>
<h2 id="解除任务挂起状态"><a href="#解除任务挂起状态" class="headerlink" title="解除任务挂起状态"></a>解除任务挂起状态</h2><ul>
<li>void vTaskResume( TaskHandle_txTaskToResume );</li>
</ul>
<p>宏INCLUDE_vTaskSuspend必须置1，此函数才有效。</p>
<h2 id="解除任务挂起状态（用于中断服务函数）"><a href="#解除任务挂起状态（用于中断服务函数）" class="headerlink" title="解除任务挂起状态（用于中断服务函数）"></a>解除任务挂起状态（用于中断服务函数）</h2><p>还在学习中，暂不记录。</p>
<h1 id="任务辅助调试类函数"><a href="#任务辅助调试类函数" class="headerlink" title="任务辅助调试类函数"></a>任务辅助调试类函数</h1><p>这类函数主要用于调试信息输出、获取任务句柄、获取任务状态、操作任务标签值等等，种类繁多，不再单独总结，具体可跳至<a href="https://freertos.blog.csdn.net/article/details/50498173">FreeRTOS任务应用函数_研究是为了理解的博客-CSDN博客</a>中讲解的很详细。</p>
]]></content>
      
        
        <tags>
            
            <tag> 嵌入式学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[FreeRTOS_基本框架]]></title>
      <url>/2022/08/18/FreeRTOS-1/</url>
      <content type="html"><![CDATA[<h1 id="1、基础内容"><a href="#1、基础内容" class="headerlink" title="1、基础内容"></a>1、基础内容</h1><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><ul>
<li>运行态:任务正在运行的状态。如果使用的是核处理器的话那么不管在任何时刻永远都只有一个任务处于运行态。</li>
<li>就绪态：处于就绪态的任务是那些已经准备就绪（这些任务没有被阻塞或者挂起 可以运行的任务，但是处于就绪态的任务还没有运行，因为有一个同优先级或者更高优先级的任务正在运行）</li>
<li>阻塞态：如果一个任务当前正在等待某个外部事件的话就说它处于阻塞态,比如说如果某个任务调用了函数 vTaskDelay()的话就会进入阻塞态， 直到延时周期完成。（任务在等待队列、信号量、事件组、通知或互斥信号量的时候也会进入阻塞态 。<strong>任务进入阻塞态会有一个超时时间，当超过这个超时时间任务就会退出阻塞态，即使所等待的事件还没有来临</strong>）</li>
<li>挂起态：任务进入挂起态以后也不能被调度器调用进入运行态，但是进入挂起态的任务没有超时时间。</li>
</ul>
<p>需要注意的是，当任务从阻塞&#x2F;挂起态退出时是进入的就绪态而非直接进入运行态。</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><ul>
<li><p>优先级数字越<strong>低</strong>表示任务优先级越<strong>低 （除使用Cortex内核的情况！！！！！！！！！）</strong></p>
<p>例如当一个任务A正在运行，另外一个任务B(优先级高于A)阻塞时间到或者事件触发处于就绪态，那么B会从A那抢占处理器，B开始运行，A停止运行</p>
<p><strong>※※※※※当使用cortex内核时相反（例如STM32)※※※※※</strong></p>
</li>
<li><p>时间片轮转</p>
<p>当宏<code>configUSE_TIME_SLICING</code>定义为1 的时候多个任务可以共用一个优先级，数量不限。此时处于就绪态的优先级相同的任务就会使用时间片轮转调度器获取运行时间</p>
</li>
</ul>
<h2 id="任务堆栈"><a href="#任务堆栈" class="headerlink" title="任务堆栈"></a>任务堆栈</h2><p>FreeRTOS之所以能正确的恢复一个任务的运行就是因为有任务堆栈在保驾护航，任务调度器在进行任务切换的时候会将当前任务的现场 (CPU寄存器值等 )保存在此任务的任务堆栈中，等到此任务下次运行的时候就会先用堆栈中保存的值来恢复现场 ，恢复现场以后任务就会接着从上次中断的地方开始运行。</p>
<h1 id="2、机制"><a href="#2、机制" class="headerlink" title="2、机制"></a>2、机制</h1><h2 id="任务通知"><a href="#任务通知" class="headerlink" title="任务通知"></a>任务通知</h2><p>任务通知来代替信号量、消息队列、事件标志组等这些东西。使用任务通知的话效率会更高。</p>
<h2 id="STM32支持的低功耗模式"><a href="#STM32支持的低功耗模式" class="headerlink" title="STM32支持的低功耗模式"></a>STM32支持的低功耗模式</h2><ul>
<li><p>sleep睡眠模式</p>
<p>在 SLEEP 模式下，只有内核停止了工作，而外设仍然在运行。<br>在进入 SLEEP 模式后，所有中断（‘外部中断、串口中断、定时器中断等’）均可唤醒 MCU，从而退出 SLEEP 模式。</p>
</li>
<li><p>stop停止模式</p>
<p>在进入 STOP 模式后，此时 SYSTICK 也会被停掉，只有外部中断（EXTI）才能唤醒 MCU由于 RTC 中断挂在外部中断线上，所以 RTC 中断也能唤醒 MCU）</p>
</li>
<li><p>standby待机模式</p>
<p>在 STANDBY 模式下，内核、所有的时钟、以及后备 1.2V 电源全部停止工作。</p>
<p>从 STANDBY 模式中唤醒后，系统相当于执行了一次复位操作，程序会从头来过。</p>
</li>
</ul>
<h2 id="Tickless-模式"><a href="#Tickless-模式" class="headerlink" title="Tickless 模式"></a>Tickless 模式</h2><p>FreeRTOS系统提供的低功耗模式，当处理器进入空闲任务周期以后就关闭系统节拍中断(滴答定时器中断)，只有当其他中断发生或者其他任务需要处理的时侯处理器才会从低功耗模式中唤醒。</p>
<h1 id="3、一些内核配置"><a href="#3、一些内核配置" class="headerlink" title="3、一些内核配置"></a>3、一些内核配置</h1><ul>
<li><p><strong>configUSE_PREEMPTION</strong></p>
<p>为1时RTOS使用抢占式调度器，为0时RTOS使用协作式调度器（时间片）。（协作式操作系统是任务主动释放CPU后，切换到下一个任务。任务切换的时机完全取决于正在运行的任务）</p>
</li>
<li><p><strong>configUSE_PORT_OPTIMISED_TASK_SELECTION</strong></p>
<p>某些运行FreeRTOS的硬件有两种方法选择下一个要执行的任务：通用方法和特定于硬件（硬件计算前导零指令）的方法</p>
<ul>
<li>设置为0 通用办法，可以用于所有FreeRTOS支持的硬件</li>
<li>设置为1 硬件计算前导零指令，并非所有硬件都支持</li>
</ul>
</li>
<li><p><strong>configUSE_IDLE_HOOK</strong></p>
<p>设置为1使用空闲钩子（Idle Hook类似于回调函数），0忽略空闲钩子。</p>
<p>空闲任务钩子是一个函数，这个函数由用户来实现，RTOS规定了函数的名字和参数，这个函数在每个空闲任务周期都会被调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vApplicationIdleHook</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//这个钩子函数不可以调用会引起空闲任务阻塞的API函数（例如：vTaskDelay()、带有阻塞时间的队列和信号量函数</span></span><br></pre></td></tr></table></figure>

<p>使用空闲钩子函数设置CPU进入省电模式是很常见的。</p>
</li>
<li><p>configUSE_MALLOC_FAILED_HOOK</p>
<p>如果定义并正确配置malloc()失败钩子函数，则这个函数会在pvPortMalloc()函数返回NULL时被调用。只有FreeRTOS在响应内存分配请求时发现堆内存不足才会返回NULL</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vApplicationMallocFailedHook</span><span class="params">( <span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>configUSE_TICK_HOOK</strong></p>
<p>设置为1使用时间片钩子（Tick Hook），0忽略时间片钩子.</p>
<p>时间片中断可以周期性的调用一个被称为钩子函数（回调函数）的应用程序。时间片钩子函数可以很方便的实现一个定时器功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vApplicationTickHook</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"><span class="comment">//vApplicationTickHook()函数在中断服务程序中执行，因此这个函数必须非常短小，不能大量使用堆栈，只能调用以”FromISR&quot; 或 &quot;FROM_ISR”结尾的API函数。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一些顾名思义的配置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configCPU_CLOCK_HZ				( SystemCoreClock ) <span class="comment">//CPU频率</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTICK_RATE_HZ				( ( TickType_t ) 1000 ) <span class="comment">//时钟节拍频率，这里设置为1000，周期就是1ms</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_PRIORITIES			( 32 )  <span class="comment">//可使用的最大优先级</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMINIMAL_STACK_SIZE		( ( unsigned short ) 128 )<span class="comment">//空闲任务使用的堆栈大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTOTAL_HEAP_SIZE			( ( size_t ) ( 64 * 1024 ) )<span class="comment">//系统所有总的堆大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_TASK_NAME_LEN			( 16 )  <span class="comment">//任务名字字符串长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_16_BIT_TICKS			0   <span class="comment">//系统节拍计数器变量数据类型，</span></span></span><br><span class="line">                                            <span class="comment">//1表示为16位无符号整形，0表示为32位无符号整形</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>configIDLE_SHOULD_YIELD</strong></p>
<p>这个参数控制任务在空闲优先级中的行为。仅在满足下列条件后，才会起作用。</p>
<ul>
<li>使用抢占式内核调度（见第一点）</li>
<li>用户任务使用空闲优先级</li>
</ul>
<p>使用同一优先级的多个任务，且该优先级大于空闲优先级时，这些任务反映在时间片上会获得相同的处理器时间。单当多个任务（不止空闲任务，还包括用户任务）共享空闲优先级时，如果configIDLE_SHOULD_YIELD为1，当用户任务运行时，空闲任务立刻让出CPU，但是空闲任务仍然会占据时间片中的一段时间，<strong>就会导致空闲任务与接下来的用户任务会共享一个时间片，即该用户任务占有时间片少于正常分配的时间片</strong></p>
<p><strong>设置configIDLE_SHOULD_YIELD为0将阻止空闲任务为用户任务让出CPU，直到空闲任务的时间片结束。这确保所有处在空闲优先级的任务分配到相同多的处理器时间，但是，这是以分配给空闲任务更高比例的处理器时间为代价的。</strong></p>
</li>
<li><p><strong>configUSE_TASK_NOTIFICATIONS</strong>（很有用）</p>
<p>置1将会开启任务通知功能，每个RTOS任务具有一个32位的通知值，RTOS任务通知相当于直接向任务发送一个事件，接收到通知的任务可以解除任务的阻塞状态（因等待任务通知而进入阻塞状态）。相对于以前必须分别创建队列、二进制信号量、计数信号量或事件组的情况，使用任务通知显然更灵活。更好的是，相比于使用信号量解除任务阻塞，使用任务通知可以快45%</p>
</li>
<li><p><strong>configGENERATE_RUN_TIME_STATS</strong></p>
<p>设置宏configGENERATE_RUN_TIME_STATS为1使能运行时间统计功能。一旦设置为1，则下面两个宏必须被定义：</p>
<ul>
<li><p>portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()</p>
<p>使用一个比运行时间更精准的基准定时器使统计更加精确，基准定时器中断频率要比统节拍中断快10~100倍。基准定时器中断频率越快，统计越精准，但能统计的运行时间也越短（比如，基准定时器10ms中断一次，8位无符号整形变量可以计到2.55秒，但如果是1秒中断一次，8位无符号整形变量可以统计到255秒）</p>
</li>
<li><p>portGET_RUN_TIME_COUNTER_VALUE()</p>
<p>返回基准时钟的值以供计数（在定时器中使使长整形变量ulHighFrequencyTimerTicks自增）</p>
</li>
</ul>
<p>当我们配置了一个定时器中断且要使用时间统计时，需要在config.h中添加</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> ulHighFrequencyTimerTicks;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() ( ulHighFrequencyTimerTicks = 0UL )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portGET_RUN_TIME_COUNTER_VALUE() ulHighFrequencyTimerTicks</span></span><br></pre></td></tr></table></figure>

<h3 id="C语言中的0UL和1UL"><a href="#C语言中的0UL和1UL" class="headerlink" title="C语言中的0UL和1UL"></a>C语言中的0UL和1UL</h3><ul>
<li>0UL ：无符号长整型0</li>
<li>1UL ：无符号长整型1</li>
</ul>
</li>
<li><p><strong>LIBRARY_LOWEST_INTERRUPT_PRIORITY</strong> &amp; <strong>LIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY</strong>  </p>
<p>由于在使用cortex内核的硬件设备中优先级数值为越小，逻辑优先级越高，所以这里的最小优先级即为硬件的最低逻辑优先级，表现在数值上即为最大数值；而此处的configMAX_SYSCALL_INTERRUPT_PRIORITY是用来设置可以在中断服务程序中安全调用FreeRTOS API函数的最高中断优先级。优先级小于等于这个宏所代表的优先级时，程序可以在中断服务程序中安全的调用FreeRTOS API函数；如果优先级大于这个宏所代表的优先级，表示FreeRTOS无法禁止这个中断，在这个中断服务程序中绝不可以调用任何API函数。</p>
<img src="/images/loading.png" data-original="/2022/08/18/FreeRTOS-1/freertos_1.jpg" class title="This is an image"> 

<p>运行在大于configMAX_SYSCALL_INTERRUPT_PRIORITY的优先级中断是不会被RTOS内核所屏蔽的，因此也不受RTOS内核功能影响。这主要用于非常高的实时需求中。比如执行电机转向。但是，这类中断的中断服务例程中绝不可以调用FreeRTOS的API函数。</p>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 嵌入式学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一些关键字]]></title>
      <url>/2022/08/03/C-%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      <content type="html"><![CDATA[<img src="/images/loading.png" data-original="/2022/08/03/C-%E5%85%B3%E9%94%AE%E5%AD%97/%E5%85%B3%E9%94%AE%E5%AD%97.jpg" class title="This is an image"> 

<h1 id="1-auto-和-register"><a href="#1-auto-和-register" class="headerlink" title="1. auto 和 register"></a>1. auto 和 register</h1><ul>
<li><p>auto关键字</p>
<ul>
<li>只能修饰局部变量, 局部变量如果没有其它修饰符, 默认就是auto的</li>
<li>特点: 随用随开, 用完即销</li>
</ul>
</li>
<li><p>register关键字</p>
<ul>
<li>只能修饰局部变量, 原则上将内存中变量提升到CPU寄存器中存储, 这样访问速度会更快</li>
<li>但是由于CPU寄存器数量相当有限, 通常不同平台和编译器在优化阶段会自动转换为auto</li>
</ul>
</li>
</ul>
<h1 id="2-static"><a href="#2-static" class="headerlink" title="2. static"></a>2. static</h1><ul>
<li><p>对局部变量的作用</p>
<ul>
<li>延长局部变量的生命周期,从程序启动到程序退出,但是它并没有改变变量的作用域</li>
</ul>
</li>
<li><p>定义变量的代码在整个程序运行期间仅仅会执行一次</p>
<p>  <strong>原因是静态局部变量的初值是在编译时赋予的，在程序执行期间不再赋予初值</strong></p>
</li>
<li><p>对全局变量的作用</p>
<ul>
<li>默认情况下多个同名的全局变量共享一块空间, 这样会导致全局变量污染问题</li>
<li><strong>如果想让某个全局变量只在某个文件中使用, 并且不和其他文件中同名全局变量共享同一块存储空间, 那么就可以使用static</strong></li>
</ul>
</li>
</ul>
<h1 id="3-extern"><a href="#3-extern" class="headerlink" title="3. extern"></a>3. extern</h1><ul>
<li><p>对局部变量的作用(无意义的)</p>
<ul>
<li>extern不能用于局部变量</li>
<li>extern代表声明一个变量, 而不是定义一个变量, 变量只有定义才会开辟存储空间</li>
<li>所以如果是局部变量, 虽然提前声明有某个局部变量, 但是局部变量只有执行到才会分配存储空间</li>
</ul>
</li>
<li><p>对全局变量的作用</p>
<ul>
<li>声明一个全局变量, 代表告诉编译器我在其它地方定义了这个变量, 你可以放心使用。举例来说，如果文件a.c需要引用b.c中变量int v，就可以在a.c中声明extern int v，然后就可以引用变量v。</li>
</ul>
</li>
</ul>
<ul>
<li><p>与包含头文件引用函数的区别</p>
<p>对变量而言，如果你想在本源文件(例如文件名A)中使用另一个源文件(例如文件名B)的变量，<strong>方法有2种</strong>：(1)在A文件中必须用extern声明在B文件中定义的变量(当然是全局变量)；(2)在A文件中添加B文件对应的头文件，当然这个头文件包含B文件中的变量声明，也即在这个头文件中必须用extern声明该变量，否则，该变量又被定义一次。</p>
<p>对函数而言，如果你想在本源文件(例如文件名A)中使用另一个源文件(例如文件名B)的函数，<strong>方法有2种</strong>：(1)在A文件中用extern声明在B文件中定义的函数(其实，也可省略extern，只需在A文件中出现B文件定义函数原型即可)；(2)在A文件中添加B文件对应的头文件，当然这个头文件包含B文件中的函数原型，<strong>在头文件中函数可以不用加extern。</strong></p>
</li>
<li><p>总结：</p>
<p>使用extern时，会加速程序的编译（确切的说是预处理）的过程，节省时间。但是当需要对变量&#x2F;函数名进行修改时需要把所有使用extern关键字的地方全部修改一次，而使用头文件包含只需更改一次，效率更高。</p>
</li>
</ul>
<h1 id="4-条件编译"><a href="#4-条件编译" class="headerlink" title="4. 条件编译"></a>4. 条件编译</h1><ul>
<li>是将代码编译进可执行程序, 而不是执行代码</li>
<li>条件编译后面的条件表达式中<strong>不能识别变量</strong>,它里面只能识别常量和宏定义</li>
</ul>
<h1 id="5-typedef"><a href="#5-typedef" class="headerlink" title="5. typedef"></a>5. typedef</h1><ul>
<li><p>C语言不仅提供了丰富的数据类型,而且还允许由用户自己定义类型说明符,也就是说允许由用户为数据类型取“别名”。</p>
<ul>
<li><p>基本数据类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INTEGER；</span><br><span class="line"><span class="keyword">typedef</span> INTEGER MyInteger;</span><br><span class="line">MyInteger a; <span class="comment">// 等价于 int a;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> NAME[<span class="number">20</span>]; <span class="comment">// 表示NAME是字符数组类型,数组长度为20。然后可用NAME 说明变量</span></span><br><span class="line">NAME a; <span class="comment">// 等价于 char a[20];</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">&#125; PersonType;</span><br><span class="line">PersonType person;</span><br><span class="line"><span class="comment">//有多种写法，此写法可读性强一些</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个sum函数，计算a跟b的和</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span><br><span class="line">  &#123;</span><br><span class="line">      <span class="type">int</span> c = a + b;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d&quot;</span>, a, b, c);</span><br><span class="line">      <span class="keyword">return</span> c;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*MySum)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> MySum p = sum;<span class="comment">// 定义一个指向sum函数的指针变量p</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(*p)(<span class="number">1</span>,<span class="number">2</span>)); <span class="comment">//3</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细解释可参考<a href="https://dhkkk.gitee.io/2022/08/23/FreeRTOS-2/">FreeRTOS的任务相关 | 小董的BLOG (gitee.io)</a>中有详细案例</p>
<p><strong>也就是说，在正常的定义前加上typedef，即把该定义的变量改为一个新的类型，要再次定义该类型的变量时，直接使用该类型的名字即可。</strong></p>
</li>
</ul>
</li>
</ul>
<h1 id="6-const"><a href="#6-const" class="headerlink" title="6. const"></a>6. const</h1><ul>
<li>对变量声明只读特性，保护变量值以防被修改。</li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul>
<li><p>修饰常量、数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">55</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰指针</p>
<ul>
<li>const int *A; &#x2F;&#x2F;const修饰指针,A可变,A指向的值不能被修改</li>
<li>int const *A; &#x2F;&#x2F;const修饰指向的对象,A可变,A指向的对象不可变</li>
<li>int *const A; &#x2F;&#x2F;const修饰指针A, A不可变,A指向的对象可变</li>
<li>const int *const A;&#x2F;&#x2F;指针A和A指向的对象都不可变</li>
</ul>
</li>
</ul>
<h1 id="ps-以下开始不是关键字"><a href="#ps-以下开始不是关键字" class="headerlink" title="ps.以下开始不是关键字"></a>ps.以下开始不是关键字</h1><h1 id="1、宏定义"><a href="#1、宏定义" class="headerlink" title="1、宏定义"></a>1、宏定义</h1><ul>
<li><p>对程序中用<strong>双引号扩起来的字符串内的字符</strong>，不进行宏的替换操作</p>
</li>
<li><p>宏定义与变量定义不同，宏定义仅是一种机械的字符替换，并不分配内存空间</p>
</li>
<li><p>宏名的有效范围是从定义位置到文件结束。如果需要终止宏定义的作用域，可以用#undef命令</p>
</li>
<li><p>定义一个宏时可以引用已经定义的宏名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> R  3.0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L  2*PI*R</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S  PI*R*R</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可用宏定义表示数据类型,使书写方便</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> String char *</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     String str = <span class="string">&quot;This is a string!&quot;</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C语言允许宏带有参数。在宏定义中的参数称为形式参数,在宏调用中的参数称为实际参数。(类似函数的使用)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> average(a, b) (a+b)/2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> a = average(<span class="number">10</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;平均值：%d&quot;</span>, a); <span class="comment">//7</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>带参数的宏在展开时，只作简单的字符和参数的替换，不进行任何计算操作。所以在定义宏时，<strong>一般用一个小括号</strong>括住字符串的参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> D1(a) (2*a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> D2(a) (2*(a))</span></span><br><span class="line"><span class="comment">//计算结果最好也用括号括起来,小型计算不括问题应该不大</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="type">int</span> b = D1(<span class="number">3</span>+<span class="number">4</span>);</span><br><span class="line">     <span class="type">int</span> c = D2(<span class="number">3</span>+<span class="number">4</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, b);  <span class="comment">//输出等价于2*3+4=10</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, c);  <span class="comment">//2*(3+4)=14</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="2、动态存储分配"><a href="#2、动态存储分配" class="headerlink" title="2、动态存储分配"></a>2、动态存储分配</h1><p>此前，用于存储数据的变量和数组在定义后，C编译程序通过定义的类型来了解其所需存储空间的大小并预先为其分配适当的存储空间，这些空间一经分配，在变量或数组的生存期内是固定不变的，所以这种方式也称为“静态存储分配”</p>
<p>C中还有一种“动态存储分配”的方法，在程序执行期间需要空间来存储数据时，通过申请分配指定的内存空间；当有闲置不用的空间时可以随时将其释放。C标准库提供了相关函数来进行对应操作：</p>
<h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><h3 id="malloc函数"><a href="#malloc函数" class="headerlink" title="malloc函数"></a>malloc函数</h3><table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">malloc(unsigned int size);</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center">size:字节数</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">成功则返回一个类型为void的首地址，失败为null</td>
</tr>
<tr>
<td align="center">功能</td>
<td align="center">在内存的动态存储区中分配一块长度为size字节的连续区域</td>
</tr>
</tbody></table>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用时需要包含&quot;stdlib.h&quot;或&quot;malloc.h&quot;</span></span><br><span class="line"><span class="type">int</span> *pi=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">//malloc返回值为void*型，可以强制转化为任何类型</span></span><br></pre></td></tr></table></figure>

<ul>
<li>需要注意的是，malloc只会负责分配空间。并不能对其进行初始化，所以此时*pi的值是随机的</li>
<li>该函数常用于初始化一个指针，这样可以避免使该指针成为<strong>野指针</strong></li>
</ul>
<h3 id="calloc函数"><a href="#calloc函数" class="headerlink" title="calloc函数"></a>calloc函数</h3><table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">calloc(unsigned int num,unsigned int size)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center">num:分配数据项的个数<br>size:每个数据项的大小</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">成功则返回一个类型为void的首地址，失败为null</td>
</tr>
<tr>
<td align="center">功能</td>
<td align="center">在内存的动态存储区中分配n块长度为size字节的连续区域</td>
</tr>
</tbody></table>
<ul>
<li>不同于malloc，calloc会对分配的存储单元值自动初始化为0</li>
</ul>
<p>因此，可以用以下方法开辟一个一维数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p;</span><br><span class="line">p=(<span class="type">char</span>*)<span class="built_in">calloc</span>(<span class="number">10</span>,<span class="keyword">sizeof</span>(<span class="type">char</span>));<span class="comment">//开辟一个可以存放十个字符串的数组</span></span><br></pre></td></tr></table></figure>

<h3 id="free函数"><a href="#free函数" class="headerlink" title="free函数"></a>free函数</h3><table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">free(void *ptr);</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数</td>
<td align="center">一个指针</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">功能</td>
<td align="center">释放ptr所指向的一块内存空间</td>
</tr>
</tbody></table>
<ul>
<li>需要注意的是，free释放的区域应为malloc或calloc所分配的区域</li>
<li>free函数的实际功能是告诉系统输入参数对应的内存不再使用，即不再被保护，也就是说其他变量随时会占用占用那个地址。<strong>因此，原则上不再访问已经被free的的内存</strong></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> C语言学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[结构体复习]]></title>
      <url>/2022/08/01/C-%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      <content type="html"><![CDATA[<h1 id="1-基本内容"><a href="#1-基本内容" class="headerlink" title="1.基本内容"></a>1.基本内容</h1><h2 id="几种初始化"><a href="#几种初始化" class="headerlink" title="几种初始化"></a>几种初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">char</span> *name;</span><br><span class="line">     <span class="type">int</span> age;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span> =</span> &#123;“lnj<span class="string">&quot;, 27&#125;; //定义的同时按顺序初始化</span></span><br><span class="line"><span class="string">/**************************************************************************/</span></span><br><span class="line"><span class="string">struct Student stu = &#123;.age = 35, .name = “lnj&quot;</span>&#125;;<span class="comment">//定义的同时不按顺序初始化</span></span><br><span class="line"><span class="comment">/**************************************************************************/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span>;</span></span><br><span class="line">stu.name = <span class="string">&quot;lnj&quot;</span>;</span><br><span class="line">stu.age = <span class="number">35</span>;  <span class="comment">//先定义后逐个初始化</span></span><br><span class="line"><span class="comment">/**************************************************************************/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span>;</span></span><br><span class="line">stu = (<span class="keyword">struct</span> Student)&#123;<span class="string">&quot;lnj&quot;</span>, <span class="number">35</span>&#125;;    <span class="comment">// 先定义后,再一次性初始化   </span></span><br></pre></td></tr></table></figure>

<h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Student </span><br><span class="line">&#123;</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line">struct Student stu[2]; </span><br><span class="line">stu[0] = &#123;&quot;lnj&quot;, 35&#125;;</span><br><span class="line">stu[1] = &#123;&quot;zs&quot;, 18&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">// 定义一个结构体类型</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> </span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">         <span class="type">char</span> *name;</span><br><span class="line">         <span class="type">int</span> age;</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个结构体变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span> =</span> &#123;“lnj<span class="string">&quot;, 18&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 定义一个指向结构体的指针变量</span></span><br><span class="line"><span class="string">    struct Student *p;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   // 指向结构体变量stu</span></span><br><span class="line"><span class="string">   p = &amp;stu;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /*</span></span><br><span class="line"><span class="string">     这时候可以用3种方式访问结构体的成员</span></span><br><span class="line"><span class="string">     */</span></span><br><span class="line"><span class="string">    // 方式1：结构体变量名.成员名</span></span><br><span class="line"><span class="string">    printf(&quot;</span>name=%s, age = %d \n<span class="string">&quot;, stu.name, stu.age);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 方式2：(*指针变量名).成员名</span></span><br><span class="line"><span class="string">    printf(&quot;</span>name=%s, age = %d \n<span class="string">&quot;, (*p).name, (*p).age);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 方式3：指针变量名-&gt;成员名</span></span><br><span class="line"><span class="string">    printf(&quot;</span>name=%s, age = %d \n<span class="string">&quot;, p-&gt;name, p-&gt;age);</span></span><br><span class="line"><span class="string">  //-&gt;运算符只用于指针结构体</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="结构体嵌套"><a href="#结构体嵌套" class="headerlink" title="结构体嵌套"></a>结构体嵌套</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span>&#123;</span></span><br><span class="line">     <span class="type">int</span> month;</span><br><span class="line">     <span class="type">int</span> day;</span><br><span class="line">     <span class="type">int</span> year;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">stu</span>&#123;</span></span><br><span class="line">     <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Date</span> <span class="title">birthday</span>;</span></span><br><span class="line">    Float score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>成员访问</p>
<p>如果某个成员也是结构体变量，可以连续使用成员运算符”.”访问最低一级成员。</p>
</li>
</ul>
<h1 id="2-内存分析"><a href="#2-内存分析" class="headerlink" title="2.内存分析"></a>2.内存分析</h1><ul>
<li><p>结构体变量占用的内存空间永远是所有成员中占用内存最大成员的倍数(对齐问题)</p>
<p>这种强制的要求一来简化了处理器与内存之间传输系统的设计,二来可以提升读取数据的速度。比如这么一种处理器,它每次读写内存的时候都从某个8倍数的地址开始,一次读出或写入8个字节的数据,假如软件能 保证double类型的数据都从8倍数地址开始,那么读或写一个double类型数据就只需要一次内存操作。否则,我们就可能需要两次内存操作才能完成这个动作,因为数据或许恰好横跨在两个符合对齐要求的8字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">int</span> age; <span class="comment">// 4</span></span><br><span class="line">   <span class="type">char</span> ch; <span class="comment">// 1</span></span><br><span class="line">   <span class="type">double</span> score; <span class="comment">// 8</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p</span>;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof = %i\n&quot;</span>, <span class="keyword">sizeof</span>(p)); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure>

<ul>
<li>占用内存最大属性是score, 占8个字节, 所以第一次会分配8个字节</li>
<li>将第一次分配的8个字节分配给age4个,分配给ch1个, 还剩下3个字节</li>
<li>当需要分配给score时, 发现只剩下3个字节, 所以会再次开辟8个字节存储空间</li>
<li>一共开辟了两次8个字节空间, 所以最终p占用16个字节</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> age; <span class="comment">// 4</span></span><br><span class="line">  <span class="type">double</span> score; <span class="comment">// 8</span></span><br><span class="line">  <span class="type">char</span> ch; <span class="comment">// 1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p</span>;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof = %i\n&quot;</span>, <span class="keyword">sizeof</span>(p)); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure>

<ul>
<li>占用内存最大属性是score, 占8个字节, 所以第一次会分配8个字节</li>
<li>将第一次分配的8个字节分配给age4个,还剩下4个字节</li>
<li>当需要分配给score时, 发现只剩下4个字节, 所以会再次开辟8个字节存储空间<br>将新分配的8个字节分配给score, 还剩下0个字节</li>
<li>当需要分配给ch时, 发现上一次分配的已经没有了, 所以会再次开辟8个字节存储空间<br>一共开辟了3次8个字节空间, 所以最终p占用24个字节</li>
</ul>
</li>
</ul>
<p><strong>需要注意的是，对占用内存最大的变量的判断仅限基本类型，同时不包括数组，也就是说当一个结构体同时包括</strong></p>
<p><strong><code>chara[5];int b;</code>时仍然用int的大小计算。</strong></p>
<h1 id="3-结构体之间赋值"><a href="#3-结构体之间赋值" class="headerlink" title="3.结构体之间赋值"></a>3.结构体之间赋值</h1><ul>
<li><p>结构体虽然是构造类型, <strong>但是结构体之间赋值是值拷贝, 而不是地址传递</strong>。所以结构体变量作为函数形参时也是值传递, <strong>在函数内修改形参, 不会影响外界实参</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">struct</span> Person per)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span> =</span> &#123;<span class="string">&quot;lnj&quot;</span>, <span class="number">35</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p1.name = %s\n&quot;</span>, p1.name); <span class="comment">// lnj</span></span><br><span class="line">    test(p1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p1.name = %s\n&quot;</span>, p1.name); <span class="comment">// lnj</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">struct</span> Person per)</span></span><br><span class="line">&#123;</span><br><span class="line">    per.name = <span class="string">&quot;zs&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h1><ul>
<li><p>和结构体不同的是, 结构体的每个成员都是占用一块独立的存储空间, 而共用体<strong>所有的成员都占用同一块存储空间，因此所有成员的地址都是相同的</strong></p>
</li>
<li><p>特点: 由于所有属性共享同一块内存空间, <strong>所以只要其中一个属性发生了改变, 其它的属性都会受到影响</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Test</span> <span class="title">t</span>;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(p) = %i\n&quot;</span>, <span class="keyword">sizeof</span>(t)); <span class="comment">//4</span></span><br><span class="line">  </span><br><span class="line">t.age = <span class="number">33</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;t.age = %i\n&quot;</span>, t.age); <span class="comment">// 33</span></span><br><span class="line">t.ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;t.ch = %c\n&quot;</span>, t.ch); <span class="comment">// a</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;t.age = %i\n&quot;</span>, t.age); <span class="comment">// 97</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><ul>
<li>枚举使用的注意<ul>
<li>C语言编译器会将枚举元素(spring、summer等)作为<strong>整型常量</strong>处理，称为枚举常量。</li>
<li>枚举元素的值取决于定义时各枚举元素排列的先后顺序。默认情况下，第一个枚举元素的值为0，第二个为1，依次顺序加1。</li>
<li>也可以在定义枚举类型时改变枚举元素的值</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span> &#123;</span></span><br><span class="line">    Spring = <span class="number">9</span>,</span><br><span class="line">    Summer,</span><br><span class="line">    Autumn = <span class="number">20</span>,</span><br><span class="line">    Winter</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 也就是说spring的值为9，summer的值为10，autumn的值为20，winter的值为21</span></span><br></pre></td></tr></table></figure>

<ul>
<li>关于枚举类型的内存大小：<ul>
<li>若为没有在其中赋值的操作，默认4字节</li>
<li>若有赋值，大小取决于赋值数的类型</li>
</ul>
</li>
</ul>
<h1 id="利用结构体实现动态链表"><a href="#利用结构体实现动态链表" class="headerlink" title="利用结构体实现动态链表"></a>利用结构体实现动态链表</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">30</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;test;</span><br><span class="line"></span><br><span class="line">test *<span class="title function_">creat</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	test *linkhead,*linkend,*pt;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pt=(test*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(test));<span class="comment">//分配动态内存</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %s&quot;</span>,&amp;pt-&gt;num,pt-&gt;name);</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			linkhead=pt;<span class="comment">//第一次先将当前节点赋给链头链尾</span></span><br><span class="line">			linkend=pt;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//若不是第一次，先将当前节点存入上一个节点的next中，再将linkend更新为当前节点以供下一次访问</span></span><br><span class="line">		&#123;                                                                <span class="comment">//当前节点的next</span></span><br><span class="line">			linkend-&gt;next=pt;</span><br><span class="line">			linkend=pt;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	linkend-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> linkhead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">destroy</span><span class="params">(test *linkHead)</span></span><br><span class="line">&#123;</span><br><span class="line">	test *p;</span><br><span class="line">	p=linkHead; </span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		linkHead=linkHead-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;clear\n&quot;</span>);</span><br><span class="line">		p=linkHead;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	test *LH，*Free_item;</span><br><span class="line">	LH=creat();</span><br><span class="line">   Free_item=LH;</span><br><span class="line">	<span class="keyword">while</span>(LH!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;NUM:%d   NAME:%s\n&quot;</span>,LH-&gt;num,LH-&gt;name);</span><br><span class="line">		LH=LH-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	destroy(Free_item);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>以下解释存在一定问题，我修改后的内容以及写在下一节！！！</strong></p>
<ul>
<li><p><em>注：其实这里最开始打印也应该单独写个函数，但是由于我懒得去写了，因此直接在main中操作参数，并且在操作完后我意识到好像无法再以LH为参数去使用destroy函数，按照一般地址与指针的理解，在打印完成过后应该已经改变了在creat()函数中分配的内存所对应的值，但是我抱着尝试的心理用main中的Free_item作为参数使用destroy函数竟然成功了，这一度让我以为我在指针的学习中是不是疏忽了什么重要内容！之后自己以简单的函数间的指针交互写了一些程序发现自己的理解好像也并没有什么问题，最后，在以”形参”为关键字搜索我的个人博客后终于找到如下一段话：</em></p>
<p><em>“结构体虽然是构造类型, 但是结构体之间赋值是值拷贝, 而不是地址传递。所以结构体变量作为函数形参时也是值传递, 在函数内修改形参, 不会影响外界实参。”（完全忘记了捏😋，所以要多多复习原来的内容！！）</em></p>
<p><em>因此LH也只是拷贝了creat函数所创建的linkhead的值而已，对LH的任何操作都不会影响creat函数所创建的linkhead的值，而Free_item拷贝的也是LH改变前的值，因此LH的改变也不会影响Free_item的内容。</em></p>
</li>
</ul>
<h2 id="2022-11-17改"><a href="#2022-11-17改" class="headerlink" title="2022.11.17改"></a>2022.11.17改</h2><p>因为最近又在学习FreeRTOS的相关内容，再次复习了一下链表的相关原理，顺便又读了一下上面写的内容，发现对于上一节最后这里的解释好像并不正确，因为当时是按照结构体赋值解释的，<strong>但是在这个链表程序中，传递的内容明显是地址而不是值！</strong>于是我再次查阅了结构指针的相关文献，解释如下：</p>
<p><strong>我们一步一步来捋一下</strong>：</p>
<h3 id="①creat函数"><a href="#①creat函数" class="headerlink" title="①creat函数"></a>①creat函数</h3><p>首先我们可以确定，在这个链表程序中的所有test类型变量均为指针变量，也就是说，在creat()函数中:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">test *<span class="title function_">creat</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	test *linkhead,*linkend,*pt;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pt=(test*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(test));<span class="comment">//分配动态内存</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %s&quot;</span>,&amp;pt-&gt;num,pt-&gt;name);</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			linkhead=pt;<span class="comment">//第一次先将当前节点赋给链头链尾</span></span><br><span class="line">			linkend=pt;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//若不是第一次，先将当前节点存入上一个节点的next中，再将linkend更新为当前节点以供下一次访问</span></span><br><span class="line">		&#123;                                                                <span class="comment">//当前节点的next</span></span><br><span class="line">			linkend-&gt;next=pt;</span><br><span class="line">			linkend=pt;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	linkend-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> linkhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>在<code>scanf(&quot;%d %s&quot;,&amp;pt-&gt;num,pt-&gt;name);</code>中，其实是让pt这个结构体指针指向了一个整型数字和一个字符串，按照C++的说法就是<strong>直接使指针指向了两个字符值常量。</strong></li>
<li>在三次循环中，分别开辟了三个动态内存区域。</li>
<li>creat函数返回的也是一个结构体指针</li>
</ul>
<h3 id="②main-函数"><a href="#②main-函数" class="headerlink" title="②main()函数"></a>②main()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	test *LH，*Free_item;</span><br><span class="line">	LH=creat();</span><br><span class="line">   Free_item=LH;</span><br><span class="line">	<span class="keyword">while</span>(LH!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;NUM:%d   NAME:%s\n&quot;</span>,LH-&gt;num,LH-&gt;name);</span><br><span class="line">		LH=LH-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	destroy(Free_item);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>creat函数返回的指针<strong>赋值</strong>给结构体指针LH，并且在这里，所有的指针都不是二重指针，因此，creat的返回值linkhead的成员num和name都是直接指向的字符值常量，<strong>因此LH也通过linkhead直接指向这两个成员，而不是LH指向linkhead这个指针变量的地址</strong>，可以理解为linkhead和LH是并列的，没有先后顺序的。</li>
<li>下一步的<code>Free_item=LH;</code>也是同理，字面意义是Free_item指向了LH的地址，但是实际上Free_item也是直接指向的动态内存中的字符值常量，因为Free_item是一个一重指针，<strong>它不具有保存另一个指针变量地址的功能，所以它会通过LH直接指向动态内存</strong></li>
<li>综上，实际上Free_item和LH也是并列关系，因此循环中LH的指向的改变不会影响到Free_item的指向，即使LH已经指向null，Free_item也还是指向的链头。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实说到底，是我自己对指针理解一直存在的误区，例如如下例程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> *p1,*p2;</span><br><span class="line">	p1=&amp;a;</span><br><span class="line">	p2=p1;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,p1,&amp;p1,p2,&amp;a); <span class="comment">//6422036 6422024 6422036 6422036</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我之前一直认为一个指针指向另一个指针，该指针的便会指向另一个指针变量自己的地址，<strong>但实际上，一重指针并不具有保存另一个指针变量地址的功能，所以该指针会直接指向另一个指针指向的内容。</strong></p>
<p>就像上述例程中,p1指向整型变量a的地址，再将p1赋值给p2，但打印结果中p2指向的地址是a的地址(&amp;a)，而不是p1本身的地址（&amp;p1)。</p>
<p>这也从另一方面说明了二重指针的一些重要性吧。</p>
]]></content>
      
        
        <tags>
            
            <tag> C语言学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[指针相关复习]]></title>
      <url>/2022/07/31/C-%E6%8C%87%E9%92%88/</url>
      <content type="html"><![CDATA[<h1 id="1-基本内容"><a href="#1-基本内容" class="headerlink" title="1.基本内容"></a>1.基本内容</h1><h2 id="什么是指针"><a href="#什么是指针" class="headerlink" title="什么是指针"></a>什么是指针</h2><ul>
<li>在计算机中所有数据都存储在内存单元中,而每个内存单元都有一个对应的地址, 只要通过这个地址就能找到对应单元中存储的数据.</li>
<li>由于通过地址能找到所需的变量单元，所以我们说该地址指向了该变量单元。将地址形象化的称为“指针”</li>
<li>内存单元的指针(地址)和内存单元的内容是两个不同的概念。</li>
</ul>
<h2 id="什么是指针变量"><a href="#什么是指针变量" class="headerlink" title="什么是指针变量"></a>什么是指针变量</h2><p>在C语言中,允许用一个变量来存放其它变量的地址, 这种专门用于存储其它变量地址的变量, 我们称之为指针变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> *p; <span class="comment">// 一个用于指向字符型变量的指针</span></span><br><span class="line">p = &amp;ch; </span><br></pre></td></tr></table></figure>

<p>*表示这是一个指针变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p =  <span class="number">250</span>; <span class="comment">// 错误写法</span></span><br><span class="line"><span class="comment">/****************************/</span></span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">*p=&amp;a; <span class="comment">//错误写法</span></span><br></pre></td></tr></table></figure>

<ul>
<li>多个指针变量可以指向同一个地址。</li>
</ul>
<h3 id="对指针变量的理解"><a href="#对指针变量的理解" class="headerlink" title="对指针变量的理解"></a>对指针变量的理解</h3><p>指针变量本身的作用是储存一个用户定义的变量的地址，但是其本身作为一个额外的变量，也有自己的地址，<strong>且这个地址不等于其储存的变量的地址；</strong></p>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> *c;</span><br><span class="line">    c=&amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;指针变量c自身的地址为：%d&quot;</span>,&amp;c);<span class="comment">//6487568 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;指针变量c存储单元内存储的内容(也就是a的地址)为：%d&quot;</span>,c);<span class="comment">//6487576</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;变量a的地址为：%d&quot;</span>,a);<span class="comment">//6487576</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  c代表c内存放的地址</span></span><br><span class="line"><span class="comment">//  &amp;c代表c自身的地址</span></span><br><span class="line"><span class="comment">//  *c代表c内存放的地址中所存储的值</span></span><br><span class="line"><span class="comment">// (c+1)代表c内存放的地址+1*类型长度</span></span><br><span class="line"><span class="comment">// *c+1代表c内存放的地址中所存储的值本身+1</span></span><br><span class="line"><span class="comment">// *(c+1)代表c内存放的地址+1*类型长度后得到的地址中存储的值</span></span><br></pre></td></tr></table></figure>

<h2 id="取地址运算符（-amp-）与解引用运算符（-）"><a href="#取地址运算符（-amp-）与解引用运算符（-）" class="headerlink" title="取地址运算符（&amp;）与解引用运算符（*）"></a>取地址运算符（&amp;）与解引用运算符（*）</h2><ul>
<li><p>取地址运算符：&amp;x，其作用为返回操作对象的地址</p>
</li>
<li><p>解引用运算符：<code>*x</code>，其作用是<strong>返回x中存储的地址内存储的值</strong></p>
<p>例： <code>int a,*p1;p1=&amp;a;</code><strong>则此时*p1代表的就是变量a的内容,而不是a的地址</strong></p>
<p>这也就是为什么使用<code>printf(&quot;%d&quot;,*p);</code>时是用*p而不是p了，因为 *p才是代表a的值，p则存储的变量a的地址</p>
<p><strong>综上：除开定义时，其余时间*p等同a，p等同&amp;a</strong></p>
<p>在定义时，<code>int *p1=&amp;a;</code>也是合法的且作用与上相同，个人理解为是一种指针格式的“声明”（？）这也解释了当某个函数参数定义为为<code>int *a</code>时实际使用时传入的也是&amp;的取地址变量了（个人理解）</p>
</li>
</ul>
<h1 id="2-一些用法"><a href="#2-一些用法" class="headerlink" title="2.一些用法"></a>2.一些用法</h1><h2 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h2><ul>
<li><p>如果一个指针变量存放的又是另一个指针变量的地址,则称这个指针变量为指向指针的指针￼变量。也称为“二级指针”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> *cp;</span><br><span class="line">cp = &amp;c;</span><br><span class="line"><span class="type">char</span> **cp2;</span><br><span class="line">cp2 = &amp;cp;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c = %c&quot;</span>, **cp2);<span class="comment">//  c=a</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="指针访问数组元素"><a href="#指针访问数组元素" class="headerlink" title="指针访问数组元素"></a>指针访问数组元素</h2><ul>
<li><p>在指针指向数组元素时,允许以下运算:</p>
<ul>
<li>加一个整数(用+或+&#x3D;),如p+1</li>
<li>减一个整数(用-或-&#x3D;),如p-1</li>
<li>自加运算,如p++,++p</li>
<li>自减运算,如p–,–p</li>
</ul>
<p>如果指针变量p已指向数组中的一个元素,则p+1<code>指向</code>同一数组中的下一个元素,p-1<code>指向</code>同 一数组中的上一个元素。【*(p+1)】</p>
<p>(p+N)在地址上的变化为<code>p内存放的地址+数组元素类型长度*N</code></p>
<ul>
<li>其对p所有的基本运算均符合上述规律</li>
</ul>
</li>
</ul>
<h2 id="指针与字符串"><a href="#指针与字符串" class="headerlink" title="指针与字符串"></a>指针与字符串</h2><p>定义字符串除了使用字符数组存放之外，还可以通过字符串指针的方式指向字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组名保存的是数组第0个元素的地址, 指针也可以保存第0个元素的地址</span></span><br><span class="line"><span class="type">char</span> *str = <span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用注意事项</p>
<ul>
<li><p>此方法不可修改字符串内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用字符数组来保存的字符串是保存栈里的,保存栈里面东西是可读可写,所有可以修改字符串中的的字符</span></span><br><span class="line"><span class="comment">//使用字符指针来保存字符串,它保存的是字符串常量地址,常量区是只读的,所以我们不可以修改字符串中的字符</span></span><br><span class="line"><span class="type">char</span> *str = <span class="string">&quot;lnj&quot;</span>;</span><br><span class="line">*(str+<span class="number">2</span>) = <span class="string">&#x27;y&#x27;</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不能够直接接收键盘输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的原因是:str是一个野指针,他并没有指向某一块内存空间</span></span><br><span class="line"><span class="comment">// 所以不允许这样写如果给str分配内存空间是可以这样用 的</span></span><br><span class="line"><span class="type">char</span> *str;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="指向函数的指针"><a href="#指向函数的指针" class="headerlink" title="指向函数的指针"></a>指向函数的指针</h2><p>函数在内存中占据空间，因此也有起始地址。</p>
<p>格式：返回值类型  (*指针变量名)(形参);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;     </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> (*p)(<span class="type">int</span> x,<span class="type">int</span> y);</span><br><span class="line">	p=sum;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(*p)(<span class="number">1</span>,<span class="number">2</span>)); <span class="comment">//打印3</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数指针有以下几点特点：</p>
<ul>
<li><p>当把一个<strong>函数名（注意是名字，不带输入参数）</strong>作为一个值使用时，该函数会自动转换成指针，指向该函数的内存地址，因此在对指针初始化时取地址符可选:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p=sum;</span><br><span class="line">p=&amp;sum;<span class="comment">//都正确</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当使用指针调用函数时，解引用也是可选的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(*p)(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p(<span class="number">1</span>,<span class="number">2</span>));<span class="comment">//都输出3</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>当函数指针作形参时：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tran</span><span class="params">(<span class="type">double</span> (*a)(<span class="type">double</span> a1),<span class="type">double</span> (*b)(<span class="type">double</span> b1),<span class="type">double</span> x)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">double</span> x=<span class="number">3.141592</span>;</span><br><span class="line">	tran(<span class="built_in">sin</span>,<span class="built_in">cos</span>,x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">tran</span><span class="params">(<span class="type">double</span>(*a)(<span class="type">double</span> a1),<span class="type">double</span>(*b)(<span class="type">double</span> b1),<span class="type">double</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,(*a)(x/<span class="number">2</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,(*b)(x/<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用函数时直接传入函数名即可。</p>
<p>同理的，也可以不声明参数为指针（因为会自动转变为指针）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tran</span><span class="params">(<span class="type">double</span> a(<span class="type">double</span> a1),<span class="type">double</span> b(<span class="type">double</span> b1),<span class="type">double</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,(*a)(x/<span class="number">2</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,(*b)(x/<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="通过形参影响实参"><a href="#通过形参影响实参" class="headerlink" title="通过形参影响实参"></a>通过形参影响实参</h2><p>我们都知道，形参值的改变不能改变对应实参的值，把数据从被调用函数返回到调用函数的唯一途径时通过return。<strong>但如果通过传送地址给被调用函数，再在被调用函数中改变地址中存储的值，也就使通过形参改变对应实参的值成为了可能。</strong></p>
<p>例如：交换值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c; <span class="comment">// 因为c只是用来存放地址内保存的值，所以为一般变量</span></span><br><span class="line">    c=*x;*x=*y;*y=c;  <span class="comment">//将a、b地址中保存的值互换、地址不变</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">    swap(&amp;a,&amp;b);<span class="comment">//将a、b的地址传给形参x、y，此时指针变量x、y内保存的就是a、b的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  %d&quot;</span>,a,b);<span class="comment">//此时a、b地址内保存的值已经互换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但如果swap函数定义成如下，又会怎么样呢</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *c; </span><br><span class="line">    c=x;x=y;y=c;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这样定义函数，则程序的流程为：<strong>①调用swap函数时，x内保存的为a的地址，y内保存的为b的地址；②在swap函数中，x内保存的地址改变为b的地址，y内保存的地址改变为为a的地址；③swap函数调用结束，x，y的内存被释放；④此时a、b变量自身的地址并没有任何改变，改变的只用形参x、y所保存的地址，因此无法起到交换作用</strong></p>
<h2 id="二维数组地址详解-数组指针-重要！！！！！"><a href="#二维数组地址详解-数组指针-重要！！！！！" class="headerlink" title="二维数组地址详解+数组指针(重要！！！！！)"></a>二维数组地址详解+数组指针(重要！！！！！)</h2><p>详见<a href="https://dhkkk.gitee.io/2022/07/28/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/">二维数组复习 | 小董的BLOG (gitee.io)</a></p>
<h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><p>详见<a href="https://dhkkk.gitee.io/2022/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/">数据结构_链表 | 小董的BLOG (gitee.io)</a>和<a href="https://dhkkk.gitee.io/2022/08/01/C-%E7%BB%93%E6%9E%84%E4%BD%93/">结构体复习 | 小董的BLOG (gitee.io)</a></p>
<p>2022.11.20:我是按照自己的理解写的，所以思路那些可能会有点奇怪，我感觉自己写的也不是很精练。。凑合看看吧</p>
]]></content>
      
        
        <tags>
            
            <tag> C语言学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[字符串复习]]></title>
      <url>/2022/07/30/C%E8%AF%AD%E8%A8%802/</url>
      <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>字符串是位于双引号中的字符序列，因此在内存中以“\0”结束,所占字节比实际多一个。</p>
<p>（‘\0’是字符串结束的标志，因此数组中没有‘\0’时只是字符数组，且元素中间不能出现’\0’）</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>当数组元素个数大于存储字符内容时, 未被初始化的部分默认值是0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">char</span> name[] = <span class="string">&quot;c\0ool&quot;</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;name = %s\n&quot;</span>,name);</span><br><span class="line"><span class="comment">//输出结果: c</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意点:<ul>
<li>对一个字符串数组, 如果不做初始化赋值, 必须指定数组长度；</li>
<li>字符串数组最后一个字符的位置要留给字符串的结尾标示‘\0’；</li>
<li>当用scanf函数输入字符串时,字符串中不能含有空格,否则将以空格作为串的结束符。</li>
</ul>
</li>
</ul>
<h3 id="正确的赋值方法："><a href="#正确的赋值方法：" class="headerlink" title="正确的赋值方法："></a>正确的赋值方法：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>]=<span class="string">&quot;string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[]=<span class="string">&quot;string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;str);<span class="comment">//或scanf(&quot;%s&quot;,str);</span></span><br></pre></td></tr></table></figure>

<h3 id="错误的赋值方法"><a href="#错误的赋值方法" class="headerlink" title="错误的赋值方法:"></a>错误的赋值方法:</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line">str=<span class="string">&quot;string&quot;</span>; <span class="comment">//这是因为数组名是一个地址常量，是不可被赋值的</span></span><br></pre></td></tr></table></figure>

<h2 id="※常用函数※"><a href="#※常用函数※" class="headerlink" title="※常用函数※"></a>※常用函数※</h2><p>使用字符串函数应包含头文件”string.h”</p>
<h3 id="（1）输出函数"><a href="#（1）输出函数" class="headerlink" title="（1）输出函数"></a>（1）输出函数</h3><ul>
<li><p>格式: puts(字符数组名)</p>
</li>
<li><p>功能:把字符数组中的字符串输出到显示器。即在屏幕上显示该字符串。</p>
</li>
<li><p>优点:</p>
<ul>
<li>自动换行；</li>
<li>可以是数组的任意元素地址。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>不能自定义输出格式</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch[] = <span class="string">&quot;dhk&quot;</span>;</span><br><span class="line"><span class="built_in">puts</span>(ch); <span class="comment">//输出结果: dhk</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>当使用printf且输出格式为&amp;s时，输出项直接为数组名，而不是数组元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>]=<span class="string">&quot;dhk&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,s);<span class="comment">//正确</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,s[<span class="number">0</span>]);<span class="comment">//错误</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="（2）输入函数"><a href="#（2）输入函数" class="headerlink" title="（2）输入函数"></a>（2）输入函数</h3><ul>
<li>格式: gets (字符数组名)</li>
<li>功能:从标准输入设备键盘上输入一个字符串。</li>
</ul>
<p>当输入的字符串中含有空格时,输出仍为全部字符串。说明gets函数并不以空格作为字符串输入结束的标志,<em><strong>而只以回车作为输入结束</strong></em>。这是与scanf函数不同的。</p>
<ul>
<li>若要使用scanf一个字符串类型，则需要注意scanf会自动把空格当作分隔符</li>
</ul>
<h3 id="（3）计算长度"><a href="#（3）计算长度" class="headerlink" title="（3）计算长度"></a>（3）计算长度</h3><h4 id="1-sizeof（）"><a href="#1-sizeof（）" class="headerlink" title="1.sizeof（）"></a>1.sizeof（）</h4><p>数值包含’\0’，且当对象为字符串数组时，计算的是整个数组分配空间的长度</p>
<h4 id="2-strlen"><a href="#2-strlen" class="headerlink" title="2.strlen()"></a>2.strlen()</h4><p>测量字符串实际长度，不包含;\0’。</p>
<h3 id="（4）连接函数"><a href="#（4）连接函数" class="headerlink" title="（4）连接函数"></a>（4）连接函数</h3><ul>
<li>格式: strcat(字符数组名1,字符数组名2)  &#x2F;strncat(<del>,</del>,num);</li>
<li>功能:把字符数组2中的字符串连接到字符数组1 中字符串的后面,并删去字符串1后的串标志 “\0”。<strong>本函数返回值是字符数组1的首地址</strong>。</li>
</ul>
<h3 id="（5）比较函数"><a href="#（5）比较函数" class="headerlink" title="（5）比较函数"></a>（5）比较函数</h3><ul>
<li><p>格式: strcmp(字符数组名1,字符数组名2)  </p>
</li>
<li><p>功能:<em><strong>按照ASCII码顺序</strong></em>比较两个数组中的字符串,并由函数返回值返回比较结果。</p>
<ul>
<li>字符串1&#x3D;字符串2,返回值&#x3D;0;</li>
<li>字符串1&gt;字符串2,返回值1;</li>
<li>字符串1&lt;字符串2,返回值-1。</li>
</ul>
<p>需要注意的是，比较顺序是从左至右依次比较每一个字符的ASCII码大小，只要出现不同字符就只按照当前字符大小比较，与之后字符大小就无关了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] =<span class="string">&quot;acb&quot;</span>;     </span><br><span class="line">	<span class="type">char</span> str2[<span class="number">10</span>] =<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strcmp</span>(str1,str2));</span><br><span class="line">    <span class="comment">//输出1，由于&#x27;c&#x27;&gt;&#x27;b&#x27;,与第三个及以后的字符大小无关</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>感觉不是很好用，就拿来比较是否相同就行。</p>
</li>
</ul>
<h3 id="（6）拷贝函数"><a href="#（6）拷贝函数" class="headerlink" title="（6）拷贝函数"></a>（6）拷贝函数</h3><ul>
<li>格式： strcpy(char* dest,char* src);   &#x2F;   strncpy(char* dest,const char* src,size_t num);</li>
<li>功能：将参数src字符串拷贝至参数dest所指的地址。</li>
<li>返回值：返回参数dest的字符串起始地址。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> str1[<span class="number">10</span>] =<span class="string">&quot;aaaaaa&quot;</span>;     </span><br><span class="line">	<span class="type">char</span> str2[<span class="number">10</span>] = <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">	<span class="built_in">strncpy</span>(str1,str2,<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str1); <span class="comment">//结果为&quot;bbaaaa&quot; </span></span><br><span class="line">    <span class="comment">//当num长度大于srt2中字符串长度时仅会打印bbb（结果可能与编译器相关）</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>strcpy会覆盖原来的整个字符串，而strncpy只会覆盖n个字节原来的字符串，剩下的保留（当n超长时应该是默认使用strcpy）</strong></p>
<h3 id="（7）检索函数"><a href="#（7）检索函数" class="headerlink" title="（7）检索函数"></a>（7）检索函数</h3><h4 id="1-char-strstr-const-char-str-const-char-substr"><a href="#1-char-strstr-const-char-str-const-char-substr" class="headerlink" title="1. char* strstr(const char* str,const char* substr)"></a>1. char* strstr(const char* str,const char* substr)</h4><ul>
<li><p>功能：检索子串在字符串中<strong>首次出现的位置</strong>。</p>
</li>
<li><p>返回值：返回字符串str中第一次出现子串substr的地址；如果没有检索到子串，则返回NULL。</p>
<h4 id="2-char-strchr-const-char-str-char-c"><a href="#2-char-strchr-const-char-str-char-c" class="headerlink" title="2. char* strchr(const char* str,char c)"></a>2. char* strchr(const char* str,char c)</h4></li>
<li><p>功能：查找字符串中第一次出现c的位置。</p>
</li>
<li><p>返回值：规律同strstr()。</p>
<h4 id="3-char-strrchr-const-char-str-char-c"><a href="#3-char-strrchr-const-char-str-char-c" class="headerlink" title="3. char* strrchr(const char* str,char c)"></a>3. char* strrchr(const char* str,char c)</h4></li>
<li><p>功能：查找字符串中最后一次出现c的位置。</p>
</li>
<li><p>返回值：同上。</p>
</li>
</ul>
<h3 id="（8）其余函数"><a href="#（8）其余函数" class="headerlink" title="（8）其余函数"></a>（8）其余函数</h3><h4 id="字符转换"><a href="#字符转换" class="headerlink" title="字符转换"></a>字符转换</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tolower</span><span class="params">(<span class="type">int</span> c)</span>：转化字符为小写字母； </span><br><span class="line"><span class="type">int</span> <span class="title function_">toupper</span><span class="params">(<span class="type">int</span> c)</span>：转化字符为大写字母；</span><br></pre></td></tr></table></figure>

<h4 id="整型转换"><a href="#整型转换" class="headerlink" title="整型转换"></a>整型转换</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span><br></pre></td></tr></table></figure>

<p>​	返回转换后的整型数。</p>
<h4 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strlwr(<span class="type">const</span> <span class="type">char</span>* str);<span class="comment">//转小写</span></span><br><span class="line">strupr(<span class="type">const</span> <span class="type">char</span>* str);<span class="comment">//转大写</span></span><br></pre></td></tr></table></figure>

]]></content>
      
        
        <tags>
            
            <tag> C语言学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于hexo本地图片无法上传]]></title>
      <url>/2022/07/30/hexo-2/</url>
      <content type="html"><![CDATA[<h1 id="关于hexo本地图片无法上传"><a href="#关于hexo本地图片无法上传" class="headerlink" title="关于hexo本地图片无法上传"></a>关于hexo本地图片无法上传</h1><h2 id="1-安装插件"><a href="#1-安装插件" class="headerlink" title="1.安装插件"></a>1.安装插件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<h2 id="2-配置插件（可以先跳过看看）"><a href="#2-配置插件（可以先跳过看看）" class="headerlink" title="2.配置插件（可以先跳过看看）"></a>2.配置插件（可以先跳过看看）</h2><p>打开&#x2F;node_modules&#x2F;hexo-asset-image&#x2F;index.js，将内容更换为下面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">cheerio</span> <span class="operator">=</span> require(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line">function <span class="title function_">getPosition</span><span class="params">(str, m, i)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">version</span> <span class="operator">=</span> String(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, function(data)&#123;</span><br><span class="line">  <span class="type">var</span> <span class="variable">config</span> <span class="operator">=</span> hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">    	<span class="type">var</span> <span class="variable">link</span> <span class="operator">=</span> data.permalink;</span><br><span class="line">	<span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; Number(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">	   <span class="type">var</span> <span class="variable">beginPos</span> <span class="operator">=</span> getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	   <span class="type">var</span> <span class="variable">beginPos</span> <span class="operator">=</span> getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">	<span class="type">var</span> <span class="variable">endPos</span> <span class="operator">=</span> link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="type">var</span> <span class="variable">toprocess</span> <span class="operator">=</span> [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      <span class="type">var</span> <span class="variable">key</span> <span class="operator">=</span> toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="type">var</span> <span class="variable">$</span> <span class="operator">=</span> cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">        xmlMode: <span class="literal">false</span>,</span><br><span class="line">        lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">        decodeEntities: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(function()&#123;</span><br><span class="line">		<span class="keyword">if</span> ($(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">			<span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">src</span> <span class="operator">=</span> $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">			<span class="keyword">if</span>(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp;</span><br><span class="line">			   !/^\s*\<span class="comment">//.test(src)) &#123;</span></span><br><span class="line">			  <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">			  <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">			  <span class="type">var</span> <span class="variable">linkArray</span> <span class="operator">=</span> link.split(<span class="string">&#x27;/&#x27;</span>).filter(function(elem)&#123;</span><br><span class="line">				<span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">			  &#125;);</span><br><span class="line">			  <span class="type">var</span> <span class="variable">srcArray</span> <span class="operator">=</span> src.split(<span class="string">&#x27;/&#x27;</span>).filter(function(elem)&#123;</span><br><span class="line">				<span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">			  &#125;);</span><br><span class="line">			  <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">				srcArray.shift();</span><br><span class="line">			  src = srcArray.join(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">			  $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class="line">			  console.info&amp;&amp;console.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			console.info&amp;&amp;console.info(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">			console.info&amp;&amp;console.info($(<span class="built_in">this</span>));</span><br><span class="line">		&#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-修改根配置文件"><a href="#3-修改根配置文件" class="headerlink" title="3.修改根配置文件"></a>3.修改根配置文件</h2><p>post_asset_folder: true</p>
<h2 id="4-引入图片（可能无法使用markdown语法-“！“）"><a href="#4-引入图片（可能无法使用markdown语法-“！“）" class="headerlink" title="4.引入图片（可能无法使用markdown语法 “！“）"></a>4.引入图片（可能无法使用markdown语法 “！<a href></a>“）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img 1.jpg This is an image %&#125; </span><br></pre></td></tr></table></figure>

<p>“1.jpg”为图片名字</p>
<h1 id="注：上传至github时png格式无法使用，最好用jpg格式"><a href="#注：上传至github时png格式无法使用，最好用jpg格式" class="headerlink" title="注：上传至github时png格式无法使用，最好用jpg格式"></a>注：上传至github时png格式无法使用，最好用jpg格式</h1>]]></content>
      
        
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[guitar-1]]></title>
      <url>/2022/07/30/guitar-1/</url>
      <content type="html"><![CDATA[<h1 id="1-自由节奏"><a href="#1-自由节奏" class="headerlink" title="1.自由节奏"></a>1.自由节奏</h1><img src="/images/loading.png" data-original="/2022/07/30/guitar-1/1.jpg" class title="This is an image"> 

<p>Rubato标志</p>
<h1 id="2-延续"><a href="#2-延续" class="headerlink" title="2.延续"></a>2.延续</h1><img src="/images/loading.png" data-original="/2022/07/30/guitar-1/2.jpg" class title="This is an image"> 

<p>此时不要再次触碰相对弦（下弧线 ）</p>
<h1 id="三连音"><a href="#三连音" class="headerlink" title="三连音"></a>三连音</h1><img src="/images/loading.png" data-original="/2022/07/30/guitar-1/3.jpg" class title="This is an image"> 

<p>击弦+勾弦三连音，上弧线代表只弹第一个音</p>
<h1 id="装饰音"><a href="#装饰音" class="headerlink" title="装饰音"></a>装饰音</h1><img src="/images/loading.png" data-original="/2022/07/30/guitar-1/4.jpg" class title="This is an image"> 

<p>此次主要为听到后一个音</p>
<p>（若单有上斜线则会从低位到高位滑音（无头&#x2F;无尾滑音））</p>
<h1 id="左手抹弦"><a href="#左手抹弦" class="headerlink" title="左手抹弦"></a>左手抹弦</h1><img src="/images/loading.png" data-original="/2022/07/30/guitar-1/5.jpg" class title="This is an image"> 

<p>L.H.Stroke +左手拍弦</p>
<h1 id="点弦"><a href="#点弦" class="headerlink" title="点弦"></a>点弦</h1><img src="/images/loading.png" data-original="/2022/07/30/guitar-1/6.jpg" class title="This is an image"> 

<p>正上方表有L.H,此处（）为幽灵音</p>
]]></content>
      
        
        <tags>
            
            <tag> guitar </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[答辩问题（自用）]]></title>
      <url>/2022/07/28/%E7%AD%94%E8%BE%A9%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="1-整体工作流程"><a href="#1-整体工作流程" class="headerlink" title="1.整体工作流程"></a>1.整体工作流程</h1><h2 id="避障问题"><a href="#避障问题" class="headerlink" title="避障问题"></a>避障问题</h2><p>本代机器人使用的超声波检测避障，但在实际运行中发现工作效果不佳，在后续迭代的过程中会考虑到使用激光雷达或者碰撞检测来完成避障。</p>
<h2 id="下位机处理视觉数据问题"><a href="#下位机处理视觉数据问题" class="headerlink" title="下位机处理视觉数据问题"></a>下位机处理视觉数据问题</h2><p>上位机以一定频率下发粪便距离铲取装置的距离，下位机将数据处理为底盘行为。</p>
<p>例：粪便偏离视野中心，底盘同时调整x，y轴的分速度。</p>
<p>​	    当粪便距离已经较近时，减慢速度，进行微调。</p>
<h2 id="舵机相关问题"><a href="#舵机相关问题" class="headerlink" title="舵机相关问题"></a>舵机相关问题</h2><p>50Hz，固定占空比，固定角度。</p>
<h2 id="运输机构"><a href="#运输机构" class="headerlink" title="运输机构"></a>运输机构</h2><p>不需要很精准的控制，直接通过延时完成。</p>
<p>推杆10s；传送带10s；进膜15s；激光切割18s。</p>
<h2 id="进膜问题"><a href="#进膜问题" class="headerlink" title="进膜问题"></a>进膜问题</h2><p>进膜机构设置有灰度传感器，只有当pvc塑料膜储备足够且正确地切割、装填后才会进入下一任务。</p>
<p>（视频中为方便调试没有安装（如果问到的话））</p>
<h2 id="激光发射问题"><a href="#激光发射问题" class="headerlink" title="激光发射问题"></a>激光发射问题</h2><p>500Hz，12V；pwm控制占空比，默认功率最大。</p>
<h2 id="底盘控制"><a href="#底盘控制" class="headerlink" title="底盘控制"></a>底盘控制</h2><p>底盘采用PID控制，当出现卡死现象时，底盘会先向反方向运动，再继续工作。</p>
<h2 id="检测装满"><a href="#检测装满" class="headerlink" title="检测装满"></a>检测装满</h2><p>同时检测储物仓中垃圾的体积和重量，当任意一方满足条件后都会触发装满任务。</p>
<h2 id="下位机主控"><a href="#下位机主控" class="headerlink" title="下位机主控"></a>下位机主控</h2><p>采用STM32F103ZET6芯片，初始化2路不同频率PWM;使用串口与上位机通信；使用IIC通讯协议与PAJ76020通讯。</p>
<h3 id="程序具体流程："><a href="#程序具体流程：" class="headerlink" title="程序具体流程："></a>程序具体流程：</h3><p>1.各项初始化</p>
<p>2.进入定时器中断以一定频率接收、处理上位机数据、检测障碍物。</p>
<p>3.当检测到相关信号后进入相关任务。（例如：避障任务，铲取粪便任务)</p>
<h1 id="2022-7-30-更新"><a href="#2022-7-30-更新" class="headerlink" title="2022.7.30 更新"></a>2022.7.30 更新</h1><p>本来紧张的一，结果最后什么问题也没问捏QAQ.</p>
]]></content>
      
        
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二维数组复习]]></title>
      <url>/2022/07/28/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<h1 id="一、理论方面"><a href="#一、理论方面" class="headerlink" title="一、理论方面"></a>一、理论方面</h1><h2 id="1-存储"><a href="#1-存储" class="headerlink" title="1.存储"></a>1.存储</h2><ul>
<li><p>存储方式:</p>
<ul>
<li><p>内存寻址从大到小, 从高地址开辟一块连续没有被使用的内存给数组。</p>
</li>
<li><p>从分配的连续存储空间中, <em><strong>地址小的位置开始给每个元素分配空间</strong></em>。</p>
</li>
<li><p>从每个元素分配的存储空间中, <em><strong>地址最大的位置开始存储数据</strong></em>。</p>
</li>
<li><p>用数组名指向整个存储空间最小的地址。</p>
<p>（分配从小地址开始，赋值从大地址开始）</p>
</li>
</ul>
</li>
</ul>
<h3 id="二维数组地址详解-指针数组-数组指针-重要！！！"><a href="#二维数组地址详解-指针数组-数组指针-重要！！！" class="headerlink" title="二维数组地址详解+指针数组+数组指针(重要！！！)"></a>二维数组地址详解+指针数组+数组指针(重要！！！)</h3><p><em>如果还没有学习指针相关内容可以先跳过</em></p>
<h4 id="地址问题详解"><a href="#地址问题详解" class="headerlink" title="地址问题详解"></a>地址问题详解</h4><p>先看一下各种情况的输出结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> *p[<span class="number">3</span>];</span><br><span class="line">    p[<span class="number">0</span>]=&amp;a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p); <span class="comment">//6487520</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p); <span class="comment">//6487520</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p[<span class="number">0</span>]); <span class="comment">//6487520</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p); <span class="comment">//6487552</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[<span class="number">0</span>][<span class="number">0</span>]); <span class="comment">//6487552</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,**p); <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p[<span class="number">0</span>]); <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当输出为p和&amp;p时，我们可以发现输出的都是一个地址且二者输出相同，都等于p[0]的地址。这就说明数组指针与数组的相关规则相同——其数组名<strong>代表了其第一个元素的地址</strong></li>
<li>当输出为<code>*p</code>和&amp;a[0] [0]时，输出的值为地址且二者相同，&amp;a[0] [0]我们不难理解，但对于<code>*p</code>，上一点已经说到，p代表了p这个数组指针第一个元素的地址，如果我们对这个地址进行解引用（关于解引用<code>*</code>运算符在<a href="https://dhkkk.gitee.io/2022/07/31/C-%E6%8C%87%E9%92%88/">指针相关复习 | 小董的BLOG </a>中有详细讲到），<strong>返回值也就是这个首元素的地址内所存储的内容</strong>，而我们知道，指针变量本身存储的内容就是地址，<strong>所以对p进行解引用的结果，就是p的首元素的地址（6487520）所存储的“a[0] [0]的地址（6487552）“</strong></li>
<li>如果你能很好的理解解引用*运算符的用法，相信你已经能理解输出为<code>**p</code>和<code> *p[0]</code>的结果了；<code>**p</code>即再对<code> *p</code>进行一次解引用，也就是对”a[0] [0]的地址（6487552）“解引用，返回值为a[0] [0]的<strong>地址</strong>所存储的内容，即1。（<code>**p</code>和<code> *p[0]</code>等价）</li>
</ul>
<p>如果你对以上内容已经比较理解，那可以思考一下以下内容（以下内容是我个人的理解，不能保证正确！）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> *p[<span class="number">3</span>];</span><br><span class="line">    p[<span class="number">0</span>]=a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据对一维数组的学习，可以推断出二维数组名a即代表第一个元素的地址，把这个元素地址放进p内，完全没问题，全然大丈夫！但是编译器就是报错了捏😋。在网上找了很多资料之后，大概能想明白是怎么回事，但是又并不是那么明白：**二维数组名a代表的是<code>a[2][3]</code>中a[0]的地址，而在C语言中，这个a[0]又被看作a[3]&#x3D;{1,2,3};**那么这里的a是不是就可以看作是a[0] [0]的地址呢，我们接着尝试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);<span class="comment">//6487552</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*a);<span class="comment">//6487552</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,**a);<span class="comment">//1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[<span class="number">0</span>]);<span class="comment">//6487552</span></span><br></pre></td></tr></table></figure>

<p>我超，什么意思捏，a和<code>*a</code>输出值一样？？？为了解释这个现象，我们不妨来读一下刚刚的报错：</p>
<p><code>[Error] cannot convert &#39;int [2][3]&#39; to &#39;int*&#39; in assignment</code></p>
<p>这里我的理解是：二维数组a的类型为<code>int [2][3]</code>，而a[0]的类型为<code>int[3]</code>，通俗一点，就是a代表的是第一行数组的地址，而a[0]代表的是a[0] [0]的地址，二者虽然在地址值上相同，但表达的意思是不同的，这也就是为什么a无法存入p中的原因，因为类型是冲突的。所以这里正常的赋值应为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> *p[<span class="number">3</span>];</span><br><span class="line">    p[<span class="number">0</span>]=*a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,**p); 或 <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还有一个办法是：</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> (*p)[<span class="number">3</span>];</span><br><span class="line">    p=a; <span class="comment">//此时p单纯的就是一个指针变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,**p); 或 <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说真的感觉不太好理解，所以可以记下一个规律：</p>
<p><strong>对一个代表一行元素的地址解引用，得到的是该行首元素的地址，再对这个地址解引用得到首元素</strong></p>
<p>(所以此处a[0]等同于*a）</p>
<h4 id="指针数组与数组指针"><a href="#指针数组与数组指针" class="headerlink" title="指针数组与数组指针"></a>指针数组与数组指针</h4><ul>
<li><p>指针数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>在C语言中，[]的优先级高于<code>*</code>因此此式正确理解为：<code>int *(p[3])</code>，说明p为一个数组，且该数组用于存放地址，<strong>此时p是一个数组，但其元素内存储的为某个地址</strong></p>
</li>
<li><p>数组指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>先表明了p是一个指针变量，再说明了p指向的对象是一个int[3]型的数组，且p本身保存的是指向数组的首地址，<strong>此时p是一个指针</strong></p>
<ul>
<li><p>对数组指针的调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>&#125;&#125;,(*p)[<span class="number">3</span>],i;</span><br><span class="line">	p=a;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p);<span class="comment">//6487552</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p);<span class="comment">//6487552</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p[<span class="number">0</span>]);<span class="comment">//6487552</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,**p);<span class="comment">//1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p[<span class="number">0</span>]);<span class="comment">//1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p[<span class="number">0</span>][<span class="number">0</span>]);<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于数组指针的使用有以下几点：<em>（都假设存放的是多维数组）</em></p>
<ul>
<li>指针名代表<strong>二维数组第一行元素的地址</strong></li>
<li>对指针名解引用一次<strong>代表二维数组第一行数组中的第一个元素的地址（等同于p[0]）</strong></li>
<li>当数组指针下标精准到某一个元素时，例如<code>p[0][0]</code>,此时<code>p[0][0]</code>就代表数组元素的值，<strong>而不是地址</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h2><p>​	一维：可以理解为行数，可省略。</p>
<p>​	二维：~~，不可省略（会报错）。</p>
<ul>
<li><p>分行赋值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=</span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">2</span>,,&#125;</span><br><span class="line">    &#123;,,<span class="number">1</span>,&#125;</span><br><span class="line">    &#123;,,,<span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>指定元素的初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;[<span class="number">1</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-二维数组与函数"><a href="#2-二维数组与函数" class="headerlink" title="2.二维数组与函数"></a>2.二维数组与函数</h2><p>​	形参是基本类型则不会影响实参，如果是数组类型则会影响实参。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">change_1</span><span class="params">(<span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    ch = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">change_2</span><span class="params">(<span class="type">char</span> ch[])</span></span><br><span class="line">&#123;</span><br><span class="line">    ch[<span class="number">0</span>] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">change_3</span><span class="params">(<span class="type">char</span> ch[][<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    ch[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> cs[<span class="number">2</span>][<span class="number">3</span>] = </span><br><span class="line">  &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;cs[0][0] = %c\n&quot;</span>, cs[<span class="number">0</span>][<span class="number">0</span>]); <span class="comment">// 打印a</span></span><br><span class="line">  change(cs);  <span class="built_in">printf</span>(<span class="string">&quot;cs[0][0] = %c\n&quot;</span>, cs[<span class="number">0</span>][<span class="number">0</span>]); <span class="comment">// 基本类型形参不影响实参</span></span><br><span class="line">  change_2(cs);  <span class="built_in">printf</span>(<span class="string">&quot;cs[0][0] = %c\n&quot;</span>, cs[<span class="number">0</span>][<span class="number">0</span>]); <span class="comment">// 数组类型形参影响实参  </span></span><br><span class="line">  change_3(cs);  <span class="built_in">printf</span>(<span class="string">&quot;cs[0][0] = %c\n&quot;</span>, cs[<span class="number">0</span>][<span class="number">0</span>]); <span class="comment">// 数组类型形参影响实参 </span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="二、实操"><a href="#二、实操" class="headerlink" title="二、实操"></a>二、实操</h1><p>通过键盘录入 w,s,a,d控制小人向不同方向移动,其中w代表向上移动,s代表向 下移动,a代表向左移动,d 代表向右移动,当小人移动到出口位置,玩家胜利。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> <span class="built_in">map</span>[<span class="number">6</span>][<span class="number">7</span>]=&#123;    <span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,</span><br><span class="line">	                <span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>, 								</span><br><span class="line">					<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,								   </span><br><span class="line">					<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,								   </span><br><span class="line">					<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,								   </span><br><span class="line">					<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mapdraw</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">char</span> loc[<span class="number">6</span>][<span class="number">7</span>])</span>;</span><br><span class="line"><span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> y=<span class="number">1</span>;   <span class="comment">//当前坐标</span></span><br><span class="line"><span class="type">int</span> last_x=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> last_y=<span class="number">1</span>;  <span class="comment">//前一次坐标</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	mapdraw();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	move();</span><br><span class="line">	change(<span class="built_in">map</span>);</span><br><span class="line">	mapdraw();</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">map</span>[<span class="number">1</span>][<span class="number">6</span>]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;YOU WIN!&quot;</span>);	</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mapdraw</span><span class="params">()</span>  <span class="comment">//打印二维数组</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,<span class="built_in">map</span>[<span class="number">0</span>][i]);	</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,<span class="built_in">map</span>[<span class="number">1</span>][i]);	</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,<span class="built_in">map</span>[<span class="number">2</span>][i]);	</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,<span class="built_in">map</span>[<span class="number">3</span>][i]);	</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,<span class="built_in">map</span>[<span class="number">4</span>][i]);	</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,<span class="built_in">map</span>[<span class="number">5</span>][i]);	</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,<span class="built_in">map</span>[<span class="number">6</span>][i]);	</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	last_x=x;</span><br><span class="line">	last_y=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">char</span> loc[<span class="number">6</span>][<span class="number">7</span>])</span>  </span><br><span class="line">&#123;</span><br><span class="line">	loc[last_x][last_y]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	loc[x][y]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">char</span> dir;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;dir);</span><br><span class="line">	<span class="keyword">switch</span>(dir)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:x=x<span class="number">-1</span>;<span class="keyword">if</span>(<span class="built_in">map</span>[x][y]==<span class="string">&#x27;#&#x27;</span>) x=x+<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:x=x+<span class="number">1</span>;<span class="keyword">if</span>(<span class="built_in">map</span>[x][y]==<span class="string">&#x27;#&#x27;</span>) x=x<span class="number">-1</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:y=y<span class="number">-1</span>;<span class="keyword">if</span>(<span class="built_in">map</span>[x][y]==<span class="string">&#x27;#&#x27;</span>) y=y+<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:y=y+<span class="number">1</span>;<span class="keyword">if</span>(<span class="built_in">map</span>[x][y]==<span class="string">&#x27;#&#x27;</span>) y=y<span class="number">-1</span>;<span class="keyword">break</span>;</span><br><span class="line">		defalut :<span class="keyword">break</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	fflush(<span class="built_in">stdin</span>);  <span class="comment">//清除缓冲区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="scanf-停止接受输入及scanf-“-c”-amp-c）吃掉回车或者空格字符的问题"><a href="#scanf-停止接受输入及scanf-“-c”-amp-c）吃掉回车或者空格字符的问题" class="headerlink" title="scanf()停止接受输入及scanf(“%c”,&amp;c）吃掉回车或者空格字符的问题"></a>scanf()停止接受输入及scanf(“%c”,&amp;c）吃掉回车或者空格字符的问题</h1><p>例如，当输入‘w’+‘回车’时，回车会作为’\n’进入缓冲区等待下一次使用，也就是说main中的循环会执行两次。</p>
<p><strong>解决方法</strong>：</p>
<p>函数名: fflush<br>功 能: 清除一个流<br>用 法: int fflush(FILE *stream);</p>
<p><strong>fflush(stdin); 清除缓冲区内容。</strong></p>
<h1 id="一些记录"><a href="#一些记录" class="headerlink" title="一些记录"></a>一些记录</h1><h2 id="1-整个数组指针"><a href="#1-整个数组指针" class="headerlink" title="1.整个数组指针"></a>1.整个数组指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">	<span class="type">int</span>* ptr = (<span class="type">int</span>*)(&amp;a + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d,%d&quot;</span>, *(a + <span class="number">1</span>), *(ptr - <span class="number">1</span>));  <span class="comment">//2   5</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&amp;a为整个数组的地址，类型为int(*)[5],需将其强制转化才可以存进prt指针。因此&amp;a+1为整个数组的指针+1。</p>
]]></content>
      
        
        <tags>
            
            <tag> C语言学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo d 无法更新]]></title>
      <url>/2022/07/27/test/</url>
      <content type="html"><![CDATA[<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>删除 <code>hexo/.deploy_git</code> 文件, 然后重新尝试 <code>hexo d</code> , 就可以成功更新了.</p>
<p>（注：代理最好开全局模式，不然容易卡住）</p>
<p>具体步骤：</p>
<p>1.先hexo d 一遍</p>
<p>2.hexo cl + hexo g </p>
<p>3.删除文件</p>
<p>4.hexo d</p>
]]></content>
      
        
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2022/07/27/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
